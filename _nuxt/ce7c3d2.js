/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[9],Array(279).concat([function(e,t,n){"use strict";n.r(t),n.d(t,"AdadeltaOptimizer",(function(){return Et})),n.d(t,"AdagradOptimizer",(function(){return Rt})),n.d(t,"AdamOptimizer",(function(){return Ft})),n.d(t,"AdamaxOptimizer",(function(){return Pt})),n.d(t,"MomentumOptimizer",(function(){return Bt})),n.d(t,"Optimizer",(function(){return $t})),n.d(t,"OptimizerConstructors",(function(){return Vt})),n.d(t,"RMSPropOptimizer",(function(){return zt})),n.d(t,"SGDOptimizer",(function(){return Lt})),n.d(t,"Tensor",(function(){return ce.a})),n.d(t,"TensorBuffer",(function(){return ce.b})),n.d(t,"Variable",(function(){return ce.c})),n.d(t,"Rank",(function(){return Wt.a})),n.d(t,"sumOutType",(function(){return Wt.b})),n.d(t,"upcastType",(function(){return Wt.c})),n.d(t,"abs",(function(){return Ut.b})),n.d(t,"acos",(function(){return Ut.c})),n.d(t,"acosh",(function(){return Ut.d})),n.d(t,"add",(function(){return Ut.e})),n.d(t,"addN",(function(){return Ut.f})),n.d(t,"all",(function(){return Ut.g})),n.d(t,"any",(function(){return Ut.h})),n.d(t,"argMax",(function(){return Ut.i})),n.d(t,"argMin",(function(){return Ut.j})),n.d(t,"asin",(function(){return Ut.k})),n.d(t,"asinh",(function(){return Ut.l})),n.d(t,"atan",(function(){return Ut.m})),n.d(t,"atan2",(function(){return Ut.n})),n.d(t,"atanh",(function(){return Ut.o})),n.d(t,"avgPool",(function(){return Ut.p})),n.d(t,"avgPool3d",(function(){return Ut.q})),n.d(t,"basicLSTMCell",(function(){return Ut.r})),n.d(t,"batchToSpaceND",(function(){return Ut.w})),n.d(t,"batchNorm",(function(){return Ut.s})),n.d(t,"batchNorm2d",(function(){return Ut.t})),n.d(t,"batchNorm3d",(function(){return Ut.u})),n.d(t,"batchNorm4d",(function(){return Ut.v})),n.d(t,"bincount",(function(){return Ut.x})),n.d(t,"broadcastArgs",(function(){return Ut.z})),n.d(t,"broadcastTo",(function(){return Ut.A})),n.d(t,"buffer",(function(){return Ut.B})),n.d(t,"cast",(function(){return Ut.C})),n.d(t,"ceil",(function(){return Ut.D})),n.d(t,"clipByValue",(function(){return Ut.E})),n.d(t,"clone",(function(){return Ut.F})),n.d(t,"complex",(function(){return Ut.G})),n.d(t,"concat",(function(){return Ut.H})),n.d(t,"concat1d",(function(){return Ut.I})),n.d(t,"concat2d",(function(){return Ut.J})),n.d(t,"concat3d",(function(){return Ut.K})),n.d(t,"concat4d",(function(){return Ut.L})),n.d(t,"conv1d",(function(){return Ut.M})),n.d(t,"conv2d",(function(){return Ut.N})),n.d(t,"conv2dTranspose",(function(){return Ut.O})),n.d(t,"conv3d",(function(){return Ut.P})),n.d(t,"conv3dTranspose",(function(){return Ut.Q})),n.d(t,"cos",(function(){return Ut.R})),n.d(t,"cosh",(function(){return Ut.S})),n.d(t,"cumprod",(function(){return Ut.U})),n.d(t,"cumsum",(function(){return Ut.V})),n.d(t,"denseBincount",(function(){return Ut.W})),n.d(t,"depthToSpace",(function(){return Ut.X})),n.d(t,"depthwiseConv2d",(function(){return Ut.Y})),n.d(t,"diag",(function(){return Ut.Z})),n.d(t,"dilation2d",(function(){return Ut.ab})),n.d(t,"div",(function(){return Ut.bb})),n.d(t,"divNoNan",(function(){return Ut.cb})),n.d(t,"dot",(function(){return Ut.db})),n.d(t,"einsum",(function(){return Ut.fb})),n.d(t,"elu",(function(){return Ut.gb})),n.d(t,"equal",(function(){return Ut.ib})),n.d(t,"erf",(function(){return Ut.jb})),n.d(t,"euclideanNorm",(function(){return Ut.kb})),n.d(t,"exp",(function(){return Ut.lb})),n.d(t,"expandDims",(function(){return Ut.mb})),n.d(t,"expm1",(function(){return Ut.nb})),n.d(t,"eye",(function(){return Ut.ob})),n.d(t,"fill",(function(){return Ut.qb})),n.d(t,"floor",(function(){return Ut.rb})),n.d(t,"floorDiv",(function(){return Ut.sb})),n.d(t,"gather",(function(){return Ut.ub})),n.d(t,"greater",(function(){return Ut.wb})),n.d(t,"greaterEqual",(function(){return Ut.xb})),n.d(t,"imag",(function(){return Ut.zb})),n.d(t,"isFinite",(function(){return Ut.Db})),n.d(t,"isInf",(function(){return Ut.Eb})),n.d(t,"isNaN",(function(){return Ut.Fb})),n.d(t,"leakyRelu",(function(){return Ut.Gb})),n.d(t,"less",(function(){return Ut.Hb})),n.d(t,"lessEqual",(function(){return Ut.Ib})),n.d(t,"linspace",(function(){return Ut.Kb})),n.d(t,"localResponseNormalization",(function(){return Ut.Lb})),n.d(t,"log",(function(){return Ut.Mb})),n.d(t,"log1p",(function(){return Ut.Nb})),n.d(t,"logSigmoid",(function(){return Ut.Ob})),n.d(t,"logSoftmax",(function(){return Ut.Pb})),n.d(t,"logSumExp",(function(){return Ut.Qb})),n.d(t,"logicalAnd",(function(){return Ut.Rb})),n.d(t,"logicalNot",(function(){return Ut.Sb})),n.d(t,"logicalOr",(function(){return Ut.Tb})),n.d(t,"logicalXor",(function(){return Ut.Ub})),n.d(t,"lowerBound",(function(){return Ut.Wb})),n.d(t,"matMul",(function(){return Ut.Xb})),n.d(t,"max",(function(){return Ut.Yb})),n.d(t,"maxPool",(function(){return Ut.Zb})),n.d(t,"maxPool3d",(function(){return Ut.ac})),n.d(t,"maxPoolWithArgmax",(function(){return Ut.bc})),n.d(t,"maximum",(function(){return Ut.cc})),n.d(t,"mean",(function(){return Ut.dc})),n.d(t,"meshgrid",(function(){return Ut.ec})),n.d(t,"min",(function(){return Ut.fc})),n.d(t,"minimum",(function(){return Ut.gc})),n.d(t,"mirrorPad",(function(){return Ut.hc})),n.d(t,"mod",(function(){return Ut.ic})),n.d(t,"moments",(function(){return Ut.jc})),n.d(t,"mul",(function(){return Ut.lc})),n.d(t,"multiRNNCell",(function(){return Ut.mc})),n.d(t,"multinomial",(function(){return Ut.nc})),n.d(t,"neg",(function(){return Ut.oc})),n.d(t,"notEqual",(function(){return Ut.qc})),n.d(t,"oneHot",(function(){return Ut.rc})),n.d(t,"ones",(function(){return Ut.sc})),n.d(t,"onesLike",(function(){return Ut.tc})),n.d(t,"outerProduct",(function(){return Ut.vc})),n.d(t,"pad",(function(){return Ut.wc})),n.d(t,"pad1d",(function(){return Ut.xc})),n.d(t,"pad2d",(function(){return Ut.yc})),n.d(t,"pad3d",(function(){return Ut.zc})),n.d(t,"pad4d",(function(){return Ut.Ac})),n.d(t,"pool",(function(){return Ut.Bc})),n.d(t,"pow",(function(){return Ut.Cc})),n.d(t,"prelu",(function(){return Ut.Dc})),n.d(t,"print",(function(){return Ut.Ec})),n.d(t,"prod",(function(){return Ut.Fc})),n.d(t,"raggedTensorToTensor",(function(){return Ut.Gc})),n.d(t,"rand",(function(){return Ut.Hc})),n.d(t,"randomGamma",(function(){return Ut.Ic})),n.d(t,"randomNormal",(function(){return Ut.Jc})),n.d(t,"randomStandardNormal",(function(){return Ut.Kc})),n.d(t,"randomUniform",(function(){return Ut.Lc})),n.d(t,"range",(function(){return Ut.Mc})),n.d(t,"real",(function(){return Ut.Nc})),n.d(t,"reciprocal",(function(){return Ut.Oc})),n.d(t,"relu",(function(){return Ut.Pc})),n.d(t,"relu6",(function(){return Ut.Qc})),n.d(t,"reshape",(function(){return Ut.Rc})),n.d(t,"reverse",(function(){return Ut.Sc})),n.d(t,"reverse1d",(function(){return Ut.Tc})),n.d(t,"reverse2d",(function(){return Ut.Uc})),n.d(t,"reverse3d",(function(){return Ut.Vc})),n.d(t,"reverse4d",(function(){return Ut.Wc})),n.d(t,"round",(function(){return Ut.Yc})),n.d(t,"rsqrt",(function(){return Ut.Zc})),n.d(t,"scalar",(function(){return Ut.ad})),n.d(t,"selu",(function(){return Ut.dd})),n.d(t,"separableConv2d",(function(){return Ut.ed})),n.d(t,"setdiff1dAsync",(function(){return Ut.fd})),n.d(t,"sigmoid",(function(){return Ut.gd})),n.d(t,"sign",(function(){return Ut.hd})),n.d(t,"sin",(function(){return Ut.jd})),n.d(t,"sinh",(function(){return Ut.kd})),n.d(t,"slice",(function(){return Ut.ld})),n.d(t,"slice1d",(function(){return Ut.md})),n.d(t,"slice2d",(function(){return Ut.nd})),n.d(t,"slice3d",(function(){return Ut.od})),n.d(t,"slice4d",(function(){return Ut.pd})),n.d(t,"softmax",(function(){return Ut.qd})),n.d(t,"softplus",(function(){return Ut.rd})),n.d(t,"spaceToBatchND",(function(){return Ut.sd})),n.d(t,"fft",(function(){return Ut.pb})),n.d(t,"ifft",(function(){return Ut.yb})),n.d(t,"irfft",(function(){return Ut.Cb})),n.d(t,"rfft",(function(){return Ut.Xc})),n.d(t,"split",(function(){return Ut.wd})),n.d(t,"sqrt",(function(){return Ut.xd})),n.d(t,"square",(function(){return Ut.yd})),n.d(t,"squaredDifference",(function(){return Ut.zd})),n.d(t,"squeeze",(function(){return Ut.Ad})),n.d(t,"stack",(function(){return Ut.Bd})),n.d(t,"step",(function(){return Ut.Cd})),n.d(t,"stridedSlice",(function(){return Ut.Dd})),n.d(t,"sub",(function(){return Ut.Fd})),n.d(t,"sum",(function(){return Ut.Gd})),n.d(t,"tan",(function(){return Ut.Hd})),n.d(t,"tanh",(function(){return Ut.Id})),n.d(t,"tensor",(function(){return Ut.Jd})),n.d(t,"tensor1d",(function(){return Ut.Kd})),n.d(t,"tensor2d",(function(){return Ut.Ld})),n.d(t,"tensor3d",(function(){return Ut.Md})),n.d(t,"tensor4d",(function(){return Ut.Nd})),n.d(t,"tensor5d",(function(){return Ut.Od})),n.d(t,"tensor6d",(function(){return Ut.Pd})),n.d(t,"tile",(function(){return Ut.Qd})),n.d(t,"topk",(function(){return Ut.Rd})),n.d(t,"truncatedNormal",(function(){return Ut.Td})),n.d(t,"unique",(function(){return Ut.Ud})),n.d(t,"unsortedSegmentSum",(function(){return Ut.Vd})),n.d(t,"unstack",(function(){return Ut.Wd})),n.d(t,"upperBound",(function(){return Ut.Xd})),n.d(t,"variable",(function(){return Ut.Yd})),n.d(t,"where",(function(){return Ut.Zd})),n.d(t,"whereAsync",(function(){return Ut.ae})),n.d(t,"zeros",(function(){return Ut.be})),n.d(t,"zerosLike",(function(){return Ut.ce})),n.d(t,"booleanMaskAsync",(function(){return Ut.y})),n.d(t,"transpose",(function(){return Ut.Sd})),n.d(t,"norm",(function(){return Ut.pc})),n.d(t,"movingAverage",(function(){return Ut.kc})),n.d(t,"scatterND",(function(){return Ut.bd})),n.d(t,"searchSorted",(function(){return Ut.cd})),n.d(t,"sparseToDense",(function(){return Ut.ud})),n.d(t,"gatherND",(function(){return Ut.vb})),n.d(t,"dropout",(function(){return Ut.eb})),n.d(t,"enclosingPowerOfTwo",(function(){return Ut.hb})),n.d(t,"cosineWindow",(function(){return Ut.T})),n.d(t,"inTopKAsync",(function(){return Ut.Bb})),n.d(t,"op",(function(){return Ut.uc})),n.d(t,"OP_SCOPE_SUFFIX",(function(){return Ut.a})),n.d(t,"image",(function(){return Ut.Ab})),n.d(t,"linalg",(function(){return Ut.Jb})),n.d(t,"losses",(function(){return Ut.Vb})),n.d(t,"spectral",(function(){return Ut.vd})),n.d(t,"fused",(function(){return Ut.tb})),n.d(t,"signal",(function(){return Ut.id})),n.d(t,"sparse",(function(){return Ut.td})),n.d(t,"string",(function(){return Ut.Ed})),n.d(t,"Reduction",(function(){return Gt.a})),n.d(t,"train",(function(){return Ht})),n.d(t,"enableProdMode",(function(){return kt.g})),n.d(t,"enableDebugMode",(function(){return kt.f})),n.d(t,"disableDeprecationWarnings",(function(){return kt.c})),n.d(t,"deprecationWarn",(function(){return kt.b})),n.d(t,"disposeVariables",(function(){return kt.e})),n.d(t,"engine",(function(){return kt.h})),n.d(t,"memory",(function(){return kt.m})),n.d(t,"profile",(function(){return kt.n})),n.d(t,"tidy",(function(){return kt.t})),n.d(t,"dispose",(function(){return kt.d})),n.d(t,"keep",(function(){return kt.l})),n.d(t,"time",(function(){return kt.u})),n.d(t,"setBackend",(function(){return kt.r})),n.d(t,"ready",(function(){return kt.o})),n.d(t,"getBackend",(function(){return kt.k})),n.d(t,"removeBackend",(function(){return kt.q})),n.d(t,"findBackend",(function(){return kt.i})),n.d(t,"findBackendFactory",(function(){return kt.j})),n.d(t,"registerBackend",(function(){return kt.p})),n.d(t,"backend",(function(){return kt.a})),n.d(t,"setPlatform",(function(){return kt.s})),n.d(t,"getKernel",(function(){return Be.c})),n.d(t,"getGradient",(function(){return Be.b})),n.d(t,"getKernelsForBackend",(function(){return Be.d})),n.d(t,"registerKernel",(function(){return Be.f})),n.d(t,"registerGradient",(function(){return Be.e})),n.d(t,"unregisterKernel",(function(){return Be.h})),n.d(t,"unregisterGradient",(function(){return Be.g})),n.d(t,"copyRegisteredKernels",(function(){return Be.a})),n.d(t,"customGrad",(function(){return jt.a})),n.d(t,"grad",(function(){return jt.b})),n.d(t,"grads",(function(){return jt.c})),n.d(t,"valueAndGrad",(function(){return jt.d})),n.d(t,"valueAndGrads",(function(){return jt.e})),n.d(t,"variableGrads",(function(){return jt.f})),n.d(t,"Environment",(function(){return v.b})),n.d(t,"env",(function(){return v.c})),n.d(t,"ENV",(function(){return v.a})),n.d(t,"version_core",(function(){return Ot})),n.d(t,"nextFrame",(function(){return qt.a})),n.d(t,"browser",(function(){return c})),n.d(t,"io",(function(){return r})),n.d(t,"math",(function(){return o})),n.d(t,"serialization",(function(){return h})),n.d(t,"test_util",(function(){return xt})),n.d(t,"util",(function(){return vt})),n.d(t,"backend_util",(function(){return m})),n.d(t,"broadcast_util",(function(){return Pe})),n.d(t,"tensor_util",(function(){return yt})),n.d(t,"slice_util",(function(){return d})),n.d(t,"gather_util",(function(){return l})),n.d(t,"scatter_util",(function(){return Xe})),n.d(t,"device_util",(function(){return rr})),n.d(t,"kernel_impls",(function(){return y})),n.d(t,"KernelBackend",(function(){return or.b})),n.d(t,"DataStorage",(function(){return or.a})),n.d(t,"Abs",(function(){return Le.a})),n.d(t,"Acos",(function(){return Le.b})),n.d(t,"Acosh",(function(){return Le.c})),n.d(t,"Add",(function(){return Le.d})),n.d(t,"AddN",(function(){return Le.e})),n.d(t,"All",(function(){return Le.f})),n.d(t,"Any",(function(){return Le.g})),n.d(t,"ArgMax",(function(){return Le.h})),n.d(t,"ArgMin",(function(){return Le.i})),n.d(t,"Asin",(function(){return Le.j})),n.d(t,"Asinh",(function(){return Le.k})),n.d(t,"Atan",(function(){return Le.l})),n.d(t,"Atanh",(function(){return Le.n})),n.d(t,"Atan2",(function(){return Le.m})),n.d(t,"AvgPool",(function(){return Le.o})),n.d(t,"AvgPoolGrad",(function(){return Le.r})),n.d(t,"AvgPool3D",(function(){return Le.p})),n.d(t,"AvgPool3DGrad",(function(){return Le.q})),n.d(t,"BatchMatMul",(function(){return Le.s})),n.d(t,"BatchToSpaceND",(function(){return Le.t})),n.d(t,"Bincount",(function(){return Le.u})),n.d(t,"BroadcastTo",(function(){return Le.w})),n.d(t,"BroadcastArgs",(function(){return Le.v})),n.d(t,"Cast",(function(){return Le.x})),n.d(t,"Ceil",(function(){return Le.y})),n.d(t,"ClipByValue",(function(){return Le.z})),n.d(t,"Complex",(function(){return Le.A})),n.d(t,"ComplexAbs",(function(){return Le.B})),n.d(t,"Concat",(function(){return Le.C})),n.d(t,"Conv2D",(function(){return Le.D})),n.d(t,"Conv2DBackpropFilter",(function(){return Le.E})),n.d(t,"Conv2DBackpropInput",(function(){return Le.F})),n.d(t,"Conv3D",(function(){return Le.G})),n.d(t,"Conv3DBackpropFilterV2",(function(){return Le.H})),n.d(t,"Conv3DBackpropInputV2",(function(){return Le.I})),n.d(t,"Cos",(function(){return Le.J})),n.d(t,"Cosh",(function(){return Le.K})),n.d(t,"Cumprod",(function(){return Le.M})),n.d(t,"Cumsum",(function(){return Le.N})),n.d(t,"CropAndResize",(function(){return Le.L})),n.d(t,"DenseBincount",(function(){return Le.O})),n.d(t,"DepthToSpace",(function(){return Le.P})),n.d(t,"DepthwiseConv2dNative",(function(){return Le.Q})),n.d(t,"DepthwiseConv2dNativeBackpropFilter",(function(){return Le.R})),n.d(t,"DepthwiseConv2dNativeBackpropInput",(function(){return Le.S})),n.d(t,"Diag",(function(){return Le.T})),n.d(t,"Dilation2D",(function(){return Le.U})),n.d(t,"Dilation2DBackpropInput",(function(){return Le.W})),n.d(t,"Dilation2DBackpropFilter",(function(){return Le.V})),n.d(t,"RealDiv",(function(){return Le.qc})),n.d(t,"Einsum",(function(){return Le.X})),n.d(t,"Elu",(function(){return Le.Y})),n.d(t,"EluGrad",(function(){return Le.Z})),n.d(t,"Erf",(function(){return Le.bb})),n.d(t,"Equal",(function(){return Le.ab})),n.d(t,"Exp",(function(){return Le.cb})),n.d(t,"ExpandDims",(function(){return Le.db})),n.d(t,"Expm1",(function(){return Le.eb})),n.d(t,"FFT",(function(){return Le.fb})),n.d(t,"Fill",(function(){return Le.gb})),n.d(t,"FlipLeftRight",(function(){return Le.hb})),n.d(t,"Floor",(function(){return Le.ib})),n.d(t,"FloorDiv",(function(){return Le.jb})),n.d(t,"FusedBatchNorm",(function(){return Le.lb})),n.d(t,"GatherV2",(function(){return Le.pb})),n.d(t,"GatherNd",(function(){return Le.ob})),n.d(t,"Greater",(function(){return Le.qb})),n.d(t,"GreaterEqual",(function(){return Le.rb})),n.d(t,"Identity",(function(){return Le.tb})),n.d(t,"IFFT",(function(){return Le.sb})),n.d(t,"Imag",(function(){return Le.ub})),n.d(t,"IsFinite",(function(){return Le.vb})),n.d(t,"IsInf",(function(){return Le.wb})),n.d(t,"IsNan",(function(){return Le.xb})),n.d(t,"LeakyRelu",(function(){return Le.Ab})),n.d(t,"Less",(function(){return Le.Bb})),n.d(t,"LessEqual",(function(){return Le.Cb})),n.d(t,"LinSpace",(function(){return Le.Db})),n.d(t,"Log",(function(){return Le.Eb})),n.d(t,"Log1p",(function(){return Le.Fb})),n.d(t,"LogicalAnd",(function(){return Le.Hb})),n.d(t,"LogicalNot",(function(){return Le.Ib})),n.d(t,"LogicalOr",(function(){return Le.Jb})),n.d(t,"LogicalXor",(function(){return Le.Kb})),n.d(t,"LogSoftmax",(function(){return Le.Gb})),n.d(t,"LowerBound",(function(){return Le.Lb})),n.d(t,"LRN",(function(){return Le.yb})),n.d(t,"LRNGrad",(function(){return Le.zb})),n.d(t,"Max",(function(){return Le.Mb})),n.d(t,"Maximum",(function(){return Le.Sb})),n.d(t,"MaxPool",(function(){return Le.Nb})),n.d(t,"MaxPoolGrad",(function(){return Le.Qb})),n.d(t,"MaxPool3D",(function(){return Le.Ob})),n.d(t,"MaxPool3DGrad",(function(){return Le.Pb})),n.d(t,"MaxPoolWithArgmax",(function(){return Le.Rb})),n.d(t,"Mean",(function(){return Le.Tb})),n.d(t,"Min",(function(){return Le.Ub})),n.d(t,"Minimum",(function(){return Le.Vb})),n.d(t,"MirrorPad",(function(){return Le.Wb})),n.d(t,"Mod",(function(){return Le.Xb})),n.d(t,"Multinomial",(function(){return Le.Yb})),n.d(t,"Multiply",(function(){return Le.Zb})),n.d(t,"Neg",(function(){return Le.ac})),n.d(t,"NotEqual",(function(){return Le.ec})),n.d(t,"NonMaxSuppressionV3",(function(){return Le.bc})),n.d(t,"NonMaxSuppressionV4",(function(){return Le.cc})),n.d(t,"NonMaxSuppressionV5",(function(){return Le.dc})),n.d(t,"OnesLike",(function(){return Le.gc})),n.d(t,"OneHot",(function(){return Le.fc})),n.d(t,"Pack",(function(){return Le.hc})),n.d(t,"PadV2",(function(){return Le.ic})),n.d(t,"Pool",(function(){return Le.jc})),n.d(t,"Pow",(function(){return Le.kc})),n.d(t,"Prelu",(function(){return Le.lc})),n.d(t,"Prod",(function(){return Le.mc})),n.d(t,"RaggedTensorToTensor",(function(){return Le.nc})),n.d(t,"Range",(function(){return Le.oc})),n.d(t,"Real",(function(){return Le.pc})),n.d(t,"Reciprocal",(function(){return Le.rc})),n.d(t,"Relu",(function(){return Le.sc})),n.d(t,"Reshape",(function(){return Le.uc})),n.d(t,"ResizeNearestNeighbor",(function(){return Le.xc})),n.d(t,"ResizeNearestNeighborGrad",(function(){return Le.yc})),n.d(t,"ResizeBilinear",(function(){return Le.vc})),n.d(t,"ResizeBilinearGrad",(function(){return Le.wc})),n.d(t,"Relu6",(function(){return Le.tc})),n.d(t,"Reverse",(function(){return Le.zc})),n.d(t,"Round",(function(){return Le.Bc})),n.d(t,"Rsqrt",(function(){return Le.Cc})),n.d(t,"ScatterNd",(function(){return Le.Dc})),n.d(t,"SearchSorted",(function(){return Le.Ec})),n.d(t,"Select",(function(){return Le.Fc})),n.d(t,"Selu",(function(){return Le.Gc})),n.d(t,"Slice",(function(){return Le.Lc})),n.d(t,"Sin",(function(){return Le.Jc})),n.d(t,"Sinh",(function(){return Le.Kc})),n.d(t,"Sign",(function(){return Le.Ic})),n.d(t,"Sigmoid",(function(){return Le.Hc})),n.d(t,"Softplus",(function(){return Le.Nc})),n.d(t,"Sqrt",(function(){return Le.Vc})),n.d(t,"Sum",(function(){return Le.ed})),n.d(t,"SpaceToBatchND",(function(){return Le.Oc})),n.d(t,"SplitV",(function(){return Le.Uc})),n.d(t,"Softmax",(function(){return Le.Mc})),n.d(t,"SparseFillEmptyRows",(function(){return Le.Pc})),n.d(t,"SparseReshape",(function(){return Le.Qc})),n.d(t,"SparseSegmentMean",(function(){return Le.Rc})),n.d(t,"SparseSegmentSum",(function(){return Le.Sc})),n.d(t,"SparseToDense",(function(){return Le.Tc})),n.d(t,"SquaredDifference",(function(){return Le.Xc})),n.d(t,"Square",(function(){return Le.Wc})),n.d(t,"StridedSlice",(function(){return Le.Zc})),n.d(t,"StringNGrams",(function(){return Le.ad})),n.d(t,"StringSplit",(function(){return Le.bd})),n.d(t,"StringToHashBucketFast",(function(){return Le.cd})),n.d(t,"Sub",(function(){return Le.dd})),n.d(t,"Tan",(function(){return Le.fd})),n.d(t,"Tanh",(function(){return Le.gd})),n.d(t,"Tile",(function(){return Le.hd})),n.d(t,"TopK",(function(){return Le.id})),n.d(t,"Transform",(function(){return Le.jd})),n.d(t,"Transpose",(function(){return Le.kd})),n.d(t,"Unique",(function(){return Le.ld})),n.d(t,"Unpack",(function(){return Le.md})),n.d(t,"UnsortedSegmentSum",(function(){return Le.nd})),n.d(t,"UpperBound",(function(){return Le.od})),n.d(t,"ZerosLike",(function(){return Le.pd})),n.d(t,"Step",(function(){return Le.Yc})),n.d(t,"FromPixels",(function(){return Le.kb})),n.d(t,"RotateWithOffset",(function(){return Le.Ac})),n.d(t,"_FusedMatMul",(function(){return Le.qd})),n.d(t,"FusedConv2D",(function(){return Le.mb})),n.d(t,"FusedDepthwiseConv2D",(function(){return Le.nb}));var r={};n.r(r),n.d(r,"copyModel",(function(){return ne})),n.d(r,"listModels",(function(){return ee})),n.d(r,"moveModel",(function(){return re})),n.d(r,"removeModel",(function(){return te})),n.d(r,"browserFiles",(function(){return fe})),n.d(r,"browserHTTPRequest",(function(){return Ie})),n.d(r,"concatenateArrayBuffers",(function(){return O.d})),n.d(r,"decodeWeights",(function(){return O.e})),n.d(r,"encodeWeights",(function(){return O.f})),n.d(r,"fromMemory",(function(){return je})),n.d(r,"fromMemorySync",(function(){return Ce})),n.d(r,"getLoadHandlers",(function(){return N})),n.d(r,"getModelArtifactsForJSON",(function(){return O.g})),n.d(r,"getModelArtifactsInfoForJSON",(function(){return O.h})),n.d(r,"getSaveHandlers",(function(){return S})),n.d(r,"http",(function(){return we})),n.d(r,"isHTTPScheme",(function(){return Oe})),n.d(r,"loadWeights",(function(){return ye})),n.d(r,"registerLoadRouter",(function(){return I})),n.d(r,"registerSaveRouter",(function(){return w})),n.d(r,"weightsLoaderFactory",(function(){return xe})),n.d(r,"withSaveHandler",(function(){return $e})),n.d(r,"withSaveHandlerSync",(function(){return Ee}));var o={};n.r(o),n.d(o,"confusionMatrix",(function(){return Me}));var c={};n.r(c),n.d(c,"fromPixelsAsync",(function(){return Ge})),n.d(c,"toPixels",(function(){return He})),n.d(c,"fromPixels",(function(){return qe}));var l={};n.r(l),n.d(l,"prepareAndValidate",(function(){return Ke}));var d={};n.r(d),n.d(d,"assertParamsValid",(function(){return Ye})),n.d(d,"maskToAxes",(function(){return Ze})),n.d(d,"computeOutShape",(function(){return Qe})),n.d(d,"stridesWithElidedDims",(function(){return Je})),n.d(d,"getNormalizedAxes",(function(){return nt})),n.d(d,"startIndicesWithElidedDims",(function(){return at})),n.d(d,"stopIndicesWithElidedDims",(function(){return st})),n.d(d,"stridesForAxis",(function(){return ot})),n.d(d,"startForAxis",(function(){return it})),n.d(d,"stopForAxis",(function(){return ut})),n.d(d,"isSliceContinous",(function(){return ct})),n.d(d,"computeFlatOffset",(function(){return lt})),n.d(d,"parseSliceParams",(function(){return pt})),n.d(d,"sliceInfo",(function(){return ht}));var h={};n.r(h),n.d(h,"Serializable",(function(){return mt})),n.d(h,"SerializationMap",(function(){return bt})),n.d(h,"registerClass",(function(){return gt}));var f={};n.r(f),n.d(f,"segOpComputeOptimalWindowSize",(function(){return Zn})),n.d(f,"computeOutShape",(function(){return Qn})),n.d(f,"collectGatherOpShapeInfo",(function(){return Jn}));var m={};n.r(m),n.d(m,"axesAreInnerMostDims",(function(){return Kt.b})),n.d(m,"combineLocations",(function(){return Kt.c})),n.d(m,"computeOutAndReduceShapes",(function(){return Kt.d})),n.d(m,"expandShapeToKeepDim",(function(){return Kt.e})),n.d(m,"assertAxesAreInnerMostDims",(function(){return Kt.a})),n.d(m,"getAxesPermutation",(function(){return Kt.f})),n.d(m,"getUndoAxesPermutation",(function(){return Kt.h})),n.d(m,"getInnerMostAxes",(function(){return Kt.g})),n.d(m,"getBroadcastDims",(function(){return Pe.getBroadcastDims})),n.d(m,"getReductionAxes",(function(){return Pe.getReductionAxes})),n.d(m,"assertAndGetBroadcastShape",(function(){return Pe.assertAndGetBroadcastShape})),n.d(m,"assertParamsConsistent",(function(){return Xt})),n.d(m,"computeOutShape",(function(){return Yt})),n.d(m,"computeDilation2DInfo",(function(){return Qt.e})),n.d(m,"computePool2DInfo",(function(){return Qt.f})),n.d(m,"computePool3DInfo",(function(){return Qt.g})),n.d(m,"computeConv2DInfo",(function(){return Qt.b})),n.d(m,"computeConv3DInfo",(function(){return Qt.c})),n.d(m,"computeDefaultPad",(function(){return Qt.d})),n.d(m,"tupleValuesAreOne",(function(){return Qt.j})),n.d(m,"eitherStridesOrDilationsAreOne",(function(){return Qt.i})),n.d(m,"convertConv2DDataFormat",(function(){return Qt.h})),n.d(m,"checkPadOnDimRoundingMode",(function(){return Qt.a})),n.d(m,"getFusedDyActivation",(function(){return Jt.c})),n.d(m,"getFusedBiasGradient",(function(){return Jt.b})),n.d(m,"applyActivation",(function(){return Jt.a})),n.d(m,"shouldFuse",(function(){return Jt.d})),n.d(m,"RowPartitionType",(function(){return Zt})),n.d(m,"combineRaggedTensorToTensorShapes",(function(){return en})),n.d(m,"getRowPartitionTypesHelper",(function(){return tn})),n.d(m,"getRaggedRank",(function(){return nn})),n.d(m,"validateDefaultValueShape",(function(){return rn})),n.d(m,"PARALLELIZE_THRESHOLD",(function(){return an})),n.d(m,"computeOptimalWindowSize",(function(){return sn})),n.d(m,"slice_util",(function(){return d})),n.d(m,"upcastType",(function(){return Wt.c})),n.d(m,"getImageCenter",(function(){return on})),n.d(m,"getReshaped",(function(){return un})),n.d(m,"getPermuted",(function(){return cn})),n.d(m,"getReshapedPermuted",(function(){return ln})),n.d(m,"getSliceBeginCoords",(function(){return dn})),n.d(m,"getSliceSize",(function(){return pn})),n.d(m,"prepareAndValidate",(function(){return Ke})),n.d(m,"validateUpdateShape",(function(){return Xe.validateUpdateShape})),n.d(m,"validateInput",(function(){return Xe.validateInput})),n.d(m,"calculateShapes",(function(){return Xe.calculateShapes})),n.d(m,"SELU_SCALEALPHA",(function(){return hn})),n.d(m,"SELU_SCALE",(function(){return fn})),n.d(m,"ERF_P",(function(){return mn})),n.d(m,"ERF_A1",(function(){return bn})),n.d(m,"ERF_A2",(function(){return gn})),n.d(m,"ERF_A3",(function(){return yn})),n.d(m,"ERF_A4",(function(){return xn})),n.d(m,"ERF_A5",(function(){return vn})),n.d(m,"warn",(function(){return On.b})),n.d(m,"log",(function(){return On.a})),n.d(m,"mergeRealAndImagArrays",(function(){return kn})),n.d(m,"splitRealAndImagArrays",(function(){return wn})),n.d(m,"complexWithEvenIndex",(function(){return In})),n.d(m,"complexWithOddIndex",(function(){return Sn})),n.d(m,"getComplexWithIndex",(function(){return Nn})),n.d(m,"assignToTypedArray",(function(){return Tn})),n.d(m,"exponents",(function(){return jn})),n.d(m,"exponent",(function(){return Cn})),n.d(m,"decodeEinsumEquation",(function(){return An})),n.d(m,"getEinsumPermutation",(function(){return Rn})),n.d(m,"checkEinsumDimSizes",(function(){return _n})),n.d(m,"getEinsumComputePath",(function(){return Fn})),n.d(m,"isIdentityPermutation",(function(){return Dn})),n.d(m,"prepareSplitSize",(function(){return Pn})),n.d(m,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",(function(){return Ln})),n.d(m,"getSparseFillEmptyRowsNegativeIndexErrorMessage",(function(){return Bn})),n.d(m,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",(function(){return zn})),n.d(m,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",(function(){return Vn})),n.d(m,"getSparseReshapeNegativeOutputDimErrorMessage",(function(){return Wn})),n.d(m,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",(function(){return Un})),n.d(m,"getSparseReshapeInputOutputMultipleErrorMessage",(function(){return Gn})),n.d(m,"getSparseReshapeInputOutputMismatchErrorMessage",(function(){return Hn})),n.d(m,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",(function(){return qn})),n.d(m,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",(function(){return Kn})),n.d(m,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",(function(){return Xn})),n.d(m,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",(function(){return Yn})),n.d(m,"segment_util",(function(){return f})),n.d(m,"fromUint8ToStringArray",(function(){return er})),n.d(m,"fromStringArrayToUint8",(function(){return nr}));var y={};n.r(y),n.d(y,"nonMaxSuppressionV3Impl",(function(){return ar.a})),n.d(y,"nonMaxSuppressionV4Impl",(function(){return ar.b})),n.d(y,"nonMaxSuppressionV5Impl",(function(){return ar.c})),n.d(y,"whereImpl",(function(){return sr.a}));var x=n(282),v=(n(335),n(294)),O=n(306);class k{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==k.instance&&(k.instance=new k),k.instance}static registerSaveRouter(e){k.getInstance().saveRouters.push(e)}static registerLoadRouter(e){k.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return k.getHandlers(e,"save")}static getLoadHandlers(e,t){return k.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?k.getInstance().loadRouters:k.getInstance().saveRouters).forEach((t=>{const o=t(e,n);null!==o&&r.push(o)})),r}}const w=e=>k.registerSaveRouter(e),I=e=>k.registerLoadRouter(e),S=e=>k.getSaveHandlers(e),N=(e,t)=>k.getLoadHandlers(e,t),T="tensorflowjs",j="models_store",C="model_info_store";function $(){if(!Object(v.c)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function E(e){const t=e.result;t.createObjectStore(j,{keyPath:"modelPath"}),t.createObjectStore(C,{keyPath:"modelPath"})}class A{constructor(e){if(this.indexedDB=$(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(T,1);r.onupgradeneeded=()=>E(r),r.onsuccess=()=>{const o=r.result;if(null==t){const t=o.transaction(j,"readonly"),r=t.objectStore(j).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(o.close(),n(r.error)),t.oncomplete=()=>o.close()}else{const r=Object(O.h)(t),c=o.transaction(C,"readwrite");let l=c.objectStore(C);const d=l.put({modelPath:this.modelPath,modelArtifactsInfo:r});let h;d.onsuccess=()=>{h=o.transaction(j,"readwrite");const d=h.objectStore(j).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});d.onsuccess=()=>e({modelArtifactsInfo:r}),d.onerror=e=>{l=c.objectStore(C);const t=l.delete(this.modelPath);t.onsuccess=()=>(o.close(),n(d.error)),t.onerror=e=>(o.close(),n(d.error))}},d.onerror=e=>(o.close(),n(d.error)),c.oncomplete=()=>{null==h?o.close():h.oncomplete=()=>o.close()}}},r.onerror=e=>n(r.error)}))}}A.URL_SCHEME="indexeddb://";const R=e=>{return Object(v.c)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(A.URL_SCHEME)?(t=e.slice(A.URL_SCHEME.length),new A(t)):null;var t};k.registerSaveRouter(R),k.registerLoadRouter(R);class _{constructor(){this.indexedDB=$()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(T,1);n.onupgradeneeded=()=>E(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(C,"readonly"),c=o.objectStore(C).getAll();c.onsuccess=()=>{const t={};for(const e of c.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},c.onerror=e=>(r.close(),t(c.error)),o.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(path){var e;return path=(e=path).startsWith(A.URL_SCHEME)?e.slice(A.URL_SCHEME.length):e,new Promise(((e,t)=>{const n=this.indexedDB.open(T,1);n.onupgradeneeded=()=>E(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(C,"readwrite"),c=o.objectStore(C),l=c.get(path);let d;l.onsuccess=()=>{if(null==l.result)return r.close(),t(new Error(`Cannot find model with path '${path}' in IndexedDB.`));{const n=c.delete(path),o=()=>{d=r.transaction(j,"readwrite");const n=d.objectStore(j).delete(path);n.onsuccess=()=>e(l.result.modelArtifactsInfo),n.onerror=e=>t(l.error)};n.onsuccess=o,n.onerror=e=>(o(),r.close(),t(l.error))}},l.onerror=e=>(r.close(),t(l.error)),o.oncomplete=()=>{null==d?r.close():d.oncomplete=()=>r.close()}},n.onerror=e=>t(n.error)}))}}var F=n(320);const D="/",M="tensorflowjs_models",P="info",L="model_topology",B="weight_specs",z="weight_data",V="model_metadata";function W(path){return{info:[M,path,P].join(D),topology:[M,path,L].join(D),weightSpecs:[M,path,B].join(D),weightData:[M,path,z].join(D),modelMetadata:[M,path,V].join(D)}}function U(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function G(e){const t=e.split(D);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(D)}class H{constructor(e){if(!Object(v.c)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=W(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Object(O.h)(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Object(O.a)(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch(e){throw U(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const e=JSON.parse(o);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const c=this.LS.getItem(this.keys.weightData);if(null==c)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Object(O.b)(c),t}}H.URL_SCHEME="localstorage://";const K=e=>{return Object(v.c)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(H.URL_SCHEME)?(t=e.slice(H.URL_SCHEME.length),new H(t)):null;var t};k.registerSaveRouter(K),k.registerLoadRouter(K);class X{constructor(){Object(F.b)(Object(v.c)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Object(F.b)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=M+D,n=D+P;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(n)){e[G(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(path){var e;const t=W(path=(e=path).startsWith(H.URL_SCHEME)?e.slice(H.URL_SCHEME.length):e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${path}'`);const n=JSON.parse(this.LS.getItem(t.info));return U(t),n}}const Y="://";class Z{constructor(){this.managers={}}static getInstance(){return null==Z.instance&&(Z.instance=new Z),Z.instance}static registerManager(e,t){Object(F.b)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Y)&&(e=e.slice(0,e.indexOf(Y))),Object(F.b)(e.length>0,(()=>"scheme must not be an empty string."));const n=Z.getInstance();Object(F.b)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Z.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Z.getInstance().managers)}}function Q(e){if(-1===e.indexOf(Y))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Z.getSchemes().join(",")}`);return{scheme:e.split(Y)[0],path:e.split(Y)[1]}}async function J(e,t,n=!1){Object(F.b)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=k.getLoadHandlers(e);Object(F.b)(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Object(F.b)(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const o=r[0],c=k.getSaveHandlers(t);Object(F.b)(c.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Object(F.b)(c.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const l=c[0],d=Q(e).scheme,h=Q(e).path,f=d===Q(e).scheme,m=await o.load();n&&f&&await Z.getManager(d).removeModel(h);const y=await l.save(m);return n&&!f&&await Z.getManager(d).removeModel(h),y.modelArtifactsInfo}async function ee(){const e=Z.getSchemes(),t={};for(const n of e){const e=await Z.getManager(n).listModels();for(const path in e){t[n+Y+path]=e[path]}}return t}async function te(e){const t=Q(e);return Z.getManager(t.scheme).removeModel(t.path)}async function ne(e,t){return J(e,t,!1)}async function re(e,t){return J(e,t,!0)}class ae{fetch(path,e){return fetch(path,e)}now(){return performance.now()}encode(text,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(text)}decode(e,t){return new TextDecoder(t).decode(e)}}if(Object(v.c)().get("IS_BROWSER")){Object(v.c)().setPlatform("browser",new ae);try{Z.registerManager(H.URL_SCHEME,new X)}catch(e){}try{Z.registerManager(A.URL_SCHEME,new _)}catch(e){}}n(417);var se=n(309),oe=n(298),ie=n(328),ue=n(359),ce=n(301);Object(x.b)();const le={buffer:se.a,cast:oe.a,clone:ie.a,print:ue.a};Object(ce.e)(le);function de(e){return new Promise((e=>setTimeout(e))).then(e)}class pe{constructor(e){if(!Object(v.c)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(pe.URL_SCHEME)&&(e=e.slice(pe.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Object(O.i)(e,n),o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),c=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(c.download=this.modelJsonFileName,c.href=o,await de((()=>c.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await de((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Object(O.h)(e)}}}}pe.URL_SCHEME="downloads://";class he{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),o=r.modelTopology;if(null==o)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:o});const c=Object(O.g)(r,(e=>this.loadWeights(e)));e(c)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),o=n.map((path=>this.loadWeightsFile(path,r[path])));return Promise.all(o).then((e=>[t,Object(O.d)(e)]))}loadWeightsFile(path,e){return new Promise(((t,n)=>{const r=new FileReader;r.onload=e=>{const n=e.target.result;t(n)},r.onerror=e=>n(`Failed to weights data from file of path '${path}'.`),r.readAsArrayBuffer(e)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>Object(O.c)(e.name))),r={};for(const o of e)o.paths.forEach((path=>{const e=Object(O.c)(path);if(-1!==t.indexOf(e))throw new Error(`Duplicate file basename found in weights manifest: '${e}'`);if(t.push(e),-1===n.indexOf(e))throw new Error(`Weight file with basename '${e}' is not provided.`);r[path]=this.weightsFiles[n.indexOf(e)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function fe(e){return new he(e)}function me(e,t,n,r){!function(e){Object(F.b)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Object(F.b)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Object(F.b)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Object(F.b)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(e.map((c=>(c.then((c=>{const l=n+ ++o/e.length*(r-n);return t(l),c})),c))))}k.registerSaveRouter((e=>Object(v.c)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(pe.URL_SCHEME)?function(e="model"){return new pe(e)}(e.slice(pe.URL_SCHEME.length)):null));var be=n(406);async function ge(e,t){null==t&&(t={});const n=null==t.fetchFunc?Object(v.c)().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),o=(null==t.onProgress?await Promise.all(r):await me(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(o):await me(o,t.onProgress,.5,1)}async function ye(e,t="",n,r){return xe((e=>ge(e,{requestInit:r})))(e,t,n)}function xe(e){return async(t,n="",r)=>{const o=t.map((()=>!1)),c={},l=null!=r?r.map((()=>!1)):[],d=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const h="quantization"in e?e.quantization.dtype:e.dtype,f=be.a[h]*F.O(e.shape),m=()=>{o[t]=!0,null==c[t]&&(c[t]=[]),c[t].push({manifestEntry:e,groupOffset:n,sizeBytes:f})};null!=r?r.forEach(((t,n)=>{t===e.name&&(m(),l[n]=!0)})):m(),d.push(e.name),n+=f}))})),!l.every((e=>e))){const e=r.filter(((e,i)=>!l[i]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${d.join(", ")}.`)}const h=o.reduce(((e,t,i)=>(t&&e.push(i),e)),[]),f=[];h.forEach((i=>{t[i].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;f.push(t)}))}));const m=await e(f),y={};let x=0;return h.forEach((i=>{const e=t[i].paths.length;let n=0;for(let i=0;i<e;i++)n+=m[x+i].byteLength;const r=new ArrayBuffer(n),o=new Uint8Array(r);let l=0;for(let i=0;i<e;i++){const e=new Uint8Array(m[x+i]);o.set(e,l),l+=e.byteLength}c[i].forEach((e=>{const t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=Object(O.e)(t,[e.manifestEntry]);for(const e in n)y[e]=n[e]})),x+=e})),y}}class ve{constructor(path,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Object(F.b)("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Object(v.c)().platform.fetch,Object(F.b)(null!=path&&path.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(path)&&Object(F.b)(2===path.length,(()=>`URL paths for http must have a length of 2, (actual length is ${path.length}).`)),this.path=path,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Object(O.i)(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Object(O.h)(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Object(O.g)(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),o=n>t?e.substring(n):"";return[r+"/",o]}(t),o=this.weightPathPrefix||n,c=[];for(const t of e)c.push(...t.weights);const l=[],d=[];for(const t of e)for(const path of t.paths)null!=this.weightUrlConverter?d.push(this.weightUrlConverter(path)):l.push(o+path+r);this.weightUrlConverter&&l.push(...await Promise.all(d));const h=await ge(l,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[c,Object(O.d)(h)]}}function Oe(e){return null!=e.match(ve.URL_SCHEME_REGEX)}ve.URL_SCHEME_REGEX=/^https?:\/\//;const ke=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Oe(e))):Oe(e),n)return we(e,t)}return null};function we(path,e){return new ve(path,e)}function Ie(path,e){return we(path,e)}k.registerSaveRouter(ke),k.registerLoadRouter(ke);class Se{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Ne{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Te{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function je(e,t,n,r){const o=arguments;return new Te(Ce(...o))}function Ce(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Se(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Se({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Se({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function $e(e){return new Ne(e)}function Ee(e){return new Ne(e)}var Ae=n(281),Re=n(312),_e=n(364),Fe=n(280),De=n(350);const Me=Object(Fe.b)({confusionMatrix_:function(e,t,n){const r=Object(Ae.a)(e,"labels","confusionMatrix"),o=Object(Ae.a)(t,"predictions","confusionMatrix");F.b(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),F.b(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),F.b(1===o.rank,(()=>`Expected the rank of predictions to be 1, but got ${o.rank}`)),F.b(r.shape[0]===o.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`)),F.b(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const c=Object(_e.a)(Object(oe.a)(r,"int32"),n),l=Object(_e.a)(Object(oe.a)(o,"int32"),n),d=Object(De.a)(c),h=Object(Re.a)(d,l);return Object(oe.a)(h,"int32")}});var Pe=n(292),Le=n(283),Be=n(348),ze=n(369);let Ve;function We(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,o=!1,c=!1,l=!1,d=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)c=!0;else if(null!=e.getContext)l=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);d=!0}if(null!=Object(Be.c)(Le.kb,x.a.backendName)){const n={pixels:e},r={numChannels:t};return x.a.runKernel(Le.kb,n,r)}const[h,f]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height];let m,y;if(l)m=e.getContext("2d").getImageData(0,0,h,f).data;else if(r||n)m=e.data;else if(c||o||d){if(null==Ve)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ve=new OffscreenCanvas(1,1).getContext("2d")}else Ve=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ve.canvas.width=h,Ve.canvas.height=f,Ve.drawImage(e,0,0,h,f),m=Ve.getImageData(0,0,h,f).data}if(4===t)y=new Int32Array(m);else{const e=h*f;y=new Int32Array(e*t);for(let i=0;i<e;i++)for(let e=0;e<t;++e)y[i*t+e]=m[4*i+e]}const v=[f,h,t];return Object(ze.a)(y,v,"int32")}function Ue(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function Ge(e,t=3){let n=null;if(Object(v.c)().getBool("WRAP_TO_IMAGEBITMAP")&&Ue(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return We(n,t)}async function He(img,canvas){let e=Object(Ae.a)(img,"img","toPixels");if(!(img instanceof ce.a)){const t=e;e=Object(oe.a)(t,"int32"),t.dispose()}if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const[t,n]=e.shape.slice(0,2),r=2===e.rank?1:e.shape[2];if(r>4||2===r)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${r}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);const data=await e.data(),o="float32"===e.dtype?255:1,c=new Uint8ClampedArray(n*t*4);for(let i=0;i<t*n;++i){const t=[0,0,0,255];for(let n=0;n<r;n++){const c=data[i*r+n];if("float32"===e.dtype){if(c<0||c>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${c}.`)}else if("int32"===e.dtype&&(c<0||c>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${c}.`);1===r?(t[0]=c*o,t[1]=c*o,t[2]=c*o):t[n]=c*o}const n=4*i;c[n+0]=Math.round(t[0]),c[n+1]=Math.round(t[1]),c[n+2]=Math.round(t[2]),c[n+3]=Math.round(t[3])}if(null!=canvas){canvas.width=n,canvas.height=t;const e=canvas.getContext("2d"),r=new ImageData(c,n,t);e.putImageData(r,0,0)}return e!==img&&e.dispose(),c}const qe=Object(Fe.b)({fromPixels_:We});function Ke(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Object(F.O)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const o=t.shape,c=o[o.length-1];let l=1;for(let i=0;i<o.length-1;++i)l*=o[i];const d=e.shape,h=o.slice();h.pop();let f=1;for(let i=c;i<n;++i)f*=d[i],h.push(d[i]);const m=[...Object(F.j)(e.shape).map((e=>e/f)),1].slice(0,c);return[h,l,f,m]}var Xe=n(343);function Ye(input,e,t){const n=input.shape.length;F.b(n===e.length,(()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`)),F.b(n===t.length,(()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`));for(let i=0;i<n;++i)F.b(e[i]+t[i]<=input.shape[i],(()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${input.shape[i]})`))}function Ze(mask){const e=[];let t=0;for(;mask>0;)1&mask&&e.push(t),mask/=2,t++;return e}function Qe(e,t,n){const r=[];for(let o=0;o<e.length;o++)r[o]=Math.ceil((t[o]-e[o])/n[o]);return r}function Je(e,t,n,r){const o=[...e];for(let i=o.length;i<r.length;i++)o.push(1);for(let i=0;i<n;i++)0===i?o[t]=1:(o.splice(t,0,1),o.pop());return o}function et(e,t,n){return n<=e?n:n-(t-1)}function tt(e,t){const n=[];for(let i=0;i<e;i++)n.push(t+i);return n}function nt(e,t,n,r,o,c,l,d,h){const f=e.length;let m=new Array(f),y=new Array(f),x=new Array(f);if(t.length&&n>0){const h=t[0],f=n+1;m=at(l,h,f,r,e),y=st(d,h,f,o,e),x=Je(c,h,f,e)}else for(let t=0;t<f;t++)m[t]=it(l,r,c,e,t,h),y[t]=ut(d,o,c,e,t,h),x[t]=ot(c,t,h);return{begin:m,end:y,strides:x}}function at(e,t,n,r,o){const c=[...o],l=tt(n,t);for(let o=0;o<c.length;o++)if(l.indexOf(o)>-1)c[o]=0;else{const l=et(t,n,o);let d=r[l];e&1<<l&&(d=0),c[o]=d}return c}function st(e,t,n,r,o){const c=[...o],l=tt(n,t);for(let o=0;o<c.length;o++)if(l.indexOf(o)>-1)c[o]=Number.MAX_SAFE_INTEGER;else{const l=et(t,n,o);let d=r[l];e&1<<l&&(d=Number.MAX_SAFE_INTEGER),c[o]=d}for(let i=0;i<c.length;i++){const e=o[i];c[i]<0&&(c[i]+=e),c[i]=F.i(0,c[i],o[i])}return c}function ot(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function it(e,t,n,r,o,c){let l=t[o];const d=n[o]||1;(e&1<<o||c&1<<o||null==l)&&(l=d>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const h=r[o];return l<0&&(l+=h),l=F.i(0,l,h-1),l}function ut(e,t,n,r,o,c){let l=t[o];const d=n[o]||1;(e&1<<o||c&1<<o||null==l)&&(l=d>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const h=r[o];return l<0&&(l+=h),l=d>0?F.i(0,l,h):F.i(-1,l,h-1),l}function ct(e,t,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function lt(e,t){let n=e.length>0?e[e.length-1]:1;for(let i=0;i<e.length-1;i++)n+=e[i]*t[i];return n}function pt(e,t,n){let r;const o=e.shape.length;let c;return r="number"==typeof t?[t,...new Array(o-1).fill(0)]:t.length<o?t.concat(new Array(o-t.length).fill(0)):t.slice(),r.forEach((e=>{F.b(-1!==e,(()=>"slice() does not support negative begin indexing."))})),c=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,c=c.map(((t,i)=>t>=0?t:(F.b(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${i}.`)),e.shape[i]-r[i]))),[r,c]}function ht(e,t,n,r,o,c,l,d,h){let f;if(null==r?(f=new Array(t.length),f.fill(1)):f=r,null!=l&&0!=(l&l-1))throw new Error("Multiple ellipses in slice is not allowed.");let m=!1;const y={dims:f.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:f.slice(),beginMask:o,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h};for(let i=0;i<y.dims;i++)m&&0!=(1<<i&d)&&y.numAddAxisAfterEllipsis++,1<<i&l&&(m=!0);m||(y.ellipsisMask|=1<<y.dims,y.dims++);const x={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let i=0;i<e.dims;i++)if(1<<i&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-i)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=i}else if(1<<i&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[i]),null!=e.end&&(t.end[n]=e.end[i]),t.strides[n]=e.strides[i],e.beginMask&1<<i&&(t.beginMask|=1<<n),e.endMask&1<<i&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<i?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(i)),t.inputShapeGatherIndicesSparse[n]=i,n++}}(y,x);let v=!0,O=!0,k=!0;const w=[],I=[];for(let i=0;i<e.length;++i){if(0===x.strides[i])throw Error(`strides[${i}] must be non-zero`);const t=!!(x.shrinkAxisMask&1<<i),n=e[i];if(-1===n){w.push(t?1:-1);continue}const r=[x.beginMask&1<<i,x.endMask&1<<i],o=[x.strides[i]>0?0:-1,x.strides[i]>0?n:n-1];if(t&&x.strides[i]<=0)throw Error("only stride 1 allowed on non-range indexing.");k=k&&1===x.strides[i];const c=!!(x.beginMask&1<<i&&x.endMask&1<<i);if(x.beginValid&&x.endValid){if(t){const e=x.begin[i]<0?n+x.begin[i]:x.begin[i];if(x.begin[i]=e,x.end[i]=x.begin[i]+1,e<0||e>=n)throw Error(`slice index ${x.begin[i]} of dimension ${i} out of bounds.`)}else x.begin[i]=ft(x.begin[i],0,x.strides[i],n,r,o),x.end[i]=ft(x.end[i],1,x.strides[i],n,r,o);const e=1===x.strides[i]&&0===x.begin[i]&&x.end[i]===n;v=v&&e,O=O&&(0===i&&1===x.strides[i]||e)}else v=v&&1===x.strides[i]&&c,O=O&&(0===i&&1===x.strides[i]||c);let l,d=!1;if(x.beginValid&&x.endValid?(l=x.end[i]-x.begin[i],d=!0):t?(l=1,d=!0):c&&n>=0&&(l=x.strides[i]<0?-n:n,d=!0),d){let e;e=0===l||l<0!=x.strides[i]<0?0:Math.trunc(l/x.strides[i])+(l%x.strides[i]!=0?1:0),w.push(e)}else w.push(-1)}for(let e=0;e<x.finalShapeGatherIndices.length;++e){const t=x.finalShapeGatherIndices[e];t>=0?I.push(w[t]):-2===t&&I.push(1)}return{finalShapeSparse:I.filter(((e,i)=>-2!==x.finalShapeGatherIndices[i])),finalShape:I,isIdentity:v,sliceDim0:O,isSimpleSlice:k,begin:x.begin,end:x.end,strides:x.strides}}function ft(e,t,n,r,o,c){if(o[t])return n>0?c[t]:c[t+1&1];{const t=e<0?r+e:e;return t<c[0]?c[0]:t>c[1]?c[1]:t}}class mt{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class bt{constructor(){this.classNameMap={}}static getMap(){return null==bt.instance&&(bt.instance=new bt),bt.instance}static register(e){bt.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function gt(e){Object(F.b)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Object(F.b)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Object(F.b)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),bt.register(e)}var yt=n(288),xt=n(366),vt=n(284);const Ot="3.20.0";var kt=n(304),wt=n(291),div=n(299),It=n(289),St=n(329),Nt=n(311),Tt=n(310),jt=n(302),Ct=n(297);class $t extends mt{minimize(e,t=!1,n){const{value:r,grads:o}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:o[e.name]})));this.applyGradients(e)}else this.applyGradients(o);return Object(kt.d)(o),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Object(jt.f)(e,t)}dispose(){null!=this.iterations_&&Object(kt.d)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Object(Ct.a)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty($t,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Et extends $t{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=x.a.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,i)=>{const n=x.a.registeredVariables[t];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${t}/accum_grad`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(false)))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${t}/accum_var`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(false)))});const r=Array.isArray(e)?e[i].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;Object(kt.t)((()=>{const e=Object(wt.a)(Object(It.a)(o,this.rho),Object(It.a)(Object(Nt.a)(r),1-this.rho)),t=Object(It.a)(Object(div.a)(Object(St.a)(Object(wt.a)(c,this.epsilon)),Object(St.a)(Object(wt.a)(o,this.epsilon))),r),l=Object(wt.a)(Object(It.a)(c,this.rho),Object(It.a)(Object(Nt.a)(t),1-this.rho));o.assign(e),c.assign(l);const d=Object(wt.a)(Object(It.a)(t,-this.learningRate),n);n.assign(d)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Object(kt.d)(this.accumulatedGrads.map((e=>e.variable))),Object(kt.d)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}Et.className="Adadelta",gt(Et);var At=n(337);class Rt extends $t{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,i)=>{const n=x.a.registeredVariables[t];if(null==this.accumulatedGrads[i]){const e=!1;this.accumulatedGrads[i]={originalName:`${t}/accumulator`,variable:Object(kt.t)((()=>Object(At.a)(n.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[i].tensor:e[t];if(null==r)return;const o=this.accumulatedGrads[i].variable;Object(kt.t)((()=>{const e=Object(wt.a)(o,Object(Nt.a)(r));o.assign(e);const t=Object(wt.a)(Object(It.a)(Object(div.a)(r,Object(St.a)(Object(wt.a)(e,x.a.backend.epsilon()))),-this.learningRate),n);n.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Object(kt.d)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Rt.className="Adagrad",gt(Rt);var _t=n(338),sub=n(295);class Ft extends $t{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Object(kt.t)((()=>{this.accBeta1=Object(Ct.a)(t).variable(),this.accBeta2=Object(Ct.a)(n).variable()})),null==r&&(this.epsilon=x.a.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Object(kt.t)((()=>{const n=Object(sub.a)(1,this.accBeta1),r=Object(sub.a)(1,this.accBeta2);t.forEach(((t,i)=>{const o=x.a.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:Object(kt.t)((()=>Object(Tt.a)(o).variable(false)))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:Object(kt.t)((()=>Object(Tt.a)(o).variable(false)))});const c=Array.isArray(e)?e[i].tensor:e[t];if(null==c)return;const l=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=Object(wt.a)(Object(It.a)(l,this.beta1),Object(It.a)(c,1-this.beta1)),f=Object(wt.a)(Object(It.a)(d,this.beta2),Object(It.a)(Object(Nt.a)(c),1-this.beta2)),m=Object(div.a)(h,n),y=Object(div.a)(f,r);l.assign(h),d.assign(f);const v=Object(wt.a)(Object(It.a)(Object(div.a)(m,Object(wt.a)(Object(St.a)(y),this.epsilon)),-this.learningRate),o);o.assign(v)})),this.accBeta1.assign(Object(It.a)(this.accBeta1,this.beta1)),this.accBeta2.assign(Object(It.a)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object(kt.d)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Object(kt.d)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Object(kt.t)((()=>{this.accBeta1.assign(Object(_t.a)(this.beta1,this.iterations_+1)),this.accBeta2.assign(Object(_t.a)(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Ft.className="Adam",gt(Ft);var Dt=n(322),Mt=n(361);class Pt extends $t{constructor(e,t,n,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Object(kt.t)((()=>{this.iteration=Object(Ct.a)(0).variable(),this.accBeta1=Object(Ct.a)(t).variable()})),null==r&&(this.epsilon=x.a.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Object(kt.t)((()=>{const n=Object(sub.a)(1,this.accBeta1),r=Object(div.a)(-this.learningRate,Object(wt.a)(Object(It.a)(this.iteration,this.decay),1));t.forEach(((t,i)=>{const o=x.a.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:Object(Tt.a)(o).variable(false)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:Object(Tt.a)(o).variable(false)});const c=Array.isArray(e)?e[i].tensor:e[t];if(null==c)return;const l=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=Object(wt.a)(Object(It.a)(l,this.beta1),Object(It.a)(c,1-this.beta1)),f=Object(It.a)(d,this.beta2),m=Object(Dt.a)(c),y=Object(Mt.a)(f,m);l.assign(h),d.assign(y);const v=Object(wt.a)(Object(It.a)(Object(div.a)(r,n),Object(div.a)(h,Object(wt.a)(y,this.epsilon))),o);o.assign(v)})),this.iteration.assign(Object(wt.a)(this.iteration,1)),this.accBeta1.assign(Object(It.a)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object(kt.d)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Object(kt.d)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Pt.className="Adamax",gt(Pt);class Lt extends $t{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,i)=>{const n=Array.isArray(e)?e[i].tensor:e[t];if(null==n)return;const r=x.a.registeredVariables[t];Object(kt.t)((()=>{const e=Object(wt.a)(Object(It.a)(this.c,n),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Object(kt.l)(Object(Ct.a)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Lt.className="SGD",gt(Lt);class Bt extends Lt{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Object(Ct.a)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,i)=>{const n=x.a.registeredVariables[t];if(null==this.accumulations[i]){const e=!1;this.accumulations[i]={originalName:`${t}/momentum`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(e)))}}const r=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[t];null!=o&&Object(kt.t)((()=>{let e;const t=Object(wt.a)(Object(It.a)(this.m,r),o);e=this.useNesterov?Object(wt.a)(Object(It.a)(this.c,Object(wt.a)(o,Object(It.a)(t,this.m))),n):Object(wt.a)(Object(It.a)(this.c,t),n),r.assign(t),n.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Object(kt.d)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Bt.className="Momentum",gt(Bt);class zt extends $t{constructor(e,t=.9,n=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==r&&(this.epsilon=x.a.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,i)=>{const n=x.a.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${t}/rms`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(r)))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${t}/momentum`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(r)))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${t}/mg`,variable:Object(kt.t)((()=>Object(Tt.a)(n).variable(r)))});const o=Array.isArray(e)?e[i].tensor:e[t];if(null==o)return;const c=this.accumulatedMeanSquares[i].variable,l=this.accumulatedMoments[i].variable;Object(kt.t)((()=>{const e=Object(wt.a)(Object(It.a)(c,this.decay),Object(It.a)(Object(Nt.a)(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[i].variable,r=Object(wt.a)(Object(It.a)(t,this.decay),Object(It.a)(o,1-this.decay)),d=Object(div.a)(Object(It.a)(o,this.learningRate),Object(St.a)(Object(sub.a)(e,Object(wt.a)(Object(Nt.a)(r),this.epsilon)))),h=Object(wt.a)(Object(It.a)(l,this.momentum),d);c.assign(e),t.assign(r),l.assign(h);const f=Object(sub.a)(n,h);n.assign(f)}else{const e=Object(wt.a)(Object(It.a)(c,this.decay),Object(It.a)(Object(Nt.a)(o),1-this.decay)),t=Object(wt.a)(Object(It.a)(l,this.momentum),Object(div.a)(Object(It.a)(o,this.learningRate),Object(St.a)(Object(wt.a)(e,this.epsilon))));c.assign(e),l.assign(t);const r=Object(sub.a)(n,t);n.assign(r)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Object(kt.d)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Object(kt.d)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Object(kt.d)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}zt.className="RMSProp",gt(zt);class Vt{static sgd(e){return new Lt(e)}static momentum(e,t,n=!1){return new Bt(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,o=!1){return new zt(e,t,n,r,o)}static adam(e=.001,t=.9,n=.999,r=null){return new Ft(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Et(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,o=0){return new Pt(e,t,n,r,o)}static adagrad(e,t=.1){return new Rt(e,t)}}var Wt=n(321),Ut=n(334),Gt=n(308);const Ht={sgd:Vt.sgd,momentum:Vt.momentum,adadelta:Vt.adadelta,adagrad:Vt.adagrad,rmsprop:Vt.rmsprop,adamax:Vt.adamax,adam:Vt.adam};var qt=n(408),Kt=n(330);function Xt(e,t){const n=e[0].length;e.forEach(((e,i)=>{F.b(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`))})),F.b(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,i)=>{for(let o=0;o<n;o++)F.b(o===t||e[o]===r[o],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`))}))}function Yt(e,t){const n=e[0].slice();for(let i=1;i<e.length;i++)n[t]+=e[i][t];return n}var Zt,Qt=n(300),Jt=n(323);function en(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){const o=n[i],c=r[r.length-n.length+i],l=r[c];if(o>=0)if(l>=0){if(l!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+e}] = ${o} but shape[${i+e}] = ${l}`)}else r[c]=o}return r}function tn(e){const t={FIRST_DIM_SIZE:Zt.FIRST_DIM_SIZE,VALUE_ROWIDS:Zt.VALUE_ROWIDS,ROW_LENGTHS:Zt.ROW_LENGTHS,ROW_SPLITS:Zt.ROW_SPLITS,ROW_LIMITS:Zt.ROW_LIMITS,ROW_STARTS:Zt.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function nn(e){return 0===e.length?0:e[0]===Zt.FIRST_DIM_SIZE?e.length-1:e.length}function rn(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){const n=e[i],r=t[i+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-e.length}] = ${n} but ragged tensor input.flatValues.shape[${i-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zt||(Zt={}));const an=30;function sn(e){return e<=an?e:Object(F.G)(e,Math.floor(Math.sqrt(e)))}function on(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function un(e,t,n,r=!0){let o=[];if(r)o=o.concat(t.slice(0)),o.push(e[0]/n),o=o.concat(e.slice(1));else{o=o.concat(e[0]);const n=t.length;for(let i=0;i<n;++i)o=o.concat([e[i+1]/t[i],t[i]]);o=o.concat(e.slice(n+1))}return o}function cn(e,t,n=!0){const r=[];if(n){r.push(t);for(let i=t+1;i<e;++i)i<=2*t?(r.push(i),r.push(i-(t+1))):r.push(i)}else{const n=[],o=[];for(let i=1;i<e;++i)i>=2*t+1||i%2==1?o.push(i):n.push(i);r.push(...n),r.push(0),r.push(...o)}return r}function ln(e,t,n,r=!0){const o=[];r?o.push(e[0]/n):o.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?r?o.push(t[i-1]*e[i]):o.push(e[i]/t[i-1]):o.push(e[i]);return o}function dn(e,t){const n=[0];for(let i=0;i<t;++i)n.push(e[i][0]);return n}function pn(e,t,n){const r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}const hn=1.7580993408473768,fn=1.0507009873554805,mn=.3275911,bn=.254829592,gn=-.284496736,yn=1.421413741,xn=-1.453152027,vn=1.061405429;var On=n(347);function kn(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let i=0;i<n.length;i+=2)n[i]=e[i/2],n[i+1]=t[i/2];return n}function wn(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let i=0;i<e.length;i+=2)t[i/2]=e[i],n[i/2]=e[i+1];return{real:t,imag:n}}function In(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let i=0;i<e.length;i+=4)n[Math.floor(i/4)]=e[i],r[Math.floor(i/4)]=e[i+1];return{real:n,imag:r}}function Sn(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let i=2;i<e.length;i+=4)n[Math.floor(i/4)]=e[i],r[Math.floor(i/4)]=e[i+1];return{real:n,imag:r}}function Nn(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Tn(data,e,t,n){data[2*n]=e,data[2*n+1]=t}function jn(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){const o=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:n,imag:r}}function Cn(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const $n="->",En=/->/g;function An(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(En,"").length)/$n.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,o]=e.split($n);Object(F.b)(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const c=r.split(","),l=c.length;if(t!==l)throw new Error(`Expected ${l} input tensors, received ${t}`);if(l>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const d=[];for(let i=0;i<o.length;++i){const e=o[i];if(!c.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===d.indexOf(e)&&d.push(e)}for(let i=0;i<r.length;++i){const e=r[i];-1===d.indexOf(e)&&","!==e&&d.push(e)}const h=new Array(c.length);for(let i=0;i<l;++i){if(new Set(c[i].split("")).size!==c[i].length)throw new Error(`Found duplicate axes in input component ${c[i]}. Support for duplicate axes in input is not implemented yet.`);h[i]=[];for(let e=0;e<c[i].length;++e)h[i].push(d.indexOf(c[i][e]))}const f=d.length,m=[];for(let i=o.length;i<f;++i)m.push(i);return{allDims:d,summedDims:m,idDims:h}}function Rn(e,t){let n=new Array(e);n.fill(-1);for(let i=0;i<t.length;++i)n[t[i]]=i;const r=[];for(let i=0;i<e;++i)-1===n[i]&&r.push(i);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function _n(e,t,n){const r=new Array(e);for(let i=0;i<n.length;++i){const e=n[i].shape;for(let n=0;n<t[i].length;++n)void 0===r[t[i][n]]?r[t[i][n]]=e[n]:Object(F.b)(r[t[i][n]]===e[n],(()=>`Expected dimension ${r[t[i][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Fn(e,t){const path=e,n=[];let r=0;0===e.length&&path.push(-1),r=e.length+1;for(let i=0;i<r;++i)n.push([]);const o=[];for(let i=0;i<path.length;++i){const e=Mn(t,path[i]);for(const t of e)-1===o.indexOf(t)&&(n[i].push(t),o.push(t))}return{path:path,steps:n}}function Dn(e){return e.every(((e,t)=>e===t))}function Mn(e,t){const n=[];for(let i=0;i<e.length;++i)0!==e[i].length&&-1===e[i].indexOf(t)&&-1!==t||n.push(i);return n}function Pn(e,t,n=0){let r=[];if("number"==typeof t)Object(F.b)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const o=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Object(F.b)(o<=1,(()=>"There should be only one negative value in split array."));const c=t.indexOf(-1);if(-1!==c){const r=t.reduce(((a,b)=>b>0?a+b:a));t[c]=e.shape[n]-r}Object(F.b)(e.shape[n]===t.reduce(((a,b)=>a+b)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Ln(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Bn(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function zn(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Vn(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Wn(e,t){return`size ${e} must be non-negative, not ${t}`}function Un(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Gn(e,t){return`Input to reshape is a SparseTensor with ${Object(F.O)(e)}\n  dense values, but the requested shape requires a multiple of ${Object(F.O)(t)}. inputShape=${e} outputShape= ${t}`}function Hn(e,t){return`Input to reshape is a tensor with ${Object(F.O)(e)} dense values, but the requested shape has ${Object(F.O)(t)}. inputShape=${e} outputShape=${t}`}function qn(){return"segment ids must be >= 0"}function Kn(){return"segment ids are not increasing"}function Xn(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Yn(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Zn(e,t){let n,r=!1;for(e<=an?(n=e,r=!0):n=Object(F.G)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Object(F.G)(e,n+1);return n}function Qn(e,t,n){const r=[],o=e.length;for(let c=0;c<o;c++)c!==t?r.push(e[c]):r.push(n);return r}function Jn(e,t,n,r){const o=t.shape.length,c=e.shape.length;if(0!==r&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>c)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${c}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let i=0;i<r;++i)if(e.shape[i]!==t.shape[i])throw new Error(`x.shape[${i}]: ${e.shape[i]} should be equal to indices.shape[${i}]: ${t.shape[i]}.`);const l=e.shape[n],d=[];let h=1,f=1,m=1;for(let i=0;i<r;++i)d.push(e.shape[i]),h*=e.shape[i];for(let i=r;i<n;i++)d.push(e.shape[i]),f*=e.shape[i];for(let i=r;i<o;i++)d.push(t.shape[i]);for(let i=n+1;i<c;i++)d.push(e.shape[i]),m*=e.shape[i];return{batchSize:h,sliceSize:m,outerSize:f,dimSize:l,outputShape:d}}function er(e){try{return e.map((e=>Object(vt.decodeString)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function nr(e){return e.map((s=>Object(vt.encodeString)(s)))}var rr=n(358),ar=n(327),sr=n(370),or=n(349)},function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return l}));var r=n(282),o=n(320);const c="__op";function l(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const l=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=c;const d=(...e)=>{r.a.startScope(n);try{const t=l(...e);return Object(o.x)(t)&&console.error("Cannot return a Promise inside of tidy."),r.a.endScope(t),t}catch(e){throw r.a.endScope(null),e}};return Object.defineProperty(d,"name",{value:n,configurable:!0}),d}},function(e,t,n){"use strict";n.d(t,"c",(function(){return h})),n.d(t,"a",(function(){return y})),n.d(t,"b",(function(){return x}));var r=n(282),o=n(294),c=n(301),l=n(320),d=n(284);function h(e,t){let n=e;if(Object(l.A)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Object(l.A)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Object(o.c)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&f(e,r,[]),r}function f(e,t,n){if(n=n||[],!Array.isArray(e)&&!Object(l.A)(e))return void Object(l.b)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Object(l.b)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Object(l.b)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let i=0;i<e.length;++i)f(e[i],r,n.concat(i))}function m(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function y(e,t,n,o="numeric"){if(e instanceof c.a)return m(o,e.dtype,t,n),e;let f=Object(l.r)(e);if("string"!==f&&["bool","int32","float32"].indexOf(o)>=0&&(f=o),m(o,f,t,n),null==e||!Object(l.A)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const y=h(e,f);Object(l.A)(e)||Array.isArray(e)||(e=[e]);const x="string"!==f?Object(d.toTypedArray)(e,f):Object(l.m)(e,[],!0);return r.a.makeTensor(x,y,f)}function x(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,i)=>y(e,`${t}[${i}]`,n,r)))}},function(e,t,n){"use strict";n.d(t,"b",(function(){return N})),n.d(t,"a",(function(){return T}));var r=n(349),o=n(294),c=n(357),l=n(283),d=n(348),h=n(347),f=n(284),m=n(320);class y{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new v)}profileKernel(e,t,n){let r;const c=()=>{r=n()};let l;const d=f.now();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(c);else{c();for(const output of r)output.dataSync();l=Promise.resolve({kernelMs:f.now()-d})}if(Object(o.c)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const output=r[i];output.data().then((t=>{x(t,output.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:l.then((e=>e.kernelMs)),extraInfo:l.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:o,extraInfo:c}=e;n.forEach((e=>{Promise.all([e.data(),r,c]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],o,n[2])}))}))}}function x(e,t,n){if("float32"!==t)return!1;for(let i=0;i<e.length;i++){const t=e[i];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class v{logKernelProfile(e,t,n,r,o,c){const time="number"==typeof r?m.L(`${r}ms`,9):r.error,l=m.L(e,25),d=t.rank,h=t.size,f=m.L(t.shape.toString(),14);let y="";for(const e in o){const input=o[e];if(null!=input){const n=input.shape||t.shape,r=n.length;y+=`${e}: ${r}D ${r>0?n:""} `}}console.log(`%c${l}\t%c${time}\t%c${d}D ${f}\t%c${h}\t%c${y}\t%c${c}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var O=n(301),k=n(288);function w(e){return null!=e.kernelName}class I{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class S{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new I}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const t=e[i];if(await this.initializeBackend(t).success)return void await this.setBackend(t)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(h.b(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new y(this.backendInstance),!0}setupRegisteredKernels(){Object(d.d)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Object(d.d)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.b||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,h.b(`Initialization of backend ${e} failed`),h.b(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return h.b(`Initialization of backend ${e} failed`),h.b(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((a,b)=>this.registryFactory[b].priority-this.registryFactory[a].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const t=e[i],{success:n,asyncInit:r}=this.initializeBackend(t);if(r||n)return{name:t,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,o=this.readSync(t),c=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,o,n.shape,n.dtype,c),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return S.nextTensorId++}nextVariableId(){return S.nextVariableId++}clone(e){const t=T.runKernel(l.tb,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return T.runKernel(l.x,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Object(d.c)(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let o=0;n.forEach((e=>{o+="complex64"===e.dtype?3:1}));const c=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-t-o-c;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),o=this.state.numBytes,c=this.state.numTensors;let l,h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const f=w(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(w(e)){const{kernelName:t,inputs:o,attrs:c}=e;null==this.backendName&&this.backend;const f=Object(d.c)(t,this.backendName);m.b(null!=f,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),l=()=>{const e=this.backend.numDataIds();h=f.kernelFunc({inputs:o,attrs:c,backend:this.backend});const l=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,l);const d=l.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,o,d);n=this.saveTensorsForBackwardMode(e)}return d}}else{const{forwardFunc:t}=e,o=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};l=()=>{const e=this.backend.numDataIds();h=this.tidy((()=>t(this.backend,o)));const n=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,e,n),n}}const{inputs:y,attrs:x}=e,v=w(e)?null:e.backwardsFunc;let O;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(O=this.profiler.profileKernel(f,y,(()=>l())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(O),t=O.outputs):t=l()})),r&&this.addTapeNode(f,y,t,v,n,x),this.state.profiling&&this.state.activeProfile.kernels.push({name:f,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-c,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(y).map((e=>null!=y[e]?y[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:O.timeMs,extraInfo:O.extraInfo}),Array.isArray(h)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Object(d.b)(e);if(null!=r){const e=r.inputsToSave||[],o=r.outputsToSave||[];let c;r.saveAllInputs?(m.b(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),c=Object.keys(t).map((e=>t[e]))):c=e.map((e=>t[e]));const l=n.filter(((e,i)=>o[i]));return c.concat(l)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=e;"string"===n&&m.z(e[0])&&(o=e.map((e=>f.encodeString(e))));const c=r.write(o,t,n),l=new O.a(t,n,c,this.nextTensorId());if(this.trackTensor(l,r),"string"===n){const e=this.state.tensorInfo.get(c),t=Object(m.f)(o);this.state.numBytes+=t-e.bytes,e.bytes=t}return l}makeTensorFromDataId(e,t,n,r){const o={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:o}=e,c=new O.a(r,o,n,this.nextTensorId());return this.trackTensor(c,t),c}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const o=new O.c(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(a,e){this.state.numTensors++,"string"===a.dtype&&this.state.numStringTensors++;let t=0;"complex64"!==a.dtype&&"string"!==a.dtype&&(t=a.size*m.g(a.dtype)),this.state.numBytes+=t,this.state.tensorInfo.has(a.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(a.dataId,{backend:e||this.backend,dtype:a.dtype,shape:a.shape,bytes:t})),a instanceof O.c||this.track(a)}incRef(a,e){this.trackTensor(a,e),this.backend.incRef(a.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;const e=this.state.tensorInfo.get(a.dataId);if(this.state.numTensors--,"string"===a.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==a.dtype&&"string"!==a.dtype){const e=a.size*m.g(a.dtype);this.state.numBytes-=e}e.backend.disposeData(a.dataId)&&this.removeDataId(a.dataId,e.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,o,c){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:o},h=Object(d.b)(e);null!=h&&(r=h.gradFunc),null!=r&&(l.gradient=e=>(e=e.map(((e,i)=>{if(null==e){const output=n[i],e=m.F(output.size,output.dtype);return this.makeTensor(e,output.shape,output.dtype)}return e})),r(e.length>1?e:e[0],o,c))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Object(k.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let i=0;i<this.state.activeScope.track.length;i++){const e=this.state.activeScope.track[i];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(m.b(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));m.b(o instanceof O.a,(()=>"The result y returned by f() must be a tensor."));const c=function(e,t,n){const r={},o={};for(let i=0;i<t.length;i++)r[t[i].id]=!0;for(let i=0;i<e.length;i++){const n=e[i],c=n.inputs;for(const e in c){const input=c[e];let l=!1;for(let e=0;e<t.length;e++)if(r[input.id]){n.outputs.forEach((output=>r[output.id]=!0)),l=!0,o[n.id]=!0;break}if(l)break}}const c={};c[n.id]=!0;const l={};for(let i=e.length-1;i>=0;i--){const t=e[i],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(c[t.outputs[e].id]){for(const e in n)c[n[e].id]=!0,l[t.id]=!0;break}}const d=[];for(let i=0;i<e.length;i++){const t=e[i];if(o[t.id]&&l[t.id]){const e={};for(const n in t.inputs){const o=t.inputs[n];r[o.id]&&(e[n]=o)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,d.push(n)}}return d}(this.state.activeTape,t,o);if(!r&&0===c.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[o.id]=null==n?function(e){const t=Object(m.D)(Object(m.O)(e),"float32");return T.makeTensor(t,e,"float32")}(o.shape):n,function(e,t,n,r){for(let i=t.length-1;i>=0;i--){const o=t[i],c=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?c.push(n):c.push(null)})),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const l=o.gradient(c);for(const t in o.inputs){if(!(t in l))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(l)}.`);const c=n((()=>l[t]()));if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[t];if(!m.a(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${t}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(null==e[d.id])e[d.id]=c;else{const t=e[d.id];e[d.id]=r(t,c),t.dispose()}}}}(e,c,(e=>this.tidy(e)),j);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(e){return m.b(m.u(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;m.b(t.every((e=>e instanceof O.a)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((input,i)=>{r[i]=input}));return this.runKernelFunc({forwardFunc:(r,o)=>(n=e(...t,o),m.b(n.value instanceof O.a,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),m.b(m.u(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const o=n.gradFunc(e,r),c=Array.isArray(o)?o:[o];m.b(c.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),m.b(c.every((e=>e instanceof O.a)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const l={};return c.forEach(((e,i)=>{l[i]=()=>e})),l},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Object(f.now)(),n=await this.backend.time(e);return n.wallMs=Object(f.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new I;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function N(){const e=Object(c.b)();if(null==e._tfengine){const t=new o.b(e);e._tfengine=new S(t)}return Object(o.d)(e._tfengine.ENV),Object(O.f)((()=>e._tfengine)),e._tfengine}S.nextTensorId=0,S.nextVariableId=0;const T=N();function j(a,b){const e={a:a,b:b};return T.runKernel(l.d,e)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return c})),n.d(t,"d",(function(){return l})),n.d(t,"e",(function(){return d})),n.d(t,"f",(function(){return h})),n.d(t,"g",(function(){return f})),n.d(t,"h",(function(){return m})),n.d(t,"i",(function(){return y})),n.d(t,"j",(function(){return x})),n.d(t,"k",(function(){return v})),n.d(t,"l",(function(){return O})),n.d(t,"n",(function(){return k})),n.d(t,"m",(function(){return w})),n.d(t,"o",(function(){return I})),n.d(t,"r",(function(){return S})),n.d(t,"p",(function(){return N})),n.d(t,"q",(function(){return T})),n.d(t,"s",(function(){return j})),n.d(t,"t",(function(){return C})),n.d(t,"u",(function(){return $})),n.d(t,"w",(function(){return E})),n.d(t,"v",(function(){return A})),n.d(t,"x",(function(){return R})),n.d(t,"y",(function(){return _})),n.d(t,"z",(function(){return F})),n.d(t,"A",(function(){return D})),n.d(t,"B",(function(){return M})),n.d(t,"C",(function(){return P})),n.d(t,"D",(function(){return L})),n.d(t,"E",(function(){return B})),n.d(t,"F",(function(){return z})),n.d(t,"G",(function(){return V})),n.d(t,"H",(function(){return W})),n.d(t,"I",(function(){return U})),n.d(t,"J",(function(){return G})),n.d(t,"K",(function(){return H})),n.d(t,"M",(function(){return K})),n.d(t,"N",(function(){return X})),n.d(t,"L",(function(){return Y})),n.d(t,"O",(function(){return Z})),n.d(t,"P",(function(){return Q})),n.d(t,"Q",(function(){return J})),n.d(t,"R",(function(){return ee})),n.d(t,"S",(function(){return te})),n.d(t,"T",(function(){return ne})),n.d(t,"U",(function(){return re})),n.d(t,"W",(function(){return ae})),n.d(t,"V",(function(){return se})),n.d(t,"qc",(function(){return oe})),n.d(t,"X",(function(){return ie})),n.d(t,"Y",(function(){return ue})),n.d(t,"Z",(function(){return ce})),n.d(t,"bb",(function(){return le})),n.d(t,"ab",(function(){return de})),n.d(t,"cb",(function(){return pe})),n.d(t,"db",(function(){return he})),n.d(t,"eb",(function(){return fe})),n.d(t,"fb",(function(){return me})),n.d(t,"gb",(function(){return be})),n.d(t,"hb",(function(){return ge})),n.d(t,"ib",(function(){return ye})),n.d(t,"jb",(function(){return xe})),n.d(t,"lb",(function(){return ve})),n.d(t,"pb",(function(){return Oe})),n.d(t,"ob",(function(){return ke})),n.d(t,"qb",(function(){return we})),n.d(t,"rb",(function(){return Ie})),n.d(t,"tb",(function(){return Se})),n.d(t,"sb",(function(){return Ne})),n.d(t,"ub",(function(){return Te})),n.d(t,"vb",(function(){return je})),n.d(t,"wb",(function(){return Ce})),n.d(t,"xb",(function(){return $e})),n.d(t,"Ab",(function(){return Ee})),n.d(t,"Bb",(function(){return Ae})),n.d(t,"Cb",(function(){return Re})),n.d(t,"Db",(function(){return _e})),n.d(t,"Eb",(function(){return Fe})),n.d(t,"Fb",(function(){return De})),n.d(t,"Hb",(function(){return Me})),n.d(t,"Ib",(function(){return Pe})),n.d(t,"Jb",(function(){return Le})),n.d(t,"Kb",(function(){return Be})),n.d(t,"Gb",(function(){return ze})),n.d(t,"Lb",(function(){return Ve})),n.d(t,"yb",(function(){return We})),n.d(t,"zb",(function(){return Ue})),n.d(t,"Mb",(function(){return Ge})),n.d(t,"Sb",(function(){return He})),n.d(t,"Nb",(function(){return qe})),n.d(t,"Qb",(function(){return Ke})),n.d(t,"Ob",(function(){return Xe})),n.d(t,"Pb",(function(){return Ye})),n.d(t,"Rb",(function(){return Ze})),n.d(t,"Tb",(function(){return Qe})),n.d(t,"Ub",(function(){return Je})),n.d(t,"Vb",(function(){return et})),n.d(t,"Wb",(function(){return tt})),n.d(t,"Xb",(function(){return nt})),n.d(t,"Yb",(function(){return at})),n.d(t,"Zb",(function(){return st})),n.d(t,"ac",(function(){return ot})),n.d(t,"ec",(function(){return it})),n.d(t,"bc",(function(){return ut})),n.d(t,"cc",(function(){return ct})),n.d(t,"dc",(function(){return lt})),n.d(t,"gc",(function(){return pt})),n.d(t,"fc",(function(){return ht})),n.d(t,"hc",(function(){return ft})),n.d(t,"ic",(function(){return mt})),n.d(t,"jc",(function(){return bt})),n.d(t,"kc",(function(){return gt})),n.d(t,"lc",(function(){return yt})),n.d(t,"mc",(function(){return xt})),n.d(t,"nc",(function(){return vt})),n.d(t,"oc",(function(){return Ot})),n.d(t,"pc",(function(){return kt})),n.d(t,"rc",(function(){return wt})),n.d(t,"sc",(function(){return It})),n.d(t,"uc",(function(){return St})),n.d(t,"xc",(function(){return Nt})),n.d(t,"yc",(function(){return Tt})),n.d(t,"vc",(function(){return jt})),n.d(t,"wc",(function(){return Ct})),n.d(t,"tc",(function(){return $t})),n.d(t,"zc",(function(){return Et})),n.d(t,"Bc",(function(){return At})),n.d(t,"Cc",(function(){return Rt})),n.d(t,"Dc",(function(){return _t})),n.d(t,"Ec",(function(){return Ft})),n.d(t,"Fc",(function(){return Dt})),n.d(t,"Gc",(function(){return Mt})),n.d(t,"Lc",(function(){return Pt})),n.d(t,"Jc",(function(){return Lt})),n.d(t,"Kc",(function(){return Bt})),n.d(t,"Ic",(function(){return zt})),n.d(t,"Hc",(function(){return Vt})),n.d(t,"Nc",(function(){return Wt})),n.d(t,"Vc",(function(){return Ut})),n.d(t,"ed",(function(){return Gt})),n.d(t,"Oc",(function(){return Ht})),n.d(t,"Uc",(function(){return qt})),n.d(t,"Mc",(function(){return Kt})),n.d(t,"Pc",(function(){return Xt})),n.d(t,"Qc",(function(){return Yt})),n.d(t,"Rc",(function(){return Zt})),n.d(t,"Sc",(function(){return Qt})),n.d(t,"Tc",(function(){return Jt})),n.d(t,"Xc",(function(){return en})),n.d(t,"Wc",(function(){return tn})),n.d(t,"Zc",(function(){return nn})),n.d(t,"ad",(function(){return rn})),n.d(t,"bd",(function(){return an})),n.d(t,"cd",(function(){return sn})),n.d(t,"dd",(function(){return on})),n.d(t,"fd",(function(){return un})),n.d(t,"gd",(function(){return cn})),n.d(t,"hd",(function(){return ln})),n.d(t,"id",(function(){return dn})),n.d(t,"jd",(function(){return pn})),n.d(t,"kd",(function(){return hn})),n.d(t,"ld",(function(){return fn})),n.d(t,"md",(function(){return mn})),n.d(t,"nd",(function(){return bn})),n.d(t,"od",(function(){return gn})),n.d(t,"pd",(function(){return yn})),n.d(t,"Yc",(function(){return xn})),n.d(t,"kb",(function(){return vn})),n.d(t,"Ac",(function(){return On})),n.d(t,"qd",(function(){return kn})),n.d(t,"mb",(function(){return wn})),n.d(t,"nb",(function(){return In}));const r="Abs",o="Acos",c="Acosh",l="Add",d="AddN",h="All",f="Any",m="ArgMax",y="ArgMin",x="Asin",v="Asinh",O="Atan",k="Atanh",w="Atan2",I="AvgPool",S="AvgPoolGrad",N="AvgPool3D",T="AvgPool3DGrad",j="BatchMatMul",C="BatchToSpaceND",$="Bincount",E="BroadcastTo",A="BroadcastArgs",R="Cast",_="Ceil",F="ClipByValue",D="Complex",M="ComplexAbs",P="Concat",L="Conv2D",B="Conv2DBackpropFilter",z="Conv2DBackpropInput",V="Conv3D",W="Conv3DBackpropFilterV2",U="Conv3DBackpropInputV2",G="Cos",H="Cosh",K="Cumprod",X="Cumsum",Y="CropAndResize",Z="DenseBincount",Q="DepthToSpace",J="DepthwiseConv2dNative",ee="DepthwiseConv2dNativeBackpropFilter",te="DepthwiseConv2dNativeBackpropInput",ne="Diag",re="Dilation2D",ae="Dilation2DBackpropInput",se="Dilation2DBackpropFilter",oe="RealDiv",ie="Einsum",ue="Elu",ce="EluGrad",le="Erf",de="Equal",pe="Exp",he="ExpandDims",fe="Expm1",me="FFT",be="Fill",ge="FlipLeftRight",ye="Floor",xe="FloorDiv",ve="FusedBatchNorm",Oe="GatherV2",ke="GatherNd",we="Greater",Ie="GreaterEqual",Se="Identity",Ne="IFFT",Te="Imag",je="IsFinite",Ce="IsInf",$e="IsNan",Ee="LeakyRelu",Ae="Less",Re="LessEqual",_e="LinSpace",Fe="Log",De="Log1p",Me="LogicalAnd",Pe="LogicalNot",Le="LogicalOr",Be="LogicalXor",ze="LogSoftmax",Ve="LowerBound",We="LRN",Ue="LRNGrad",Ge="Max",He="Maximum",qe="MaxPool",Ke="MaxPoolGrad",Xe="MaxPool3D",Ye="MaxPool3DGrad",Ze="MaxPoolWithArgmax",Qe="Mean",Je="Min",et="Minimum",tt="MirrorPad",nt="Mod",at="Multinomial",st="Multiply",ot="Neg",it="NotEqual",ut="NonMaxSuppressionV3",ct="NonMaxSuppressionV4",lt="NonMaxSuppressionV5",pt="OnesLike",ht="OneHot",ft="Pack",mt="PadV2",bt="Pool",gt="Pow",yt="Prelu",xt="Prod",vt="RaggedTensorToTensor",Ot="Range",kt="Real",wt="Reciprocal",It="Relu",St="Reshape",Nt="ResizeNearestNeighbor",Tt="ResizeNearestNeighborGrad",jt="ResizeBilinear",Ct="ResizeBilinearGrad",$t="Relu6",Et="Reverse",At="Round",Rt="Rsqrt",_t="ScatterNd",Ft="SearchSorted",Dt="Select",Mt="Selu",Pt="Slice",Lt="Sin",Bt="Sinh",zt="Sign",Vt="Sigmoid",Wt="Softplus",Ut="Sqrt",Gt="Sum",Ht="SpaceToBatchND",qt="SplitV",Kt="Softmax",Xt="SparseFillEmptyRows",Yt="SparseReshape",Zt="SparseSegmentMean",Qt="SparseSegmentSum",Jt="SparseToDense",en="SquaredDifference",tn="Square",nn="StridedSlice",rn="StringNGrams",an="StringSplit",sn="StringToHashBucketFast",on="Sub",un="Tan",cn="Tanh",ln="Tile",dn="TopK",pn="Transform",hn="Transpose",fn="Unique",mn="Unpack",bn="UnsortedSegmentSum",gn="UpperBound",yn="ZerosLike",xn="Step",vn="FromPixels",On="RotateWithOffset",kn="_FusedMatMul",wn="FusedConv2D",In="FusedDepthwiseConv2D"},function(e,t,n){"use strict";n.r(t),n.d(t,"shuffle",(function(){return o.M})),n.d(t,"shuffleCombo",(function(){return o.N})),n.d(t,"clamp",(function(){return o.i})),n.d(t,"nearestLargerEven",(function(){return o.H})),n.d(t,"swap",(function(){return o.S})),n.d(t,"sum",(function(){return o.R})),n.d(t,"randUniform",(function(){return o.J})),n.d(t,"distSquared",(function(){return o.l})),n.d(t,"assert",(function(){return o.b})),n.d(t,"assertShapesMatch",(function(){return o.e})),n.d(t,"assertNonNull",(function(){return o.d})),n.d(t,"flatten",(function(){return o.m})),n.d(t,"sizeFromShape",(function(){return o.O})),n.d(t,"isScalarShape",(function(){return o.y})),n.d(t,"arraysEqual",(function(){return o.a})),n.d(t,"isInt",(function(){return o.v})),n.d(t,"tanh",(function(){return o.T})),n.d(t,"sizeToSquarishShape",(function(){return o.P})),n.d(t,"createShuffledIndices",(function(){return o.k})),n.d(t,"rightPad",(function(){return o.L})),n.d(t,"repeatedTry",(function(){return o.K})),n.d(t,"inferFromImplicitShape",(function(){return o.s})),n.d(t,"parseAxisParam",(function(){return o.I})),n.d(t,"squeezeShape",(function(){return o.Q})),n.d(t,"getTypedArrayFromDType",(function(){return o.o})),n.d(t,"getArrayFromDType",(function(){return o.n})),n.d(t,"checkConversionForErrors",(function(){return o.h})),n.d(t,"isValidDtype",(function(){return o.B})),n.d(t,"hasEncodingLoss",(function(){return o.p})),n.d(t,"isTypedArray",(function(){return o.A})),n.d(t,"bytesPerElement",(function(){return o.g})),n.d(t,"bytesFromStringArray",(function(){return o.f})),n.d(t,"isString",(function(){return o.z})),n.d(t,"isBoolean",(function(){return o.t})),n.d(t,"isNumber",(function(){return o.w})),n.d(t,"inferDtype",(function(){return o.r})),n.d(t,"isFunction",(function(){return o.u})),n.d(t,"nearestDivisor",(function(){return o.G})),n.d(t,"computeStrides",(function(){return o.j})),n.d(t,"toNestedArray",(function(){return o.U})),n.d(t,"makeOnesTypedArray",(function(){return o.D})),n.d(t,"makeZerosTypedArray",(function(){return o.F})),n.d(t,"makeZerosNestedTypedArray",(function(){return o.E})),n.d(t,"assertNonNegativeIntegerDimensions",(function(){return o.c})),n.d(t,"locToIndex",(function(){return o.C})),n.d(t,"indexToLoc",(function(){return o.q})),n.d(t,"isPromise",(function(){return o.x})),n.d(t,"hexToLong",(function(){return d})),n.d(t,"fingerPrint64",(function(){return S})),n.d(t,"createScalarValue",(function(){return N})),n.d(t,"toTypedArray",(function(){return T})),n.d(t,"now",(function(){return j})),n.d(t,"fetch",(function(){return C})),n.d(t,"encodeString",(function(){return $})),n.d(t,"decodeString",(function(){return E}));var r=n(294),o=n(320),c=n(413);const l=n.n(c).a||c;function d(e){return l.fromString(e,!0,16)}const h=d("c3a5c85c97cb3127"),f=d("b492b66fbe98f273"),m=d("9ae16a3b2f90404f");function y(e){return e.xor(e.shru(47))}function x(s,e,t){const n=s.slice(e,e+t);return l.fromBytes(Array.from(n),!0,!0)}function v(s,e){return x(s,e,8)}function O(s,e){return x(s,e,4)}function k(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function w(u,e,t=d("9ddfea08eb382d69")){let a=u.xor(e).mul(t);a=a.xor(a.shru(47));let b=e.xor(a).mul(t);return b=b.xor(b.shru(47)),b=b.mul(t),b}function I(s,e,a,b){return function(e,t,n,r,a,b){a=a.add(e),b=k(b.add(a).add(r),21);const o=a;return a=(a=a.add(t)).add(n),b=b.add(k(a,44)),[a.add(r),b.add(o)]}(v(s,e),v(s,e+8),v(s,e+16),v(s,e+24),a,b)}function S(s,e=s.length){const t=l.fromNumber(81,!0);if(e<=32)return e<=16?function(s,e=s.length){if(e>=8){const t=m.add(2*e),a=v(s,0).add(m),b=v(s,e-8);return w(k(b,37).mul(t).add(a),k(a,25).add(b).mul(t),t)}if(e>=4){const t=m.add(2*e);return w(O(s,0).shl(3).add(e),O(s,e-4),t)}if(e>0){const t=s[0]+(s[e>>1]<<8),n=e+(s[e-1]<<2);return y(m.mul(t).xor(h.mul(n))).mul(m)}return m}(s,e):function(s,e=s.length){const t=m.add(2*e),a=v(s,0).mul(f),b=v(s,8),n=v(s,e-8).mul(t),r=v(s,e-16).mul(m);return w(k(a.add(b),43).add(k(n,30)).add(r),a.add(k(b.add(m),18)).add(n),t)}(s,e);if(e<=64)return function(s,e=s.length){const t=m.add(2*e),a=v(s,0).mul(m),b=v(s,8),n=v(s,e-8).mul(t),r=v(s,e-16).mul(m),o=k(a.add(b),43).add(k(n,30)).add(r),c=w(o,a.add(k(b.add(m),18)).add(n),t),l=v(s,16).mul(t),d=v(s,24),g=o.add(v(s,e-32)).mul(t),h=c.add(v(s,e-24)).mul(t);return w(k(l.add(d),43).add(k(g,30)).add(h),l.add(k(d.add(a),18)).add(g),t)}(s,e);let n=t,r=t.mul(f).add(113),o=y(r.mul(m).add(113)).mul(m),c=[l.UZERO,l.UZERO],d=[l.UZERO,l.UZERO];n=n.mul(m).add(v(s,0));let x=0;const S=64*(e-1>>6),N=S+(e-1&63)-63;do{n=k(n.add(r).add(c[0]).add(v(s,x+8)),37).mul(f),r=k(r.add(c[1]).add(v(s,x+48)),42).mul(f),n=n.xor(d[1]),r=r.add(c[0]).add(v(s,x+40)),o=k(o.add(d[0]),33).mul(f),c=I(s,x,c[1].mul(f),n.add(d[0])),d=I(s,x+32,o.add(d[1]),r.add(v(s,x+16))),[o,n]=[n,o],x+=64}while(x!==S);const T=f.add(o.and(255).shl(1));return x=N,d[0]=d[0].add(e-1&63),c[0]=c[0].add(d[0]),d[0]=d[0].add(c[0]),n=k(n.add(r).add(c[0]).add(v(s,x+8)),37).mul(T),r=k(r.add(c[1]).add(v(s,x+48)),42).mul(T),n=n.xor(d[1].mul(9)),r=r.add(c[0].mul(9).add(v(s,x+40))),o=k(o.add(d[0]),33).mul(T),c=I(s,x,c[1].mul(T),n.add(d[0])),d=I(s,x+32,o.add(d[1]),r.add(v(s,x+16))),[o,n]=[n,o],w(w(c[0],d[0],T).add(y(r).mul(h)).add(o),w(c[1],d[1],T).add(n),T)}function N(e,t){return"string"===t?$(e):T([e],t)}function T(a,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=o.m(a)),Object(r.c)().getBool("DEBUG")&&o.h(a,e),function(a,e){return a instanceof Float32Array&&"float32"===e||a instanceof Int32Array&&"int32"===e||a instanceof Uint8Array&&"bool"===e}(a,e))return a;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(a);if("int32"===e)return new Int32Array(a);if("bool"===e){const e=new Uint8Array(a.length);for(let i=0;i<e.length;++i)0!==Math.round(a[i])&&(e[i]=1);return e}throw new Error(`Unknown data type ${e}`)}function j(){return Object(r.c)().platform.now()}function C(path,e){return Object(r.c)().platform.fetch(path,e)}function $(s,e="utf-8"){return e=e||"utf-8",Object(r.c)().platform.encode(s,e)}function E(e,t="utf-8"){return t=t||"utf-8",Object(r.c)().platform.decode(e,t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&r.util.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({reshape_:function(e,t){const n={x:Object(c.a)(e,"x","reshape","string_or_numeric")},l={shape:t};return r.a.runKernel(o.uc,n,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return l}));var r=n(279),o=n(285);function c(e,t,n){return({inputs:c,attrs:l,backend:d})=>{const{x:h}=c;if(Object(o.a)(h,e),"string"===h.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const f=d,m=f.data.get(h.dataId).values,y=r.util.sizeFromShape(h.shape),x=n||h.dtype,v=r.util.getArrayFromDType(x,y);for(let i=0;i<y;++i)v[i]=t(m[i],l);return f.makeTensorInfo(h.shape,x,v)}}function l(e,t,n){return({inputs:r,attrs:c,backend:l})=>{const{x:d}=r;if(Object(o.a)(d,e),"string"===d.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const h=l,f=h.data.get(d.dataId).values,m=n||d.dtype,y=t(f,m,c);return h.makeTensorInfo(d.shape,m,y)}}},function(e,t,n){"use strict";n.r(t),n.d(t,"makeTypesMatch",(function(){return l})),n.d(t,"assertTypesMatch",(function(){return d})),n.d(t,"isTensorInList",(function(){return h})),n.d(t,"getTensorsInContainer",(function(){return f}));var r=n(301),o=n(321),c=n(320);function l(a,b){if(a.dtype===b.dtype)return[a,b];const e=Object(o.c)(a.dtype,b.dtype);return[a.cast(e),b.cast(e)]}function d(a,b){Object(c.b)(a.dtype===b.dtype,(()=>`The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`))}function h(e,t){return t.some((t=>t.id===e.id))}function f(e){const t=[];return m(e,t,new Set),t}function m(e,t,n){if(null==e)return;if(e instanceof r.a)return void t.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;const c=e;for(const e in c){const r=c[e];n.has(r)||(n.add(r),m(r,t,n))}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const h=Object(d.b)({mul_:function(a,b){let e=Object(l.a)(a,"a","mul"),t=Object(l.a)(b,"b","mul");[e,t]=Object(c.makeTypesMatch)(e,t);const n={a:e,b:t};return r.a.runKernel(o.Zb,n)}})},function(e,t,n){"use strict";n.d(t,"d",(function(){return o})),n.d(t,"e",(function(){return c})),n.d(t,"f",(function(){return l})),n.d(t,"b",(function(){return d})),n.d(t,"g",(function(){return f})),n.d(t,"c",(function(){return m})),n.d(t,"a",(function(){return y}));var r=n(279);function o(e,t,n,o,l){const d=t.inputParams[e];if(d&&void 0!==d.inputIndexStart){const e=d.inputIndexStart,h=0===d.inputIndexEnd?void 0:void 0===d.inputIndexEnd?e+1:d.inputIndexEnd;if("tensor"===d.type)return c(t.inputNames[d.inputIndexStart],n,o,l);if("tensors"===d.type){return t.inputNames.slice(e,h).map((e=>c(e,n,o,l)))}const f=c(t.inputNames.slice(e)[0],n,o,l),data=f.dataSync();return"number"===d.type?data[0]:r.util.toNestedArray(f.shape,data)}const h=t.attrParams[e];return h&&h.value}function c(e,t,n,r){const[o,c]=f(e);if(null!=r){const e=r.getHashTableHandleByName(o);if(null!=e)return e}const l=n.currentContextIds.find((e=>!!t[h(o,e)]));return void 0!==l?t[h(o,l)][c]:void 0}function l(e,t,n){return t[h(e,n.currentContextId)]}function d(e,t){const[n,r,o]=f(e);return[h(n,t&&t.currentContextId),r,o]}function h(e,t){return t?`${e}-${t}`:e}function f(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],r=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),r]}function m(e,t,n){let r=o("pad",e,t,n);if("explicit"===r){r=o("explicitPaddings",e,t,n);const c=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)c[i][0]=r[2*i],c[i][1]=r[2*i+1];return c}return r}function y(e){return e.kept?e:Object(r.clone)(e)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const h=Object(d.b)({add_:function(a,b){let e=Object(l.a)(a,"a","add"),t=Object(l.a)(b,"b","add");[e,t]=Object(c.makeTypesMatch)(e,t);const n={a:e,b:t};return r.a.runKernel(o.d,n)}})},function(e,t,n){"use strict";function r(e,t){const n=e.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=e[o]||1;(t[t.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}function o(e,t){const n=[];for(let i=0;i<t.length;i++){const r=e[e.length-i-1],o=t.length-i-1,c=t[o];(null==r||1===r&&c>1)&&n.unshift(o)}return n}function c(e,t){const n=[],r=Math.max(e.length,t.length);for(let i=0;i<r;i++){let a=e[e.length-i-1];null==a&&(a=1);let b=t[t.length-i-1];if(null==b&&(b=1),1===a)n.unshift(b);else if(1===b)n.unshift(a);else{if(a!==b){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(a)}}return n}n.r(t),n.d(t,"getBroadcastDims",(function(){return r})),n.d(t,"getReductionAxes",(function(){return o})),n.d(t,"assertAndGetBroadcastShape",(function(){return c}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e){return(t,n,o,c,l)=>{const d=r.backend_util.assertAndGetBroadcastShape(t,n),h=d.length,f=r.util.computeStrides(d),m=r.util.sizeFromShape(d),y=r.util.getTypedArrayFromDType(l,m),x=t.length,v=n.length,O=r.util.computeStrides(t),k=r.util.computeStrides(n),w=r.backend_util.getBroadcastDims(t,d),I=r.backend_util.getBroadcastDims(n,d);if(w.length+I.length===0)for(let i=0;i<y.length;++i)y[i]=e(o[i%o.length],c[i%c.length]);else for(let i=0;i<y.length;++i){const t=r.util.indexToLoc(i,h,f),n=t.slice(-x);w.forEach((e=>n[e]=0));const l=r.util.locToIndex(n,x,O),d=t.slice(-v);I.forEach((e=>d[e]=0));const m=r.util.locToIndex(d,v,k);y[i]=e(o[l],c[m])}return[y,d]}}},function(e,t,n){"use strict";n.d(t,"b",(function(){return c})),n.d(t,"c",(function(){return d})),n.d(t,"a",(function(){return h})),n.d(t,"d",(function(){return f}));var r=n(320);const o="tfjsflags";class c{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=l,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(d().getBool("IS_TEST")||d().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];d().getBool("IS_TEST")||d().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Object(r.x)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(o in e){e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}}function l(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((s,...e)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,e[0],e[1]),e.join("=")))),t}function d(){return h}let h=null;function f(e){h=e}},function(e,t,n){"use strict";n.d(t,"a",(function(){return sub}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const sub=Object(d.b)({sub_:function(a,b){let e=Object(l.a)(a,"a","sub"),t=Object(l.a)(b,"b","sub");[e,t]=Object(c.makeTypesMatch)(e,t);const n={a:e,b:t};return r.a.runKernel(o.dd,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(279),o=n(285),c=n(325),l=n(317);function d(e,t,n,d){return null==n?({inputs:n,backend:c})=>{const{a:a,b:b}=n,l=c;Object(o.a)([a,b],e);const h=l.data.get(a.dataId).values,f=l.data.get(b.dataId).values,m="string"===a.dtype?r.backend_util.fromUint8ToStringArray(h):h,y="string"===a.dtype?r.backend_util.fromUint8ToStringArray(f):f,x=d||a.dtype,[v,O]=t(a.shape,b.shape,m,y,x);return l.makeTensorInfo(O,x,v)}:({inputs:e,backend:r})=>{const{a:a,b:b}=e,o=r;if("complex64"===a.dtype||"complex64"===b.dtype){const e=Object(c.a)({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,d=t.complexTensorInfos.imag,h=o.data.get(r.dataId).values,f=o.data.get(d.dataId).values,m=Object(c.a)({inputs:{x:b},backend:o,attrs:{dtype:"complex64"}}),y=o.data.get(m.dataId),x=y.complexTensorInfos.real,v=y.complexTensorInfos.imag,O=o.data.get(x.dataId).values,k=o.data.get(v.dataId).values,[w,I,S]=n(a.shape,b.shape,h,f,O,k),N=o.makeTensorInfo(S,"float32",w),T=o.makeTensorInfo(S,"float32",I),j=Object(l.a)({inputs:{real:N,imag:T},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(N),o.disposeIntermediateTensorInfo(T),j}{const e=o.data.get(a.dataId).values,n=o.data.get(b.dataId).values,r=d||a.dtype,[c,l]=t(a.shape,b.shape,e,n,r);return o.makeTensorInfo(l,r,c)}}}function h(e){return(t,n,o,c,l,d)=>{const h=r.backend_util.assertAndGetBroadcastShape(t,n),f=r.util.sizeFromShape(h),m=h.length,y=r.util.computeStrides(h),x=r.util.getTypedArrayFromDType("float32",f),v=r.util.getTypedArrayFromDType("float32",f),O=r.backend_util.getBroadcastDims(t,h),k=r.backend_util.getBroadcastDims(n,h),w=r.backend_util.mergeRealAndImagArrays(o,c),I=r.backend_util.mergeRealAndImagArrays(l,d),S=t.length,N=r.util.computeStrides(t),T=n.length,j=r.util.computeStrides(n);if(O.length+k.length===0)for(let i=0;i<x.length;i++){const t=i%w.length,n=i%I.length,r=e(w[2*t],w[2*t+1],I[2*n],I[2*n+1]);x[i]=r.real,v[i]=r.imag}else for(let i=0;i<x.length;i++){const t=r.util.indexToLoc(i,m,y),n=t.slice(-S);O.forEach((e=>n[e]=0));const o=r.util.locToIndex(n,S,N),c=t.slice(-T);k.forEach((e=>c[e]=0));const l=r.util.locToIndex(c,T,j),d=e(w[2*o],w[2*o+1],I[2*l],I[2*l+1]);x[i]=d.real,v[i]=d.imag}return[x,v,h]}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(320),o=n(314);function c(e,t){if((Object(r.A)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(r.A)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(o.a)(e,[],[],t)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(281),l=n(320),d=n(280);const h=Object(d.b)({cast_:function(e,t){const n=Object(c.a)(e,"x","cast");if(!l.B(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const d={x:n},h={dtype:t};return r.a.runKernel(o.x,d,h)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return div}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(360),h=n(280);const div=Object(h.b)({div_:function(a,b){let e=Object(l.a)(a,"a","div"),t=Object(l.a)(b,"b","div");if([e,t]=Object(c.makeTypesMatch)(e,t),"int32"===e.dtype&&"int32"===t.dtype)return Object(d.a)(e,t);const n={a:e,b:t};return r.a.runKernel(o.qc,n,{})}})},function(e,t,n){"use strict";n.d(t,"e",(function(){return o})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"b",(function(){return d})),n.d(t,"c",(function(){return h})),n.d(t,"d",(function(){return f})),n.d(t,"j",(function(){return O})),n.d(t,"i",(function(){return k})),n.d(t,"h",(function(){return w})),n.d(t,"a",(function(){return I}));var r=n(320);function o(e,t,n,r,o="NHWC",c){return d(e,[...t,e[3]],n,c,r,null,null,w(o))}function c(e,t,n,r,o,c,l="channelsLast"){const[h,f]=m(t);let y;if("channelsLast"===l)y=[h,f,e[3],e[3]];else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);y=[h,f,e[1],e[1]]}return d(e,y,n,r,o,c,!1,l)}function l(e,t,n,r,o,c,l="NDHWC"){const[d,f,m]=y(t);let x,v;if("NDHWC"===l)v="channelsLast",x=[d,f,m,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);v="channelsFirst",x=[d,f,m,e[1],e[1]]}return h(e,x,n,r,o,!1,v,c)}function d(e,t,n,r,o,c,l=!1,d="channelsLast"){let[h,y,O,k]=[-1,-1,-1,-1];if("channelsLast"===d)[h,y,O,k]=e;else{if("channelsFirst"!==d)throw new Error(`Unknown dataFormat ${d}`);[h,k,y,O]=e}const[w,I,,S]=t,[N,T]=m(n),[j,C]=m(r),$=x(w,j),E=x(I,C),{padInfo:A,outHeight:R,outWidth:_}=function(e,t,n,r,o,c,l,d,h){let m,y,x;if("number"==typeof e){m={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,r,o){null==r&&(r=f(e,t,n));const c=e[0],l=e[1],d=v((c-t+2*r)/n+1,o),h=v((l-t+2*r)/n+1,o);return[d,h]}([t,n],c,r,e,d);y=o[0],x=o[1]}else if("same"===e){y=Math.ceil(t/r),x=Math.ceil(n/o);const e=Math.max(0,(y-1)*r+c-t),d=Math.max(0,(x-1)*o+l-n),h=Math.floor(e/2),f=e-h,v=Math.floor(d/2);m={top:h,bottom:f,left:v,right:d-v,type:"SAME"}}else if("valid"===e)m={top:0,bottom:0,left:0,right:0,type:"VALID"},y=Math.ceil((t-c+1)/r),x=Math.ceil((n-l+1)/o);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const f="channelsLast"===h?e[1][0]:e[2][0],O="channelsLast"===h?e[1][1]:e[2][1],k="channelsLast"===h?e[2][0]:e[3][0],w="channelsLast"===h?e[2][1]:e[3][1];m={top:f,bottom:O,left:k,right:w,type:0===f&&0===O&&0===k&&0===w?"VALID":"EXPLICIT"},y=v((t-c+f+O)/r+1,d),x=v((n-l+k+w)/o+1,d)}}return{padInfo:m,outHeight:y,outWidth:x}}(o,y,O,N,T,$,E,c,d),F=l?S*k:S;let D;return"channelsFirst"===d?D=[h,F,R,_]:"channelsLast"===d&&(D=[h,R,_,F]),{batchSize:h,dataFormat:d,inHeight:y,inWidth:O,inChannels:k,outHeight:R,outWidth:_,outChannels:F,padInfo:A,strideHeight:N,strideWidth:T,filterHeight:w,filterWidth:I,effectiveFilterHeight:$,effectiveFilterWidth:E,dilationHeight:j,dilationWidth:C,inShape:e,outShape:D,filterShape:t}}function h(e,t,n,r,o,c=!1,l="channelsLast",d){let[h,m,O,k,w]=[-1,-1,-1,-1,-1];if("channelsLast"===l)[h,m,O,k,w]=e;else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);[h,w,m,O,k]=e}const[I,S,N,,T]=t,[j,C,$]=y(n),[E,A,R]=y(r),_=x(I,E),F=x(S,A),D=x(N,R),{padInfo:M,outDepth:P,outHeight:L,outWidth:B}=function(e,t,n,r,o,c,l,d,h,m,y){let x,O,k,w;if("number"==typeof e){x={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const c=function(e,t,n,r,o,c){null==o&&(o=f(e,t,r));const l=e[0],d=e[1],h=e[2],m=v((l-t+2*o)/r+1,c),y=v((d-t+2*o)/r+1,c),x=v((h-t+2*o)/r+1,c);return[m,y,x,n]}([t,n,r,1],d,1,o,e,y);O=c[0],k=c[1],w=c[2]}else if("same"===e){O=Math.ceil(t/o),k=Math.ceil(n/c),w=Math.ceil(r/l);const e=(O-1)*o+d-t,f=(k-1)*c+h-n,y=(w-1)*l+m-r,v=Math.floor(e/2),I=e-v,S=Math.floor(f/2),N=f-S,T=Math.floor(y/2);x={top:S,bottom:N,left:T,right:y-T,front:v,back:I,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);x={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},O=Math.ceil((t-d+1)/o),k=Math.ceil((n-h+1)/c),w=Math.ceil((r-m+1)/l)}return{padInfo:x,outDepth:O,outHeight:k,outWidth:w}}(o,m,O,k,j,C,$,_,F,D,d),z=c?T*w:T;let V;return"channelsFirst"===l?V=[h,z,P,L,B]:"channelsLast"===l&&(V=[h,P,L,B,z]),{batchSize:h,dataFormat:l,inDepth:m,inHeight:O,inWidth:k,inChannels:w,outDepth:P,outHeight:L,outWidth:B,outChannels:z,padInfo:M,strideDepth:j,strideHeight:C,strideWidth:$,filterDepth:I,filterHeight:S,filterWidth:N,effectiveFilterDepth:_,effectiveFilterHeight:F,effectiveFilterWidth:D,dilationDepth:E,dilationHeight:A,dilationWidth:R,inShape:e,outShape:V,filterShape:t}}function f(e,t,n,r=1){const o=x(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)}function m(param){return"number"==typeof param?[param,param,param]:2===param.length?[param[0],param[1],1]:param}function y(param){return"number"==typeof param?[param,param,param]:param}function x(e,t){return t<=1?e:e+(e-1)*(t-1)}function v(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function O(param){const[e,t,n]=m(param);return 1===e&&1===t&&1===n}function k(e,t){return O(e)||O(t)}function w(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function I(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)r.b(r.v(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((p=>{p.forEach((t=>{r.b(r.v(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}},function(e,t,n){"use strict";n.d(t,"b",(function(){return y})),n.d(t,"f",(function(){return k})),n.d(t,"e",(function(){return w})),n.d(t,"d",(function(){return I})),n.d(t,"a",(function(){return S})),n.d(t,"c",(function(){return N}));var r=n(357),o=n(320);function c(e,t,n,r){const c=Object(o.j)(t),d=function(e,t,n,r){const c=Object(o.O)(t),d=r[r.length-1],h=new Array(d).fill(0),m=t.length,y="complex64"===n?f(e):e;if(m>1)for(let e=0;e<c/d;e++){const t=e*d;for(let e=0;e<d;e++)h[e]=Math.max(h[e],l(y[t+e],0,n).length)}return h}(e,t,n,c),m=t.length,y=h(e,t,n,c,d),x=["Tensor"];return r&&(x.push(`  dtype: ${n}`),x.push(`  rank: ${m}`),x.push(`  shape: [${t}]`),x.push("  values:")),x.push(y.map((e=>"    "+e)).join("\n")),x.join("\n")}function l(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Object(o.z)(e)?`'${e}'`:"bool"===n?d(e):parseFloat(e.toFixed(7)).toString(),Object(o.L)(r,t)}function d(e){return 0===e?"false":"true"}function h(e,t,n,r,o,c=!0){const m="complex64"===n?2:1,y=t[0],x=t.length;if(0===x){if("complex64"===n){return[l(f(e)[0],0,n)]}return"bool"===n?[d(e[0])]:[e[0].toString()]}if(1===x){if(y>20){const t=3*m;let r=Array.from(e.slice(0,t)),c=Array.from(e.slice((y-3)*m,y*m));return"complex64"===n&&(r=f(r),c=f(c)),["["+r.map(((e,i)=>l(e,o[i],n))).join(", ")+", ..., "+c.map(((e,i)=>l(e,o[y-3+i],n))).join(", ")+"]"]}return["["+("complex64"===n?f(e):Array.from(e)).map(((e,i)=>l(e,o[i],n))).join(", ")+"]"]}const v=t.slice(1),O=r.slice(1),k=r[0]*m,w=[];if(y>20){for(let i=0;i<3;i++){const t=i*k,r=t+k;w.push(...h(e.slice(t,r),v,n,O,o,!1))}w.push("...");for(let i=y-3;i<y;i++){const t=i*k,r=t+k;w.push(...h(e.slice(t,r),v,n,O,o,i===y-1))}}else for(let i=0;i<y;i++){const t=i*k,r=t+k;w.push(...h(e.slice(t,r),v,n,O,o,i===y-1))}const I=2===x?",":"";w[0]="["+w[0]+I;for(let i=1;i<w.length-1;i++)w[i]=" "+w[i]+I;let S=",\n";for(let i=2;i<x;i++)S+="\n";return w[w.length-1]=" "+w[w.length-1]+"]"+(c?"":S),w}function f(e){const t=[];for(let i=0;i<e.length;i+=2)t.push([e[i],e[i+1]]);return t}var m=n(284);class y{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=o.O(e),null!=n){const e=n.length;o.b(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||o.n(t,this.size),this.strides=Object(o.j)(e)}set(e,...t){0===t.length&&(t=[0]),o.b(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let i=0;for(const t of e){if(t<0||t>=this.shape[i]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}i++}let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return this.values[t]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let i=0;i<t.length-1;++i)t[i]=Math.floor(e/this.strides[i]),e-=t[i]*this.strides[i];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return x().makeTensor(this.values,this.shape,this.dtype)}}let x=null,v=null,O=null;function k(e){x=e}function w(e){v=e}function I(e){O=e}class S{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=o.O(e),this.strides=Object(o.j)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return v.buffer(this.shape,this.dtype,e)}bufferSync(){return v.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Object(o.U)(this.shape,e,"complex64"===this.dtype)}arraySync(){return Object(o.U)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const data=x().read(this.dataId);if("string"===this.dtype){const e=await data;try{return e.map((b=>m.decodeString(b)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return data}dataToGPU(e){return this.throwIfDisposed(),x().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const data=x().readSync(this.dataId);if("string"===this.dtype)try{return data.map((b=>m.decodeString(b)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return data}async bytes(){this.throwIfDisposed();const data=await x().read(this.dataId);return"string"===this.dtype?data:new Uint8Array(data.buffer)}dispose(){this.isDisposed||(x().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return v.print(this,e)}clone(){return this.throwIfDisposed(),v.clone(this)}toString(e=!1){return c(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),v.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),x().makeVariable(this,e,t,n)}}Object.defineProperty(S,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Object(r.a)("Tensor",(()=>S));class N extends S{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!o.a(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);x().disposeTensor(this),this.dataId=e.dataId,x().incRef(this,null)}dispose(){x().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(N,Symbol.hasInstance,{value:e=>e instanceof S&&null!=e.assign&&e.assign instanceof Function})},function(e,t,n){"use strict";n.d(t,"a",(function(){return x})),n.d(t,"f",(function(){return y})),n.d(t,"d",(function(){return f})),n.d(t,"e",(function(){return m})),n.d(t,"b",(function(){return d})),n.d(t,"c",(function(){return h}));var r=n(282),o=n(301),c=n(281),l=n(320);function d(e){return l.b(l.u(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const o=Object(c.a)(t,"x","tf.grad","string_or_numeric"),d=null!=n?Object(c.a)(n,"dy","tf.grad"):null;return r.a.tidy((()=>{const{value:t,grads:n}=r.a.gradients((()=>e(o)),[o],d);return null!=d&&l.e(t.shape,d.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),v(n),n[0]}))}}function h(e){return l.b(l.u(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{l.b(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const o=Object(c.b)(t,"args","tf.grads","string_or_numeric"),d=null!=n?Object(c.a)(n,"dy","tf.grads"):null;return r.a.tidy((()=>{const{value:t,grads:n}=r.a.gradients((()=>e(...o)),o,d);return null!=d&&l.e(t.shape,d.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),v(n),n}))}}function f(e){return l.b(l.u(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{l.b(t instanceof o.a,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),l.b(null==n||n instanceof o.a,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:c,value:d}=r.a.gradients((()=>e(t)),[t],n);return v(c),{grad:c[0],value:d}}}function m(e){return l.b(l.u(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{l.b(Array.isArray(t)&&t.every((e=>e instanceof o.a)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),l.b(null==n||n instanceof o.a,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const c=r.a.gradients((()=>e(...t)),t,n);return null!=n&&l.e(c.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),v(c.grads),c}}function y(e,t){l.b(l.u(e),(()=>"The f passed in variableGrads(f) must be a function")),l.b(null==t||Array.isArray(t)&&t.every((e=>e instanceof o.c)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in r.a.registeredVariables)t.push(r.a.registeredVariables[e])}const c=n?t.filter((e=>!e.trainable)):null,d=t.length;t=t.filter((e=>e.trainable)),l.b(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${d} variables is trainable.`));const{value:h,grads:f}=r.a.gradients(e,t,null,!0);l.b(f.some((g=>null!=g)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),l.b(0===h.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${h.rank} tensor`));const m={};return t.forEach(((e,i)=>{null!=f[i]&&(m[e.name]=f[i])})),null!=c&&c.forEach((e=>m[e.name]=null)),{value:h,grads:m}}function x(e){return r.a.customGrad(e)}function v(e){if(e.filter((g=>null==g)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return d}));var r=n(279),o=n(285),c=n(353);function l(e){const{inputs:t,attrs:n,backend:r}=e,{x:l}=t,{perm:d}=n;Object(o.a)(l,"transpose");const h=l.shape.length,f=new Array(h);for(let i=0;i<f.length;i++)f[i]=l.shape[d[i]];const m=r.data.get(l.dataId).values,y=Object(c.a)(m,l.shape,l.dtype,d,f);return{dataId:r.write(y,f,l.dtype),shape:f,dtype:l.dtype}}const d={kernelName:r.Transpose,backendName:"cpu",kernelFunc:l}},function(e,t,n){"use strict";n.d(t,"g",(function(){return d})),n.d(t,"f",(function(){return h})),n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return m})),n.d(t,"e",(function(){return y})),n.d(t,"h",(function(){return x})),n.d(t,"m",(function(){return v})),n.d(t,"n",(function(){return O})),n.d(t,"t",(function(){return k})),n.d(t,"d",(function(){return w})),n.d(t,"l",(function(){return I})),n.d(t,"u",(function(){return time})),n.d(t,"r",(function(){return S})),n.d(t,"o",(function(){return N})),n.d(t,"k",(function(){return T})),n.d(t,"q",(function(){return j})),n.d(t,"i",(function(){return C})),n.d(t,"j",(function(){return $})),n.d(t,"p",(function(){return E})),n.d(t,"a",(function(){return A})),n.d(t,"s",(function(){return R}));var r=n(282),o=n(294),c=n(301),l=n(288);function d(){Object(o.c)().set("PROD",!0)}function h(){Object(o.c)().set("DEBUG",!0)}function f(){Object(o.c)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function m(e){Object(o.c)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function y(){r.a.disposeVariables()}function x(){return r.a}function v(){return r.a.memory()}function O(e){return r.a.profile(e)}function k(e,t){return r.a.tidy(e,t)}function w(e){Object(l.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function I(e){return r.a.keep(e)}function time(e){return r.a.time(e)}function S(e){return r.a.setBackend(e)}function N(){return r.a.ready()}function T(){return r.a.backendName}function j(e){r.a.removeBackend(e)}function C(e){return r.a.findBackend(e)}function $(e){return r.a.findBackendFactory(e)}function E(e,t,n=1){return r.a.registerBackend(e,t,n)}function A(){return r.a.backend}function R(e,t){Object(o.c)().setPlatform(e,t)}Object(c.d)(m)},function(e,t){e.exports=function(){throw new Error("define cannot be used indirect")}},function(e,t,n){"use strict";(function(e){n.d(t,"f",(function(){return d})),n.d(t,"e",(function(){return h})),n.d(t,"a",(function(){return x})),n.d(t,"b",(function(){return v})),n.d(t,"d",(function(){return O})),n.d(t,"c",(function(){return k})),n.d(t,"i",(function(){return w})),n.d(t,"g",(function(){return I})),n.d(t,"h",(function(){return S}));var r=n(315),o=n(336),c=n(320),l=n(406);async function d(e,t){const n=[],r=[],o=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<o.length;++i){const c=o[i],l=Array.isArray(e)?e[i].tensor:e[c];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${c}': ${l.dtype}`);const d={name:c,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const e=new Promise((async e=>{const t=await l.bytes(),n=t.reduce(((p,e)=>p+e.length),0)+4*t.length,r=new Uint8Array(n);let o=0;for(let i=0;i<t.length;i++){const e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,o),o+=4,r.set(e,o),o+=e.length}e(r)}));r.push(e)}else r.push(l.data());null!=t&&(d.group=t),n.push(d)}return{data:f(await Promise.all(r)),specs:n}}function h(e,t){const n={};let d,h=0;for(const f of t){const t=f.name,m=f.dtype,y=f.shape,x=Object(c.O)(y);let v;if("quantization"in f){const n=f.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${f.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${f.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==m)throw new Error(`Weight ${f.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${m}.`)}const r=l.a[n.dtype],o=e.slice(h,h+x*r),c="uint8"===n.dtype?new Uint8Array(o):new Uint16Array(o);if("float32"===m)if("uint8"===n.dtype||"uint16"===n.dtype){v=new Float32Array(c.length);for(let i=0;i<c.length;i++){const e=c[i];v[i]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===d&&(d=N()),v=d(c)}else{if("int32"!==m)throw new Error(`Unsupported dtype in weight '${t}': ${m}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);v=new Int32Array(c.length);for(let i=0;i<c.length;i++){const e=c[i];v[i]=Math.round(e*n.scale+n.min)}}h+=x*r}else if("string"===m){const t=Object(c.O)(f.shape);v=[];for(let i=0;i<t;i++){const t=new Uint32Array(e.slice(h,h+4))[0];h+=4;const n=new Uint8Array(e.slice(h,h+t));v.push(n),h+=t}}else{const c=l.a[m],d=e.slice(h,h+x*c);if("float32"===m)v=new Float32Array(d);else if("int32"===m)v=new Int32Array(d);else if("bool"===m)v=new Uint8Array(d);else{if("complex64"!==m)throw new Error(`Unsupported dtype in weight '${t}': ${m}`);{v=new Float32Array(d);const e=new Float32Array(v.length/2),image=new Float32Array(v.length/2);for(let i=0;i<e.length;i++)e[i]=v[2*i],image[i]=v[2*i+1];const c=Object(o.a)(e,y,"float32"),l=Object(o.a)(image,y,"float32");n[t]=Object(r.a)(c,l),c.dispose(),l.dispose()}}h+=x*c}"complex64"!==m&&(n[t]=Object(o.a)(v,y,m))}return n}function f(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let o=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),o),o+=e.byteLength})),r.buffer}const m=void 0!==e&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function y(t){return m?e.byteLength(t):new Blob([t]).size}function x(t){if(m)return e.from(t).toString("base64");const n=new Uint8Array(t);let s="";for(let i=0,e=n.length;i<e;i++)s+=String.fromCharCode(n[i]);return btoa(s)}function v(t){if(m){const n=e.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const s=atob(t),n=new Uint8Array(s.length);for(let i=0;i<s.length;++i)n.set([s.charCodeAt(i)],i);return n.buffer}function O(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function k(path){for(path=path.trim();path.endsWith("/");)path=path.slice(0,path.length-1);const e=path.split("/");return e[e.length-1]}function w(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function I(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[r,o]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=o}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function S(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:y(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:y(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function N(){const e=function(){const e=i=>{let e=i<<13,t=0;for(;0==(8388608&e);)t-=8388608,e<<=1;return e&=-8388609,t+=947912704,e|t},t=new Uint32Array(2048);t[0]=0;for(let i=1;i<1024;i++)t[i]=e(i);for(let i=1024;i<2048;i++)t[i]=939524096+(i-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let i=1;i<31;i++)e[i]=i<<23;for(let i=33;i<63;i++)e[i]=2147483648+(i-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let i=0;i<64;i++)e[i]=1024;return e[0]=e[32]=0,e}();return r=>{const o=new ArrayBuffer(4*r.length),c=new Uint32Array(o);for(let o=0;o<r.length;o++){const l=r[o],d=e[n[l>>10]+(1023&l)]+t[l>>10];c[o]=d}return new Float32Array(o)}}}).call(this,n(405).Buffer)},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(281),l=n(298),d=n(280);const h=Object(d.b)({sum_:function(e,t=null,n=!1){let d=Object(c.a)(e,"x","sum");"bool"===d.dtype&&(d=Object(l.a)(d,"int32"));const h={x:d},f={axis:t,keepDims:n};return r.a.runKernel(o.ed,h,f)}})},function(e,t,n){"use strict";var r;n.d(t,"a",(function(){return r})),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(301),o=n(320);function c(e,t="float32",n){return t=t||"float32",o.c(e),new r.b(e,t,n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({zerosLike_:function(e){const t={x:Object(c.a)(e,"x","zerosLike")};return r.a.runKernel(o.pd,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n(282),o=n(281),c=n(280);const l=Object(c.b)({square_:function(e){const t=Object(o.a)(e,"x","square");return r.a.runKernel("Square",{x:t},{})}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const h=Object(d.b)({matMul_:function(a,b,e=!1,t=!1){let n=Object(l.a)(a,"a","matMul"),d=Object(l.a)(b,"b","matMul");[n,d]=Object(c.makeTypesMatch)(n,d);const h={a:n,b:d},f={transposeA:e,transposeB:t};return r.a.runKernel(o.s,h,f)}})},function(e,t,n){"use strict";function r(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o}));const o={kernelName:n(279).Identity,backendName:"cpu",kernelFunc:r}},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n(282),o=n(320),c=n(284);function l(e,t,n,l){if(null==l&&(l=Object(o.r)(e)),"complex64"===l)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(o.A)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Object(o.c)(t);const e=Object(o.O)(t),r=Object(o.O)(n);Object(o.b)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let i=0;i<n.length;++i){const e=n[i],r=i!==n.length-1||e!==Object(o.O)(t.slice(i));Object(o.b)(n[i]===t[i]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Object(o.A)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==l?Object(c.toTypedArray)(e,l):Object(o.m)(e,[],!0),r.a.makeTensor(e,t,l)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(281),l=n(320),d=n(280);const h=Object(d.b)({complex_:function(e,t){const n=Object(c.a)(e,"real","complex"),d=Object(c.a)(t,"imag","complex");l.e(n.shape,d.shape,`real and imag shapes, ${n.shape} and ${d.shape}, must match in call to tf.complex().`);const h={real:n,imag:d};return r.a.runKernel(o.A,h)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({neg_:function(e){const t={x:Object(c.a)(e,"x","neg")};return r.a.runKernel(o.ac,t)}})},function(e,t,n){"use strict";function r(e){const{inputs:t,backend:n}=e,{real:r,imag:o}=t,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,d=n.makeTensorInfo(r.shape,"complex64");return n.data.get(d.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",c),imag:n.makeTensorInfo(o.shape,"float32",l)},d}n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o}));const o={kernelName:n(279).Complex,backendName:"cpu",kernelFunc:r}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e){return(t,n,o)=>{const c=r.util.getTypedArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)c[i]=e(t[i],o);return c}}},function(e,t,n){"use strict";n.d(t,"c",(function(){return c})),n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return d}));var r=n(279),o=n(285);function c(e,t,n,o,c){const l=r.slice_util.isSliceContinous(o,t,n),d=r.util.sizeFromShape(n),h=r.util.computeStrides(o);if(l){const n=r.slice_util.computeFlatOffset(t,h);return"string"===c?e.slice(n,n+d):e.subarray(n,n+d)}const f="string"===c?r.backend_util.fromUint8ToStringArray(e):e,m=Object(r.buffer)(o,c,f),y=Object(r.buffer)(n,c);for(let i=0;i<y.size;++i){const e=y.indexToLoc(i),n=e.map(((e,n)=>e+t[n]));y.set(m.get(...n),...e)}return"string"===c?r.backend_util.fromStringArrayToUint8(y.values):y.values}function l(e){const{inputs:t,backend:n,attrs:l}=e,{x:d}=t,{begin:h,size:f}=l;Object(o.a)(d,"slice");const[m,y]=r.slice_util.parseSliceParams(d,h,f);r.slice_util.assertParamsValid(d,m,y);const x=c(n.data.get(d.dataId).values,m,y,d.shape,d.dtype);return n.makeTensorInfo(y,d.dtype,x)}const d={kernelName:r.Slice,backendName:"cpu",kernelFunc:l}},function(e,t,n){"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,d(e,t,n)}function o(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,d(e,n,r),d(t,n,r)}function c(e,t,n){return Math.max(e,Math.min(t,n))}function l(e){return e%2==0?e:e+1}function d(object,e,t){const n=object[e];object[e]=object[t],object[t]=n}function h(e){let t=0;for(let i=0;i<e.length;i++)t+=e[i];return t}function f(a,b){const e=Math.random();return b*e+(1-e)*a}function m(a,b){let e=0;for(let i=0;i<a.length;i++){const t=Number(a[i])-Number(b[i]);e+=t*t}return e}function y(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function x(e,t,n=""){y(I(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function v(a){y(null!=a,(()=>"The input to the tensor constructor must be a non-null value."))}function O(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||L(e)&&!n)for(let i=0;i<e.length;++i)O(e[i],t,n);else t.push(e);return t}function k(e){if(0===e.length)return 1;let t=e[0];for(let i=1;i<e.length;i++)t*=e[i];return t}function w(e){return 0===e.length}function I(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}function S(a){return a%1==0}function N(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function T(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function j(e){const t=new Uint32Array(e);for(let i=0;i<e;++i)t[i]=i;return r(t),t}function C(a,e){return e<=a.length?a:a+" ".repeat(e-a.length)}function $(e,t=(e=>0),n){return new Promise(((r,o)=>{let c=0;const l=()=>{if(e())return void r();c++;const d=t(c);null!=n&&c>=n?o():setTimeout(l,d)};l()}))}function E(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const o=e.slice();return o[r]=t/n,o}function A(e,t){const n=t.length;return y((e=null==e?t.map(((s,i)=>i)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),y(e.every((e=>S(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((a=>a<0?n+a:a))}function R(e,t){const n=[],r=[],o=null!=t&&Array.isArray(t)&&0===t.length,c=null==t||o?null:A(t,e).sort();let l=0;for(let i=0;i<e.length;++i){if(null!=c){if(c[l]===i&&1!==e[i])throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(null==c[l]||c[l]>i)&&1===e[i]&&(n.push(e[i]),r.push(i)),c[l]<=i&&l++}1!==e[i]&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function _(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function F(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function D(e,t){for(let i=0;i<e.length;i++){const n=e[i];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function M(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function P(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function L(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray}function B(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function z(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function V(e){return"string"==typeof e||e instanceof String}function W(e){return"boolean"==typeof e}function U(e){return"number"==typeof e}function G(e){return Array.isArray(e)?G(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":U(e)?"float32":V(e)?"string":W(e)?"bool":"float32"}function H(e){return!!(e&&e.constructor&&e.call&&e.apply)}function K(e,t){for(let i=t;i<e;++i)if(e%i==0)return i;return e}function X(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let i=t-3;i>=0;--i)n[i]=n[i+1]*e[i+1];return n}function Y(e,t,a,n=!1){const r=new Array;if(1===t.length){const o=t[0]*(n?2:1);for(let i=0;i<o;i++)r[i]=a[e+i]}else{const o=t[0],c=t.slice(1),l=c.reduce(((e,t)=>e*t))*(n?2:1);for(let i=0;i<o;i++)r[i]=Y(e+i*l,c,a,n)}return r}function Z(e,a,t=!1){if(0===e.length)return a[0];const n=e.reduce(((e,t)=>e*t))*(t?2:1);if(0===n)return[];if(n!==a.length)throw new Error(`[${e}] does not match the input size ${a.length}${t?" for a complex tensor":""}.`);return Y(0,e,a,t)}function Q(e,t){const n=J(e,t);for(let i=0;i<n.length;i++)n[i]=1;return n}function J(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function ee(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Z(e,new Float32Array(n));if("int32"===t)return Z(e,new Int32Array(n));if("bool"===t)return Z(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function te(e){e.forEach((t=>{y(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function ne(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let i=0;i<e.length-1;++i)r+=n[i]*e[i];return r}function re(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(e/n[i]),e-=r[i]*n[i];return r[r.length-1]=e,r}function ae(object){return object&&object.then&&"function"==typeof object.then}n.d(t,"M",(function(){return r})),n.d(t,"N",(function(){return o})),n.d(t,"i",(function(){return c})),n.d(t,"H",(function(){return l})),n.d(t,"S",(function(){return d})),n.d(t,"R",(function(){return h})),n.d(t,"J",(function(){return f})),n.d(t,"l",(function(){return m})),n.d(t,"b",(function(){return y})),n.d(t,"e",(function(){return x})),n.d(t,"d",(function(){return v})),n.d(t,"m",(function(){return O})),n.d(t,"O",(function(){return k})),n.d(t,"y",(function(){return w})),n.d(t,"a",(function(){return I})),n.d(t,"v",(function(){return S})),n.d(t,"T",(function(){return N})),n.d(t,"P",(function(){return T})),n.d(t,"k",(function(){return j})),n.d(t,"L",(function(){return C})),n.d(t,"K",(function(){return $})),n.d(t,"s",(function(){return E})),n.d(t,"I",(function(){return A})),n.d(t,"Q",(function(){return R})),n.d(t,"o",(function(){return _})),n.d(t,"n",(function(){return F})),n.d(t,"h",(function(){return D})),n.d(t,"B",(function(){return M})),n.d(t,"p",(function(){return P})),n.d(t,"A",(function(){return L})),n.d(t,"g",(function(){return B})),n.d(t,"f",(function(){return z})),n.d(t,"z",(function(){return V})),n.d(t,"t",(function(){return W})),n.d(t,"w",(function(){return U})),n.d(t,"r",(function(){return G})),n.d(t,"u",(function(){return H})),n.d(t,"G",(function(){return K})),n.d(t,"j",(function(){return X})),n.d(t,"U",(function(){return Z})),n.d(t,"D",(function(){return Q})),n.d(t,"F",(function(){return J})),n.d(t,"E",(function(){return ee})),n.d(t,"c",(function(){return te})),n.d(t,"C",(function(){return ne})),n.d(t,"q",(function(){return re})),n.d(t,"x",(function(){return ae}))},function(e,t,n){"use strict";var r,o,c,l,d;n.d(t,"a",(function(){return r})),n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return m})),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(o||(o={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(c||(c={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(l||(l={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(d||(d={}));const h={float32:l,int32:o,bool:c,complex64:d};function f(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return h[e][t]}function m(e){return f(e,"int32")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({abs_:function(e){const t=Object(c.a)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return r.a.runKernel(o.B,e)}{const e={x:t};return r.a.runKernel(o.a,e)}}})},function(e,t,n){"use strict";n.d(t,"c",(function(){return O})),n.d(t,"b",(function(){return k})),n.d(t,"a",(function(){return w})),n.d(t,"d",(function(){return I}));var r=n(292),o=n(362),c=n(363),l=n(289),d=n(365),h=n(342),f=n(367),m=n(286),y=n(339),x=n(368),v=n(307);function O(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Object(l.a)(e,Object(x.a)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function k(e,t){let n=t;const o=r.getReductionAxes(e.shape,t.shape);return o.length>0&&(n=Object(v.a)(n,o)),Object(m.a)(n,e.shape)}function w(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Object(h.a)(e);if("elu"===t)return Object(o.a)(e);if("relu6"===t)return Object(f.a)(e);if("prelu"===t)return Object(d.a)(e,n);if("leakyrelu"===t)return Object(c.a)(e,r);if("sigmoid"===t)return Object(y.a)(e);throw new Error(`Unknown fused activation ${t}.`)}const I=(e,t)=>!(e>0)||"linear"===t},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return f}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a+b)),d=Object(c.b)(((e,t,n,r)=>({real:e+n,imag:t+r}))),h=Object(c.a)(r.Add,l,d),f={kernelName:r.Add,backendName:"cpu",kernelFunc:h}},function(e,t,n){"use strict";n.d(t,"c",(function(){return f})),n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return y}));var r=n(279),o=n(293),c=n(410),l=n(317),d=n(313),h=n(333);function f(e,t,n,c){if("int32"===c){return[t,"int32",Int32Array.from(e)]}if("bool"===c){const c=r.util.toTypedArray([0],n),[l,d]=Object(o.a)(((a,b)=>a!==b?1:0))(t,[],e,c,"bool");return[d,"bool",l]}throw new Error(`Error in Cast: failed to cast ${n} to ${c}`)}function m(e){const{inputs:t,backend:n,attrs:o}=e,{x:y}=t,{dtype:x}=o;if("complex64"===x){if("complex64"===y.dtype)return Object(d.a)({inputs:{x:y},backend:n});const e=Object(c.a)(n,y.shape,y.dtype),t=m({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),r=Object(l.a)({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===y.dtype){const e=Object(h.a)({inputs:{input:y},backend:n}),t=m({inputs:{x:e},backend:n,attrs:{dtype:x}});return n.disposeIntermediateTensorInfo(e),t}if(!r.util.hasEncodingLoss(y.dtype,x)){const e=Object(d.a)({inputs:{x:y},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:x}}const v=n.data.get(y.dataId).values,[O,k,w]=f(v,y.shape,y.dtype,x);return n.makeTensorInfo(O,k,w)}const y={kernelName:r.Cast,backendName:"cpu",kernelFunc:m}},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return f}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((e,t)=>e*t)),d=Object(c.b)(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),h=Object(c.a)(r.Multiply,l,d),f={kernelName:r.Multiply,backendName:"cpu",kernelFunc:h}},function(e,t,n){"use strict";function r(e,element,t){const n=function(e,t,n){return function(e,t,n){let r=0,o=e.length,c=0,l=!1;for(;r<o;){c=r+(o-r>>>1);const d=n(t,e[c]);d>0?r=c+1:(o=c,l=!d)}return l?r:-r-1}(e,t,n||o)}(e,element,t),r=n<0?-(n+1):n;e.splice(r,0,element)}function o(a,b){return a>b?1:a<b?-1:0}function c(e,t,n,r,o){return h(e,t,n,r,o,0)}function l(e,t,n,r,o,c){return h(e,t,n,r,o,0,!1,c,!0)}function d(e,t,n,r,o,c){return h(e,t,n,r,o,c,!0)}function h(e,t,n,o,c,l,d=!1,h=!1,x=!1){const v=[];for(let i=0;i<t.length;i++)t[i]>c&&v.push({score:t[i],boxIndex:i,suppressBeginIndex:0});v.sort(y);const O=l>0?-.5/l:0,k=[],w=[];for(;k.length<n&&v.length>0;){const t=v.pop(),{score:n,boxIndex:l,suppressBeginIndex:d}=t;if(n<c)break;let h=!1;for(let n=k.length-1;n>=d;--n){const r=f(e,l,k[n]);if(r>=o){h=!0;break}if(t.score=t.score*m(o,O,r),t.score<=c)break}t.suppressBeginIndex=k.length,h||(t.score===n?(k.push(l),w.push(t.score)):t.score>c&&r(v,t,y))}const I=k.length,S=n-I;h&&S>0&&(k.push(...new Array(S).fill(0)),w.push(...new Array(S).fill(0)));const N={selectedIndices:k};return d&&(N.selectedScores=w),x&&(N.validOutputs=I),N}function f(e,i,t){const n=e.subarray(4*i,4*i+4),r=e.subarray(4*t,4*t+4),o=Math.min(n[0],n[2]),c=Math.min(n[1],n[3]),l=Math.max(n[0],n[2]),d=Math.max(n[1],n[3]),h=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),m=Math.max(r[0],r[2]),y=Math.max(r[1],r[3]),x=(l-o)*(d-c),v=(m-h)*(y-f);if(x<=0||v<=0)return 0;const O=Math.max(o,h),k=Math.max(c,f),w=Math.min(l,m),I=Math.min(d,y),S=Math.max(w-O,0)*Math.max(I-k,0);return S/(x+v-S)}function m(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function y(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return l})),n.d(t,"c",(function(){return d}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({clone_:function(e){const t={x:Object(c.a)(e,"x","clone","string_or_numeric")};return r.a.runKernel(o.tb,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({sqrt_:function(e){const t={x:Object(c.a)(e,"x","sqrt","float32")};return r.a.runKernel(o.Vc,t)}})},function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return c})),n.d(t,"d",(function(){return l})),n.d(t,"e",(function(){return d})),n.d(t,"a",(function(){return h})),n.d(t,"f",(function(){return f})),n.d(t,"h",(function(){return m})),n.d(t,"g",(function(){return y}));var r=n(320);function o(e,t){for(let i=0;i<e.length;++i)if(e[e.length-i-1]!==t-1-i)return!1;return!0}function c(e,t,n){const r=e.length+t.length,o=[];let c=0,l=0;for(let d=0;d<r;d++)-1===n.indexOf(d)?o.push(e[c++]):o.push(t[l++]);return o}function l(e,t){const n=[],r=e.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&n.push(e[o]);return[n,t.map((t=>e[t]))]}function d(e,t){return c(e,t.map((e=>1)),t)}function h(e,t,n){r.b(o(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function f(e,t){if(o(e,t))return null;const n=[];for(let i=0;i<t;++i)-1===e.indexOf(i)&&n.push(i);return e.forEach((e=>n.push(e))),n}function m(e){return e.map(((e,i)=>[i,e])).sort(((a,b)=>a[1]-b[1])).map((e=>e[0]))}function y(e,t){const n=[];for(let i=t-e;i<t;++i)n.push(i);return n}},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t){(function(t){e.exports=t}).call(this,{})},function(e,t,n){"use strict";function r(e){const{inputs:t,backend:n}=e,{input:input}=t,r=n.data.get(input.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o}));const o={kernelName:n(279).Real,backendName:"cpu",kernelFunc:r}},function(e,t,n){"use strict";n.d(t,"b",(function(){return o.a})),n.d(t,"c",(function(){return f})),n.d(t,"d",(function(){return m})),n.d(t,"e",(function(){return y.a})),n.d(t,"f",(function(){return v})),n.d(t,"g",(function(){return O})),n.d(t,"h",(function(){return k})),n.d(t,"i",(function(){return w})),n.d(t,"j",(function(){return I})),n.d(t,"k",(function(){return S})),n.d(t,"l",(function(){return N})),n.d(t,"m",(function(){return T})),n.d(t,"n",(function(){return C})),n.d(t,"o",(function(){return $})),n.d(t,"p",(function(){return _})),n.d(t,"q",(function(){return F})),n.d(t,"r",(function(){return W})),n.d(t,"w",(function(){return U})),n.d(t,"s",(function(){return G})),n.d(t,"t",(function(){return H})),n.d(t,"u",(function(){return K})),n.d(t,"v",(function(){return X})),n.d(t,"x",(function(){return Y})),n.d(t,"z",(function(){return Z})),n.d(t,"A",(function(){return Q})),n.d(t,"B",(function(){return J.a})),n.d(t,"C",(function(){return E.a})),n.d(t,"D",(function(){return ee})),n.d(t,"E",(function(){return te})),n.d(t,"F",(function(){return D.a})),n.d(t,"G",(function(){return ne.a})),n.d(t,"H",(function(){return M})),n.d(t,"I",(function(){return re})),n.d(t,"J",(function(){return ae})),n.d(t,"K",(function(){return se})),n.d(t,"L",(function(){return oe})),n.d(t,"M",(function(){return ue})),n.d(t,"N",(function(){return ie})),n.d(t,"O",(function(){return le})),n.d(t,"P",(function(){return de})),n.d(t,"Q",(function(){return he})),n.d(t,"R",(function(){return fe})),n.d(t,"S",(function(){return me})),n.d(t,"U",(function(){return be})),n.d(t,"V",(function(){return ge})),n.d(t,"W",(function(){return ye})),n.d(t,"X",(function(){return xe})),n.d(t,"Y",(function(){return ve})),n.d(t,"Z",(function(){return Oe})),n.d(t,"ab",(function(){return ke})),n.d(t,"bb",(function(){return div.a})),n.d(t,"cb",(function(){return Te})),n.d(t,"db",(function(){return je})),n.d(t,"fb",(function(){return Ce})),n.d(t,"gb",(function(){return $e.a})),n.d(t,"ib",(function(){return Ie})),n.d(t,"jb",(function(){return Ee})),n.d(t,"kb",(function(){return Ve})),n.d(t,"lb",(function(){return We})),n.d(t,"mb",(function(){return Ue})),n.d(t,"nb",(function(){return Ge})),n.d(t,"ob",(function(){return qe})),n.d(t,"qb",(function(){return Ke.a})),n.d(t,"rb",(function(){return Xe})),n.d(t,"sb",(function(){return Ye.a})),n.d(t,"ub",(function(){return Ze})),n.d(t,"wb",(function(){return Qe})),n.d(t,"xb",(function(){return Je})),n.d(t,"zb",(function(){return et.a})),n.d(t,"Db",(function(){return tt})),n.d(t,"Eb",(function(){return nt})),n.d(t,"Fb",(function(){return at})),n.d(t,"Gb",(function(){return st.a})),n.d(t,"Hb",(function(){return ot})),n.d(t,"Ib",(function(){return it})),n.d(t,"Kb",(function(){return ut})),n.d(t,"Lb",(function(){return ct})),n.d(t,"Mb",(function(){return lt})),n.d(t,"Nb",(function(){return pt})),n.d(t,"Ob",(function(){return bt})),n.d(t,"Pb",(function(){return gt})),n.d(t,"Qb",(function(){return yt})),n.d(t,"Rb",(function(){return xt})),n.d(t,"Sb",(function(){return vt})),n.d(t,"Tb",(function(){return Ot})),n.d(t,"Ub",(function(){return kt})),n.d(t,"Wb",(function(){return St})),n.d(t,"Xb",(function(){return P.a})),n.d(t,"Yb",(function(){return Re})),n.d(t,"Zb",(function(){return Nt})),n.d(t,"ac",(function(){return Tt})),n.d(t,"bc",(function(){return jt})),n.d(t,"cc",(function(){return Ct.a})),n.d(t,"dc",(function(){return $t})),n.d(t,"ec",(function(){return _t})),n.d(t,"fc",(function(){return _e})),n.d(t,"gc",(function(){return Ft})),n.d(t,"hc",(function(){return Dt})),n.d(t,"ic",(function(){return Mt})),n.d(t,"jc",(function(){return Pt})),n.d(t,"lc",(function(){return L.a})),n.d(t,"mc",(function(){return Lt})),n.d(t,"nc",(function(){return Bt})),n.d(t,"oc",(function(){return ft.a})),n.d(t,"qc",(function(){return zt})),n.d(t,"rc",(function(){return Vt.a})),n.d(t,"sc",(function(){return At})),n.d(t,"tc",(function(){return Wt})),n.d(t,"vc",(function(){return Ut})),n.d(t,"wc",(function(){return Gt})),n.d(t,"xc",(function(){return Ht})),n.d(t,"yc",(function(){return qt})),n.d(t,"zc",(function(){return Kt})),n.d(t,"Ac",(function(){return Xt})),n.d(t,"Bc",(function(){return Zt})),n.d(t,"Cc",(function(){return Fe.a})),n.d(t,"Dc",(function(){return Qt.a})),n.d(t,"Ec",(function(){return Jt.a})),n.d(t,"Fc",(function(){return en})),n.d(t,"Gc",(function(){return tn})),n.d(t,"Hc",(function(){return nn})),n.d(t,"Ic",(function(){return un})),n.d(t,"Jc",(function(){return cn})),n.d(t,"Kc",(function(){return ln})),n.d(t,"Lc",(function(){return dn})),n.d(t,"Mc",(function(){return pn})),n.d(t,"Nc",(function(){return hn.a})),n.d(t,"Oc",(function(){return fn})),n.d(t,"Pc",(function(){return mn.a})),n.d(t,"Qc",(function(){return bn.a})),n.d(t,"Rc",(function(){return R.a})),n.d(t,"Sc",(function(){return gn})),n.d(t,"Tc",(function(){return yn})),n.d(t,"Uc",(function(){return xn})),n.d(t,"Vc",(function(){return vn})),n.d(t,"Wc",(function(){return On})),n.d(t,"Yc",(function(){return kn})),n.d(t,"Zc",(function(){return wn})),n.d(t,"ad",(function(){return De.a})),n.d(t,"dd",(function(){return In})),n.d(t,"ed",(function(){return Sn})),n.d(t,"fd",(function(){return Nn})),n.d(t,"gd",(function(){return B.a})),n.d(t,"hd",(function(){return Tn})),n.d(t,"jd",(function(){return jn})),n.d(t,"kd",(function(){return Cn})),n.d(t,"ld",(function(){return z})),n.d(t,"md",(function(){return $n})),n.d(t,"nd",(function(){return En})),n.d(t,"od",(function(){return An})),n.d(t,"pd",(function(){return Rn})),n.d(t,"qd",(function(){return _n})),n.d(t,"rd",(function(){return mt})),n.d(t,"sd",(function(){return Yt})),n.d(t,"pb",(function(){return Fn})),n.d(t,"yb",(function(){return Dn})),n.d(t,"Cb",(function(){return Mn})),n.d(t,"Xc",(function(){return Ln})),n.d(t,"wd",(function(){return Pn})),n.d(t,"xd",(function(){return Me.a})),n.d(t,"yd",(function(){return Pe.a})),n.d(t,"zd",(function(){return Bn})),n.d(t,"Ad",(function(){return zn})),n.d(t,"Bd",(function(){return Vn})),n.d(t,"Cd",(function(){return Wn.a})),n.d(t,"Dd",(function(){return Un})),n.d(t,"Fd",(function(){return sub.a})),n.d(t,"Gd",(function(){return Le.a})),n.d(t,"Hd",(function(){return Gn})),n.d(t,"Id",(function(){return V})),n.d(t,"Jd",(function(){return Hn.a})),n.d(t,"Kd",(function(){return Kn})),n.d(t,"Ld",(function(){return Xn})),n.d(t,"Md",(function(){return Yn.a})),n.d(t,"Nd",(function(){return Zn})),n.d(t,"Od",(function(){return Qn})),n.d(t,"Pd",(function(){return Jn})),n.d(t,"Qd",(function(){return He})),n.d(t,"Rd",(function(){return er})),n.d(t,"Td",(function(){return nr})),n.d(t,"Ud",(function(){return rr})),n.d(t,"Vd",(function(){return ar})),n.d(t,"Wd",(function(){return sr})),n.d(t,"Xd",(function(){return or})),n.d(t,"Yd",(function(){return ir})),n.d(t,"Zd",(function(){return Se})),n.d(t,"ae",(function(){return cr})),n.d(t,"be",(function(){return Et})),n.d(t,"ce",(function(){return Ne.a})),n.d(t,"y",(function(){return lr})),n.d(t,"Sd",(function(){return dr.a})),n.d(t,"pc",(function(){return ze})),n.d(t,"kc",(function(){return pr})),n.d(t,"bd",(function(){return mr})),n.d(t,"cd",(function(){return It})),n.d(t,"ud",(function(){return gr})),n.d(t,"vb",(function(){return yr})),n.d(t,"eb",(function(){return xr})),n.d(t,"hb",(function(){return vr})),n.d(t,"T",(function(){return Or})),n.d(t,"Bb",(function(){return kr})),n.d(t,"uc",(function(){return h.b})),n.d(t,"a",(function(){return h.a})),n.d(t,"Ab",(function(){return va})),n.d(t,"Jb",(function(){return Oa})),n.d(t,"Vb",(function(){return ka})),n.d(t,"vd",(function(){return ya})),n.d(t,"tb",(function(){return r})),n.d(t,"id",(function(){return xa})),n.d(t,"td",(function(){return wa})),n.d(t,"Ed",(function(){return Ia}));var r={};n.r(r),n.d(r,"conv2d",(function(){return Sr})),n.d(r,"depthwiseConv2d",(function(){return jr})),n.d(r,"matMul",(function(){return Cr}));var o=n(322),c=n(282),l=n(283),d=n(281),h=n(280);const f=Object(h.b)({acos_:function(e){const t={x:Object(d.a)(e,"x","acos")};return c.a.runKernel(l.b,t)}});const m=Object(h.b)({acosh_:function(e){const t={x:Object(d.a)(e,"x","acosh")};return c.a.runKernel(l.c,t)}});var y=n(291),x=n(320);const v=Object(h.b)({addN_:function(e){x.b(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),x.b(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,i)=>Object(d.a)(e,`tensors${i}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!x.a(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return c.a.runKernel(l.e,r)}});const O=Object(h.b)({all_:function(e,t=null,n=!1){const r={x:Object(d.a)(e,"x","all","bool")},o={axis:t,keepDims:n};return c.a.runKernel(l.f,r,o)}});const k=Object(h.b)({any_:function(e,t=null,n=!1){const r={x:Object(d.a)(e,"x","any","bool")},o={axis:t,keepDims:n};return c.a.runKernel(l.g,r,o)}});const w=Object(h.b)({argMax_:function(e,t=0){const n={x:Object(d.a)(e,"x","argMax")},r={axis:t};return c.a.runKernel(l.h,n,r)}});const I=Object(h.b)({argMin_:function(e,t=0){const n={x:Object(d.a)(e,"x","argMin")},r={axis:t};return c.a.runKernel(l.i,n,r)}});const S=Object(h.b)({asin_:function(e){const t={x:Object(d.a)(e,"x","asin")};return c.a.runKernel(l.j,t)}});const N=Object(h.b)({asinh_:function(e){const t={x:Object(d.a)(e,"x","asinh")};return c.a.runKernel(l.k,t)}});const T=Object(h.b)({atan_:function(e){const t={x:Object(d.a)(e,"x","atan")};return c.a.runKernel(l.l,t)}});var j=n(288);const C=Object(h.b)({atan2_:function(a,b){let e=Object(d.a)(a,"a","atan2"),t=Object(d.a)(b,"b","atan2");[e,t]=Object(j.makeTypesMatch)(e,t);const n={a:e,b:t};return c.a.runKernel(l.m,n)}});const $=Object(h.b)({atanh_:function(e){const t={x:Object(d.a)(e,"x","atanh")};return c.a.runKernel(l.n,t)}});var E=n(298),A=n(300),R=n(286);const _=Object(h.b)({avgPool_:function(e,t,n,r,o){const h=Object(d.a)(e,"x","avgPool","float32");x.b(A.i(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let f=h,m=!1;3===h.rank&&(m=!0,f=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),x.b(4===f.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${f.rank}.`)),A.a("avgPool",r,o);const y={x:f},v={filterSize:t,strides:n,pad:r,dimRoundingMode:o};let O=c.a.runKernel(l.o,y,v);return O=Object(E.a)(O,h.dtype),m?Object(R.a)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}});const F=Object(h.b)({avgPool3d_:function(e,t,n,r,o,h="NDHWC"){const f=Object(d.a)(e,"x","avgPool3d","float32");let m=f,y=!1;4===f.rank&&(y=!0,m=Object(R.a)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),x.b(5===m.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${m.rank}.`)),x.b("NDHWC"===h,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${h}`)),Object(A.a)("avgPool3d",r,o);const v={x:m},O={filterSize:t,strides:n,pad:r,dimRoundingMode:o,dataFormat:h};let k=c.a.runKernel(l.p,v,O);return k=Object(E.a)(k,m.dtype),y?Object(R.a)(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}});var D=n(328);const M=Object(h.b)({concat_:function(e,t=0){Object(x.b)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Object(d.b)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Object(D.a)(n[0]);const r=n,o={axis:t};return c.a.runKernel(l.C,r,o)}});var P=n(312),L=n(289),B=n(339);const z=Object(h.b)({slice_:function(e,t,n){const r=Object(d.a)(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const o={x:r},h={begin:t,size:n};return c.a.runKernel(l.Lc,o,h)}});const V=Object(h.b)({tanh_:function(e){const t={x:Object(d.a)(e,"x","tanh","float32")};return c.a.runKernel(l.gd,t)}});const W=Object(h.b)({basicLSTMCell_:function(e,t,n,data,r,o){const c=Object(d.a)(e,"forgetBias","basicLSTMCell"),l=Object(d.a)(t,"lstmKernel","basicLSTMCell"),h=Object(d.a)(n,"lstmBias","basicLSTMCell"),f=Object(d.a)(data,"data","basicLSTMCell"),m=Object(d.a)(r,"c","basicLSTMCell"),x=Object(d.a)(o,"h","basicLSTMCell"),v=M([f,x],1),O=Object(P.a)(v,l),k=Object(y.a)(O,h),w=k.shape[0],I=k.shape[1]/4,S=[w,I],i=z(k,[0,0],S),N=z(k,[0,I],S),T=z(k,[0,2*I],S),j=z(k,[0,3*I],S),C=Object(y.a)(Object(L.a)(Object(B.a)(i),V(N)),Object(L.a)(m,Object(B.a)(Object(y.a)(c,T))));return[C,Object(L.a)(V(C),Object(B.a)(j))]}});const U=Object(h.b)({batchToSpaceND_:function(e,t,n){const r=Object(d.a)(e,"x","batchToSpaceND"),o=t.reduce(((a,b)=>a*b));x.b(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),x.b(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),x.b(r.shape[0]%o==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`));const h={x:r},f={blockShape:t,crops:n};return c.a.runKernel(l.t,h,f)}});const G=Object(h.b)({batchNorm_:function(e,t,n,r,o,h){null==h&&(h=.001);const f=Object(d.a)(e,"x","batchNorm"),m=Object(d.a)(t,"mean","batchNorm"),y=Object(d.a)(n,"variance","batchNorm");let v,O;null!=o&&(v=Object(d.a)(o,"scale","batchNorm")),null!=r&&(O=Object(d.a)(r,"offset","batchNorm")),x.b(m.rank===y.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),x.b(null==O||m.rank===O.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),x.b(null==v||m.rank===v.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const k=function(e){let t;return t=0===e.rank||1===e.rank?Object(R.a)(e,[1,1,1,e.size]):2===e.rank?Object(R.a)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Object(R.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(f),w={x:k,scale:v,offset:O,mean:m,variance:y},I={varianceEpsilon:h},S=c.a.runKernel(l.lb,w,I);return Object(R.a)(S,f.shape)}});const H=Object(h.b)({batchNorm2d_:function(e,t,n,r,o,c){const l=Object(d.a)(e,"x","batchNorm"),h=Object(d.a)(t,"mean","batchNorm"),f=Object(d.a)(n,"variance","batchNorm");let m,y;return null!=o&&(m=Object(d.a)(o,"scale","batchNorm")),null!=r&&(y=Object(d.a)(r,"offset","batchNorm")),x.b(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),x.b(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${h.rank}.`)),x.b(2===f.rank||1===f.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${f.rank}.`)),null!=m&&x.b(2===m.rank||1===m.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${m.rank}.`)),null!=y&&x.b(2===y.rank||1===y.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${y.rank}.`)),G(l,h,f,y,m,c)}});const K=Object(h.b)({batchNorm3d_:function(e,t,n,r,o,c){const l=Object(d.a)(e,"x","batchNorm"),h=Object(d.a)(t,"mean","batchNorm"),f=Object(d.a)(n,"variance","batchNorm");let m,y;return null!=o&&(m=Object(d.a)(o,"scale","batchNorm")),null!=r&&(y=Object(d.a)(r,"offset","batchNorm")),x.b(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),x.b(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${h.rank}.`)),x.b(3===f.rank||1===f.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${f.rank}.`)),null!=m&&x.b(3===m.rank||1===m.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${m.rank}.`)),null!=y&&x.b(3===y.rank||1===y.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${y.rank}.`)),G(l,h,f,y,m,c)}});const X=Object(h.b)({batchNorm4d_:function(e,t,n,r,o,c){const l=Object(d.a)(e,"x","batchNorm"),h=Object(d.a)(t,"mean","batchNorm"),f=Object(d.a)(n,"variance","batchNorm");let m,y;return null!=o&&(m=Object(d.a)(o,"scale","batchNorm")),null!=r&&(y=Object(d.a)(r,"offset","batchNorm")),x.b(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),x.b(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${h.rank}.`)),x.b(4===f.rank||1===f.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${f.rank}.`)),null!=m&&x.b(4===m.rank||1===m.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${m.rank}.`)),null!=y&&x.b(4===y.rank||1===y.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${y.rank}.`)),G(l,h,f,y,m,c)}});const Y=Object(h.b)({bincount_:function(e,t,n){const r=Object(d.a)(e,"x","bincount"),o=Object(d.a)(t,"weights","bincount");x.b("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),x.b(n>=0,(()=>`size must be non-negative, but got ${n}.`)),x.b(o.size===r.size||0===o.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`));const h={x:r,weights:o},f={size:n};return c.a.runKernel(l.u,h,f)}});const Z=Object(h.b)({broadcastArgs_:function(e,t){const n=Object(d.a)(e,"s0","broadcastArgs","int32"),r=Object(d.a)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const o={s0:n,s1:r};return c.a.runKernel(l.v,o)}});const Q=Object(h.b)({broadcastTo_:function(e,t){let input=Object(d.a)(e,"broadcastTo","x");const n=input.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<input.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${input.rank}.`);if(t.length>input.rank){const e=input.shape.slice();for(;e.length<t.length;)e.unshift(1);input=Object(R.a)(input,e)}const r=input.shape,o=Array.from(t);for(let i=t.length-1;i>=0;i--)if(r[i]===t[i])o[i]=1;else if(1!==input.shape[i])throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(0===o.map(((e,i)=>e>1?i:-1)).filter((i=>i>=0)).length)return Object(D.a)(input);const h={x:input},f={reps:o};return c.a.runKernel(l.hd,h,f)}});var J=n(309);const ee=Object(h.b)({ceil_:function(e){const t={x:Object(d.a)(e,"x","ceil","float32")};return c.a.runKernel(l.y,t)}});const te=Object(h.b)({clipByValue_:function(e,t,n){const r=Object(d.a)(e,"x","clipByValue");x.b(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const o={x:r},h={clipValueMin:t,clipValueMax:n};return c.a.runKernel(l.z,o,h)}});var ne=n(315);const re=Object(h.b)({concat1d_:function(e){return M(e,0)}});const ae=Object(h.b)({concat2d_:function(e,t){return M(e,t)}});const se=Object(h.b)({concat3d_:function(e,t){return M(e,t)}});const oe=Object(h.b)({concat4d_:function(e,t){return M(e,t)}});const ie=Object(h.b)({conv2d_:function(e,filter,t,n,r="NHWC",o=[1,1],h){const f=Object(d.a)(e,"x","conv2d","float32"),m=Object(d.a)(filter,"filter","conv2d","float32");let y=f,v=!1;3===f.rank&&(v=!0,y=Object(R.a)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),x.b(4===y.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${y.rank}.`)),x.b(4===m.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${m.rank}.`)),A.a("conv2d",n,h);const O="NHWC"===r?y.shape[3]:y.shape[1];x.b(O===m.shape[2],(()=>`Error in conv2d: depth of input (${O}) must match input depth for filter ${m.shape[2]}.`)),x.b(A.i(t,o),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`));const k={x:y,filter:m},w={strides:t,pad:n,dataFormat:r,dilations:o,dimRoundingMode:h},I=c.a.runKernel(l.D,k,w);return v?Object(R.a)(I,[I.shape[1],I.shape[2],I.shape[3]]):I}});const ue=Object(h.b)({conv1d_:function(e,filter,t,n,r="NWC",o=1,c){const l=Object(d.a)(e,"x","conv1d"),h=Object(d.a)(filter,"filter","conv1d");let f=l,m=!1;2===l.rank&&(m=!0,f=Object(R.a)(l,[1,l.shape[0],l.shape[1]])),x.b(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),x.b(3===h.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`)),A.a("conv1d",n,c),x.b(f.shape[2]===h.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${h.shape[1]}.`)),x.b(A.i(t,o),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`)),x.b("NWC"===r,(()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));const y=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),v=Object(R.a)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),O=ie(v,y,[1,t],n,"NHWC",[1,o],c);return m?Object(R.a)(O,[O.shape[2],O.shape[3]]):Object(R.a)(O,[O.shape[0],O.shape[2],O.shape[3]])}});const ce=Object(h.b)({conv2DBackpropInput_:function(e,t,filter,n,r,o="NHWC",d){x.b(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let h=e,f=t,m=!1;3===t.rank&&(m=!0,f=Object(R.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,e[0],e[1],e[2]]),x.b(4===h.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`)),x.b(4===f.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${f.rank}`)),x.b(4===filter.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`));const y="NHWC"===o?h[3]:h[1],v="NHWC"===o?f.shape[3]:f.shape[1];x.b(y===filter.shape[2],(()=>`Error in conv2dDerInput: depth of input (${y}) must match input depth for filter ${filter.shape[2]}.`)),x.b(v===filter.shape[3],(()=>`Error in conv2dDerInput: depth of output (${v}) must match output depth for filter ${filter.shape[3]}.`)),A.a("conv2dDerInput",r,d);const O={dy:f,filter:filter},k={strides:n,pad:r,dataFormat:o,dimRoundingMode:d,inputShape:h},w=c.a.runKernel(l.F,O,k);return m?Object(R.a)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}});const le=Object(h.b)({conv2dTranspose_:function(e,filter,t,n,r,o){const c=Object(d.a)(e,"x","conv2dTranspose"),l=Object(d.a)(filter,"filter","conv2dTranspose");return ce(t,c,l,n,r,"NHWC",o)}});const de=Object(h.b)({conv3d_:function(e,filter,t,n,r="NDHWC",o=[1,1,1]){const h=Object(d.a)(e,"x","conv3d"),f=Object(d.a)(filter,"filter","conv3d");let m=h,y=!1;4===h.rank&&(y=!0,m=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),x.b(5===m.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${m.rank}.`)),x.b(5===f.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${f.rank}.`)),x.b(m.shape[4]===f.shape[3],(()=>`Error in conv3d: depth of input (${m.shape[4]}) must match input depth for filter ${f.shape[3]}.`)),x.b(Object(A.i)(t,o),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`)),x.b("NDHWC"===r,(()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`));const v={x:m,filter:f},O={strides:t,pad:n,dataFormat:r,dilations:o},k=c.a.runKernel(l.G,v,O);return y?Object(R.a)(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}});const pe=Object(h.b)({conv3DBackpropInput_:function(e,t,filter,n,r){x.b(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,d=t,h=!1;4===t.rank&&(h=!0,d=Object(R.a)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const f=o[4],m=d.shape[4];x.b(5===o.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`)),x.b(5===d.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${d.rank}`)),x.b(5===filter.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`)),x.b(f===filter.shape[3],(()=>`Error in conv3dDerInput: depth of input (${f}) must match input depth for filter ${filter.shape[3]}.`)),x.b(m===filter.shape[4],(()=>`Error in conv3dDerInput: depth of output (${m}) must match output depth for filter ${filter.shape[4]}.`));const y={dy:d,filter:filter},v={pad:r,strides:n,inputShape:o},O=c.a.runKernel(l.I,y,v);return h?Object(R.a)(O,[O.shape[1],O.shape[2],O.shape[3],O.shape[4]]):O}});const he=Object(h.b)({conv3dTranspose_:function(e,filter,t,n,r){const o=Object(d.a)(e,"x","conv3dTranspose"),c=Object(d.a)(filter,"filter","conv3dTranspose");return pe(t,o,c,n,r)}});const fe=Object(h.b)({cos_:function(e){const t={x:Object(d.a)(e,"x","cos","float32")};return c.a.runKernel(l.J,t)}});const me=Object(h.b)({cosh_:function(e){const t={x:Object(d.a)(e,"x","cosh","float32")};return c.a.runKernel(l.K,t)}});const be=Object(h.b)({cumprod_:function(e,t=0,n=!1,r=!1){const o={x:Object(d.a)(e,"x","cumprod")},h={axis:t,exclusive:n,reverse:r};return c.a.runKernel(l.M,o,h)}});const ge=Object(h.b)({cumsum_:function(e,t=0,n=!1,r=!1){const o={x:Object(d.a)(e,"x","cumsum")},h={axis:t,exclusive:n,reverse:r};return c.a.runKernel(l.N,o,h)}});const ye=Object(h.b)({denseBincount_:function(e,t,n,r=!1){const o=Object(d.a)(e,"x","denseBincount"),h=Object(d.a)(t,"weights","denseBincount");x.b("int32"===o.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`)),x.b(o.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`)),x.b(n>=0,(()=>`size must be non-negative, but got ${n}.`)),x.b(h.size===o.size||0===h.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${h.shape}.`));const f={x:o,weights:h},m={size:n,binaryOutput:r};return c.a.runKernel(l.O,f,m)}});const xe=Object(h.b)({depthToSpace_:function(e,t,n="NHWC"){const r=Object(d.a)(e,"x","depthToSpace","float32"),o="NHWC"===n?r.shape[1]:r.shape[2],h="NHWC"===n?r.shape[2]:r.shape[3],f="NHWC"===n?r.shape[3]:r.shape[1];x.b(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),x.b(o*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),x.b(h*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${h} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),x.b(f%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${f} for depthToSpace with input shape ${r.shape}`));const m={x:r},y={blockSize:t,dataFormat:n};return c.a.runKernel(l.P,m,y)}});const ve=Object(h.b)({depthwiseConv2d_:function(e,filter,t,n,r="NHWC",o=[1,1],h){const f=Object(d.a)(e,"x","depthwiseConv2d","float32"),m=Object(d.a)(filter,"filter","depthwiseConv2d","float32");let y=f,v=!1;3===f.rank&&(v=!0,y=Object(R.a)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),x.b(4===y.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`)),x.b(4===m.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`));const O="NHWC"===r?y.shape[3]:y.shape[1];x.b(O===m.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${O}) must match the inChannels dimension in filter ${m.shape[2]}.`)),A.a("depthwiseConv2d",n,h);const k={x:y,filter:m},w={strides:t,pad:n,dataFormat:r,dilations:o,dimRoundingMode:h},I=c.a.runKernel(l.Q,k,w);return v?Object(R.a)(I,[I.shape[1],I.shape[2],I.shape[3]]):I}});const Oe=Object(h.b)({diag_:function(e){const t={x:Object(d.a)(e,"x","diag")};return c.a.runKernel(l.T,t)}});const ke=Object(h.b)({dilation2d_:function(e,filter,t,n,r=[1,1],o="NHWC"){const h=Object(d.a)(e,"x","dilation2d"),f=Object(d.a)(filter,"filter","dilation2d");x.b(3===h.rank||4===h.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${h.rank}.`)),x.b(3===f.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${f.rank}.`)),x.b("NHWC"===o,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`));let m=h,y=!1;3===h.rank&&(m=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),y=!0);const v={x:m,filter:f},O={strides:t,pad:n,dilations:r},k=c.a.runKernel(l.U,v,O);return y?Object(R.a)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}});var div=n(299),we=n(292);const Ie=Object(h.b)({equal_:function(a,b){let e=Object(d.a)(a,"a","equal","string_or_numeric"),t=Object(d.a)(b,"b","equal","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.ab,n)}});const Se=Object(h.b)({where_:function(e,a,b){const t=Object(d.a)(a,"a","where"),n=Object(d.a)(b,"b","where"),r=Object(d.a)(e,"condition","where","bool"),o=Object(we.assertAndGetBroadcastShape)(Object(we.assertAndGetBroadcastShape)(r.shape,t.shape),n.shape),h={condition:Q(r,o),t:Q(t,o),e:Q(n,o)};return c.a.runKernel(l.Fc,h)}});var Ne=n(310);const Te=Object(h.b)({divNoNan_:function(a,b){let e=Object(d.a)(a,"a","div"),t=Object(d.a)(b,"b","div");[e,t]=Object(j.makeTypesMatch)(e,t);const n=Object(div.a)(e,t),r=Object(Ne.a)(n),o=Ie(t,r);return Se(o,r,n)}});const je=Object(h.b)({dot_:function(e,t){const n=Object(d.a)(e,"t1","dot"),r=Object(d.a)(t,"t2","dot");x.b(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const o=1===n.rank?n.size:n.shape[1],c=1===r.rank?r.size:r.shape[0];if(x.b(o===c,(()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${c}.`)),1===n.rank&&1===r.rank){const e=Object(R.a)(n,[1,-1]),t=Object(R.a)(r,[-1,1]),o=Object(P.a)(e,t);return Object(R.a)(o,[])}if(1===n.rank&&2===r.rank){const e=Object(R.a)(n,[1,-1]),t=Object(R.a)(r,[r.shape[0],r.shape[1]]),o=Object(P.a)(e,t);return Object(R.a)(o,[o.size])}if(2===n.rank&&1===r.rank){const e=Object(R.a)(r,[-1,1]),t=Object(P.a)(n,e);return Object(R.a)(t,[t.size])}{const e=Object(R.a)(r,[r.shape[0],r.shape[1]]);return Object(P.a)(n,e)}}});const Ce=Object(h.b)({einsum_:function(e,...t){const n=t.map(((e,i)=>Object(d.a)(e,`tensors${i}`,"einsum"))),r={equation:e};return c.a.runKernel(l.X,n,r)}});var $e=n(362);const Ee=Object(h.b)({erf_:function(e){let t=Object(d.a)(e,"x","erf");x.b("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Object(E.a)(t,"float32"));const n={x:t};return c.a.runKernel(l.bb,n)}});var Ae=n(330);const Re=Object(h.b)({max_:function(e,t=null,n=!1){const r={x:Object(d.a)(e,"x","max")},o={reductionIndices:t,keepDims:n};return c.a.runKernel(l.Mb,r,o)}});const _e=Object(h.b)({min_:function(e,t=null,n=!1){const r={x:Object(d.a)(e,"x","min")},o={axis:t,keepDims:n};return c.a.runKernel(l.Ub,r,o)}});var Fe=n(338),De=n(297),Me=n(329),Pe=n(311),Le=n(307);function Be(e,p,t=null){if(0===e.rank)return Object(o.a)(e);if(1!==e.rank&&null===t)return Be(Object(R.a)(e,[-1]),p,t);if(1===e.rank||"number"==typeof t||Array.isArray(t)&&1===t.length){if(1===p)return Object(Le.a)(Object(o.a)(e),t);if(p===1/0)return Re(Object(o.a)(e),t);if(p===-1/0)return _e(Object(o.a)(e),t);if("euclidean"===p||2===p)return Object(Me.a)(Object(Le.a)(Object(Fe.a)(Object(o.a)(e),Object(De.a)(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${p}`)}if(Array.isArray(t)&&2===t.length){if(1===p)return Re(Object(Le.a)(Object(o.a)(e),t[0]),t[1]-1);if(p===1/0)return Re(Object(Le.a)(Object(o.a)(e),t[1]),t[0]);if(p===-1/0)return _e(Object(Le.a)(Object(o.a)(e),t[1]),t[0]);if("fro"===p||"euclidean"===p)return Object(Me.a)(Object(Le.a)(Object(Pe.a)(e),t));throw new Error(`Error in norm: invalid ord value: ${p}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const ze=Object(h.b)({norm_:function(e,t="euclidean",n=null,r=!1){const o=Be(e=Object(d.a)(e,"x","norm"),t,n);let c=o.shape;if(r){const t=Object(x.I)(n,e.shape);c=Ae.e(o.shape,t)}return Object(R.a)(o,c)}});const Ve=Object(h.b)({euclideanNorm_:function(e,t=null,n=!1){return ze(e,"euclidean",t,n)}});const We=Object(h.b)({exp_:function(e){const t={x:Object(d.a)(e,"x","exp")};return c.a.runKernel(l.cb,t)}});const Ue=Object(h.b)({expandDims_:function(e,t=0){const n=Object(d.a)(e,"x","expandDims","string_or_numeric");x.b(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},o={dim:t};return c.a.runKernel(l.db,r,o)}});const Ge=Object(h.b)({expm1_:function(e){const t={x:Object(d.a)(e,"x","expm1")};return c.a.runKernel(l.eb,t)}});const He=Object(h.b)({tile_:function(e,t){const n=Object(d.a)(e,"x","tile","string_or_numeric");x.b(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},o={reps:t};return c.a.runKernel(l.hd,r,o)}});const qe=Object(h.b)({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const o=Object(J.a)([e,t],r),c=e<=t?e:t;for(let i=0;i<c;++i)o.set(1,i,i);const l=Object(R.a)(o.toTensor(),[e,t]);if(null==n)return l;if(1===n.length)return He(Ue(l,0),[n[0],1,1]);if(2===n.length)return He(Ue(Ue(l,0),0),[n[0],n[1],1,1]);if(3===n.length)return He(Ue(Ue(Ue(l,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Ke=n(337);const Xe=Object(h.b)({floor_:function(e){const t={x:Object(d.a)(e,"x","floor","float32")};return c.a.runKernel(l.ib,t)}});var Ye=n(360);const Ze=Object(h.b)({gather_:function(e,t,n=0,r=0){const o={x:Object(d.a)(e,"x","gather"),indices:Object(d.a)(t,"indices","gather","int32")},h={axis:n,batchDims:r};return c.a.runKernel(l.pb,o,h)}});const Qe=Object(h.b)({greater_:function(a,b){let e=Object(d.a)(a,"a","greater","string_or_numeric"),t=Object(d.a)(b,"b","greater","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.qb,n)}});const Je=Object(h.b)({greaterEqual_:function(a,b){let e=Object(d.a)(a,"a","greaterEqual","string_or_numeric"),t=Object(d.a)(b,"b","greaterEqual","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.rb,n)}});var et=n(340);const tt=Object(h.b)({isFinite_:function(e){const t={x:Object(d.a)(e,"x","isFinite")};return c.a.runKernel(l.vb,t)}});const nt=Object(h.b)({isInf_:function(e){const t={x:Object(d.a)(e,"x","isInf")};return c.a.runKernel(l.wb,t)}});const at=Object(h.b)({isNaN_:function(e){const t={x:Object(d.a)(e,"x","isNaN")};return c.a.runKernel(l.xb,t)}});var st=n(363);const ot=Object(h.b)({less_:function(a,b){let e=Object(d.a)(a,"a","less","string_or_numeric"),t=Object(d.a)(b,"b","less","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Bb,n)}});const it=Object(h.b)({lessEqual_:function(a,b){let e=Object(d.a)(a,"a","lessEqual","string_or_numeric"),t=Object(d.a)(b,"b","lessEqual","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Cb,n)}});function ut(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return c.a.runKernel(l.Db,{},r)}const ct=Object(h.b)({localResponseNormalization_:function(e,t=5,n=1,r=1,o=.5){const h=Object(d.a)(e,"x","localResponseNormalization");x.b(4===h.rank||3===h.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${h.rank}.`)),x.b(x.v(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let f=h,m=!1;3===h.rank&&(m=!0,f=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]]));const y={x:f},v={depthRadius:t,bias:n,alpha:r,beta:o},O=c.a.runKernel(l.yb,y,v);return m?Object(R.a)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}});const lt=Object(h.b)({log_:function(e){const t={x:Object(d.a)(e,"x","log","float32")};return c.a.runKernel(l.Eb,t)}});const pt=Object(h.b)({log1p_:function(e){const t={x:Object(d.a)(e,"x","log1p")};return c.a.runKernel(l.Fb,t)}});var ht=n(302),ft=n(316);const mt=Object(h.b)({softplus_:function(e){const t={x:Object(d.a)(e,"x","softplus")};return c.a.runKernel(l.Nc,t)}});const bt=Object(h.b)({logSigmoid_:function(e){const t=Object(d.a)(e,"x","logSigmoid"),n=Object(ht.a)((e=>({value:Object(ft.a)(mt(Object(ft.a)(e))),gradFunc:t=>Object(L.a)(t,Object(B.a)(Object(ft.a)(e)))})));return n(t)}});var sub=n(295);const gt=Object(h.b)({logSoftmax_:function(e,t=-1){const n=Object(d.a)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=Object(ht.a)(((e,n)=>{const r=Re(e,t,!0),o=Object(sub.a)(e,r),c=Object(sub.a)(Object(E.a)(o,"float32"),lt(Object(Le.a)(We(o),t,!0)));n([c]);return{value:c,gradFunc:(e,n)=>{const[r]=n,o=We(r);return Object(sub.a)(e,Object(L.a)(Object(Le.a)(e,t,!0),o))}}}));return r(n)}});const yt=Object(h.b)({logSumExp_:function(e,t=null,n=!1){const r=Object(d.a)(e,"x","logSumExp"),o=Object(x.I)(t,r.shape),c=Re(r,o,!0),a=Object(sub.a)(r,c),b=We(a),l=Object(Le.a)(b,o),h=lt(l),f=Object(y.a)(Object(R.a)(c,h.shape),h);if(n){const e=Object(Ae.e)(f.shape,o);return Object(R.a)(f,e)}return f}});const xt=Object(h.b)({logicalAnd_:function(a,b){const e=Object(d.a)(a,"a","logicalAnd","bool"),t=Object(d.a)(b,"b","logicalAnd","bool");Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Hb,n)}});const vt=Object(h.b)({logicalNot_:function(e){const t={x:Object(d.a)(e,"x","logicalNot","bool")};return c.a.runKernel(l.Ib,t)}});const Ot=Object(h.b)({logicalOr_:function(a,b){const e=Object(d.a)(a,"a","logicalOr","bool"),t=Object(d.a)(b,"b","logicalOr","bool");Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Jb,n)}});const kt=Object(h.b)({logicalXor_:function(a,b){const e=Object(d.a)(a,"a","logicalXor","bool"),t=Object(d.a)(b,"b","logicalXor","bool");return Object(we.assertAndGetBroadcastShape)(e.shape,t.shape),xt(Ot(a,b),vt(xt(a,b)))}}),wt=2147483648;const It=Object(h.b)({searchSorted_:function(e,t,n="left"){const r=Object(d.a)(e,"sortedSequence","searchSorted"),o=Object(d.a)(t,"values","searchSorted"),h=r.shape[r.shape.length-1],f=o.shape[o.shape.length-1],m=Object(R.a)(r,[-1,h]),y=Object(R.a)(o,[-1,f]);if(m.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(m.shape[0]!==y.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Object(x.O)(y.shape)>=wt)throw new Error("values tensor size must less than 2147483648");if(m.shape[1]>=wt)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${m.shape[1]}`);const v={sortedSequence:m,values:y},O={side:n};return c.a.runKernel(l.Ec,v,O)}});function St(e,t){return It(e,t,"left")}const Nt=Object(h.b)({maxPool_:function(e,t,n,r,o){const h=Object(d.a)(e,"x","maxPool");let f=h,m=!1;3===h.rank&&(m=!0,f=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),x.b(4===f.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${f.rank}.`)),x.b(A.i(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),A.a("maxPool",r,o);const y={x:f},v={filterSize:t,strides:n,pad:r,dimRoundingMode:o},O=c.a.runKernel(l.Nb,y,v);return m?Object(R.a)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}});const Tt=Object(h.b)({maxPool3d_:function(e,t=[1,1,1],n,r,o,h="NDHWC"){const f=Object(d.a)(e,"x","maxPool3d");let m=f,y=!1;4===f.rank&&(y=!0,m=Object(R.a)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),x.b(5===m.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${m.rank}.`)),x.b("NDHWC"===h,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${h}`)),Object(A.a)("maxPool3d",r,o);const v={x:m},O={filterSize:t,strides:n,pad:r,dimRoundingMode:o,dataFormat:h},k=c.a.runKernel(l.Ob,v,O);return y?Object(R.a)(k,[k.shape[1],k.shape[2],k.shape[3],k.shape[4]]):k}});const jt=Object(h.b)({maxPoolWithArgmax_:function(e,t,n,r,o=!1){const h={x:Object(d.a)(e,"x","maxPoolWithArgmax")},f={filterSize:t,strides:n,pad:r,includeBatchInIndex:o},m=c.a.runKernel(l.Rb,h,f);return{result:m[0],indexes:m[1]}}});var Ct=n(361);const $t=Object(h.b)({mean_:function(e,t=null,n=!1){const r={x:Object(d.a)(e,"x","mean")},o={axis:t,keepDims:n};return c.a.runKernel(l.Tb,r,o)}});function Et(e,t="float32"){if("complex64"===t){const t=Et(e,"float32"),n=Et(e,"float32");return Object(ne.a)(t,n)}const n=Object(x.F)(Object(x.O)(e),t);return c.a.makeTensor(n,e,t)}function At(e,t="float32"){if("complex64"===t){const t=At(e,"float32"),n=Et(e,"float32");return Object(ne.a)(t,n)}const n=Object(x.D)(Object(x.O)(e),t);return c.a.makeTensor(n,e,t)}var Rt=n(301);function _t(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Object(d.a)(e,"x","meshgrid",e instanceof Rt.a?e.dtype:"float32");if(void 0===t)return[r];let o=Object(d.a)(t,"y","meshgrid",t instanceof Rt.a?t.dtype:"float32");const c=Object(x.O)(r.shape),l=Object(x.O)(o.shape);return"xy"===n?(r=Object(R.a)(r,[1,-1]),o=Object(R.a)(o,[-1,1]),[Object(P.a)(At([l,1],r.dtype),r),Object(P.a)(o,At([1,c],o.dtype))]):(r=Object(R.a)(r,[-1,1]),o=Object(R.a)(o,[1,-1]),[Object(P.a)(r,At([1,l],r.dtype)),Object(P.a)(At([c,1],o.dtype),o)])}const Ft=Object(h.b)({minimum_:function(a,b){let e=Object(d.a)(a,"a","minimum"),t=Object(d.a)(b,"b","minimum");[e,t]=Object(j.makeTypesMatch)(e,t),"bool"===e.dtype&&(e=Object(E.a)(e,"int32"),t=Object(E.a)(t,"int32")),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Vb,n)}});const Dt=Object(h.b)({mirrorPad_:function(e,t,n){x.b("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Object(d.a)(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");x.b(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const o="reflect"===n?1:0;for(let i=0;i<r.rank;i++)x.b(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),x.b(t[i][0]>=0&&t[i][0]<=r.shape[i]-o&&t[i][1]>=0&&t[i][1]<=r.shape[i]-o,(()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-o} or less than 0 for input of shape ${r.shape}`));const h={paddings:t,mode:n},f={x:r};return c.a.runKernel(l.Wb,f,h)}});const Mt=Object(h.b)({mod_:function(a,b){let e=Object(d.a)(a,"a","mod"),t=Object(d.a)(b,"b","mod");[e,t]=Object(j.makeTypesMatch)(e,t);const n={a:e,b:t};return c.a.runKernel(l.Xb,n)}});const Pt=Object(h.b)({moments_:function(e,t=null,n=!1){e=Object(d.a)(e,"x","moments");const r=Object(x.I)(t,e.shape),o=$t(e,r,n);let c=o.shape;n||(c=Object(Ae.e)(o.shape,r));const l=Object(Pe.a)(Object(sub.a)(Object(E.a)(e,"float32"),Object(R.a)(o,c)));return{mean:o,variance:$t(l,r,n)}}});const Lt=Object(h.b)({multiRNNCell_:function(e,data,t,n){const r=Object(d.a)(data,"data","multiRNNCell"),o=Object(d.b)(t,"c","multiRNNCell"),c=Object(d.b)(n,"h","multiRNNCell");let input=r;const l=[];for(let i=0;i<e.length;i++){const output=e[i](input,o[i],c[i]);l.push(output[0]),l.push(output[1]),input=output[1]}const h=[],f=[];for(let i=0;i<l.length;i+=2)h.push(l[i]),f.push(l[i+1]);return[h,f]}});const Bt=Object(h.b)({multinomial_:function(e,t,n,r=!1){const o=Object(d.a)(e,"logits","multinomial"),h=o.size,f=o.rank;if(h<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${h}.`);if(f>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${f}`);n=n||Math.random();const m={logits:1===f?Object(R.a)(o,[1,-1]):o},y={numSamples:t,seed:n,normalized:r},x=c.a.runKernel(l.Yb,m,y);return 1===f?Object(R.a)(x,[x.size]):x}});const zt=Object(h.b)({notEqual_:function(a,b){let e=Object(d.a)(a,"a","notEqual","string_or_numeric"),t=Object(d.a)(b,"b","notEqual","string_or_numeric");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.ec,n)}});var Vt=n(364);const Wt=Object(h.b)({onesLike_:function(e){const t={x:Object(d.a)(e,"x","onesLike")};return c.a.runKernel(l.gc,t)}});const Ut=Object(h.b)({outerProduct_:function(e,t){const n=Object(d.a)(e,"v1","outerProduct"),r=Object(d.a)(t,"v2","outerProduct");x.b(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const o=Object(R.a)(n,[-1,1]),c=Object(R.a)(r,[1,-1]);return Object(P.a)(o,c)}});const Gt=Object(h.b)({pad_:function(e,t,n=0){const r=Object(d.a)(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},h={x:r};return c.a.runKernel(l.ic,h,o)}});const Ht=Object(h.b)({pad1d_:function(e,t,n=0){return Object(x.b)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Gt(e,[t],n)}});const qt=Object(h.b)({pad2d_:function(e,t,n=0){return Object(x.b)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gt(e,t,n)}});const Kt=Object(h.b)({pad3d_:function(e,t,n=0){return Object(x.b)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gt(e,t,n)}});const Xt=Object(h.b)({pad4d_:function(e,t,n=0){return Object(x.b)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gt(e,t,n)}});const Yt=Object(h.b)({spaceToBatchND_:function(e,t,n){const r=Object(d.a)(e,"x","spaceToBatchND");x.b(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),x.b(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),x.b(r.shape.reduce(((a,b,i)=>i>0&&i<=t.length?a&&(b+n[i-1][0]+n[i-1][1])%t[i-1]==0:a),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const o={x:r},h={blockShape:t,paddings:n};return c.a.runKernel(l.Oc,o,h)}});const Zt=Object(h.b)({pool_:function(input,e,t,n,r,o,c){null==r&&(r=[1,1]),null==o&&(o=1),0===n&&(n="valid");const l=Object(d.a)(input,"x","maxPool");let h=l,f=!1;3===l.rank&&(f=!0,h=Object(R.a)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),x.b(A.i(o,r),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`));const m=A.f(h.shape,e,o,r,n),y=[m.dilationHeight,m.dilationWidth];let v;v="same"===n?function(e,t){const n=e.map(((s,i)=>s+(s-1)*(t[i]-1))).map((s=>s-1)),r=n.map((s=>Math.floor(s/2))),o=n.map(((s,i)=>s-r[i]));return n.map(((e,i)=>[r[i],o[i]]))}([m.filterHeight,m.filterWidth],y):[[0,0],[0,0]];const O=1===y[0]&&1===y[1],[k,w]=function(e,t,n){const r=n.map((b=>b[0])),o=n.map((b=>b[1])),c=e.concat(r,o),l=t.map(((b,i)=>(b-c[i]%b)%b)),d=o.map(((s,i)=>s+l[i])),h=t.map(((e,i)=>[r[i],d[i]])),f=t.map(((e,i)=>[0,l[i]]));return[h,f]}([m.inHeight,m.inWidth],y,v),I=O?n:"valid",S=O?h:Yt(h,y,k),N=("avg"===t?()=>_(S,e,o,I,c):()=>Nt(S,e,o,I,c))(),T=O?N:U(N,y,w);return f?Object(R.a)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}});var Qt=n(365),Jt=n(359);const en=Object(h.b)({prod_:function(e,t=null,n=!1){let r=Object(d.a)(e,"x","prod");"bool"===r.dtype&&(r=Object(E.a)(r,"int32"));const o={x:r},h={axis:t,keepDims:n};return c.a.runKernel(l.mc,o,h)}});const tn=Object(h.b)({raggedTensorToTensor_:function(e,t,n,r,o){const h=Object(d.a)(e,"shape","raggedTensorToTensor","int32"),f=Object(d.a)(t,"values","raggedTensorToTensor"),m={shape:h,values:f,defaultValue:Object(d.a)(n,"defaultValue","raggedTensorToTensor",f.dtype),rowPartitionTensors:r.map(((e,i)=>Object(d.a)(e,`tensors${i}`,"raggedTensorToTensor","int32")))},y={rowPartitionTypes:o};return c.a.runKernel(l.nc,m,y)}});const nn=Object(h.b)({rand_:function(e,t,n){const r=Object(x.O)(e);let o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);o=new Uint8Array(r)}for(let i=0;i<r;i++)o[i]=t();return c.a.makeTensor(o,e,n)}});var rn=n(407);n(366);class an{constructor(e,t,n,r,o){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const c=o||Math.random();this.random=rn.alea(c.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,o,s;do{r=2*this.random()-1,o=2*this.random()-1,s=r*r+o*o}while(s>=1||0===s);const c=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*c,t=this.mean+this.stdDev*o*c,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class sn{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const o=r||Math.random();this.randu=rn.alea(o.toString()),this.randn=new an(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,u,o;for(;;){do{r=this.randn.nextValue(),o=1+this.c*r}while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),u=this.randu(),u<t||Math.log(u)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class on{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=rn.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const un=Object(h.b)({randomGamma_:function(e,t,n=1,r="float32",o){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const c=new sn(t,n,r,o),l=Object(J.a)(e,r);for(let i=0;i<l.values.length;i++)l.values[i]=c.nextValue();return l.toTensor()}});const cn=Object(h.b)({randomNormal_:function(e,t=0,n=1,r,o){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const c=new an(t,n,r,!1,o),l=Object(J.a)(e,r);for(let i=0;i<l.values.length;i++)l.values[i]=c.nextValue();return l.toTensor()}});const ln=Object(h.b)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return cn(e,0,1,t,n)}});const dn=Object(h.b)({randomUniform_:function(e,t=0,n=1,r="float32",o){const c=Object(J.a)(e,r),l=new on(t,n,null,o);for(let i=0;i<c.values.length;i++)c.values[i]=l.nextValue();return c.toTensor()}});function pn(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:e,stop:t,step:n,dtype:r};return c.a.runKernel(l.oc,{},o)}var hn=n(341);const fn=Object(h.b)({reciprocal_:function(e){const t={x:Object(d.a)(e,"x","reciprocal")};return c.a.runKernel(l.rc,t)}});var mn=n(342),bn=n(367);const gn=Object(h.b)({reverse_:function(e,t){const n={x:Object(d.a)(e,"x","reverse")},r={dims:t};return c.a.runKernel(l.zc,n,r)}});const yn=Object(h.b)({reverse1d_:function(e){const t=Object(d.a)(e,"x","reverse");return x.b(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),gn(t,0)}});const xn=Object(h.b)({reverse2d_:function(e,t){const n=Object(d.a)(e,"x","reverse");return x.b(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),gn(n,t)}});const vn=Object(h.b)({reverse3d_:function(e,t){const n=Object(d.a)(e,"x","reverse");return x.b(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),gn(n,t)}});const On=Object(h.b)({reverse4d_:function(e,t){const n=Object(d.a)(e,"x","reverse");return x.b(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),gn(n,t)}});const kn=Object(h.b)({round_:function(e){const t={x:Object(d.a)(e,"x","round")};return c.a.runKernel(l.Bc,t)}});const wn=Object(h.b)({rsqrt_:function(e){const t={x:Object(d.a)(e,"x","rsqrt","float32")};return c.a.runKernel(l.Cc,t)}});const In=Object(h.b)({selu_:function(e){const t={x:Object(d.a)(e,"x","selu")};return c.a.runKernel(l.Gc,t)}});const Sn=Object(h.b)({separableConv2d_:function(e,t,n,r,o,c=[1,1],l="NHWC"){const h=Object(d.a)(e,"x","separableConv2d"),f=Object(d.a)(t,"depthwiseFilter","separableConv2d"),m=Object(d.a)(n,"pointwiseFilter","separableConv2d");let y=h,v=!1;if(3===h.rank&&(v=!0,y=Object(R.a)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===l)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");x.b(4===y.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${y.rank}.`)),x.b(4===f.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${f.rank}.`)),x.b(4===m.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${f.rank}.`)),x.b(1===m.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${m.shape[0]}.`)),x.b(1===m.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${m.shape[1]}.`));const O=f.shape[2],k=f.shape[3];x.b(m.shape[2]===O*k,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${O*k}, but got ${m.shape[2]}.`));const w=ve(y,f,r,o,l,c),I=ie(w,m,1,"valid",l);return v?Object(R.a)(I,[I.shape[1],I.shape[2],I.shape[3]]):I}});const Nn=async function(e,t){const n=Object(d.a)(e,"x","setdiff1d"),r=Object(d.a)(t,"y","setdiff1d");x.b(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),x.b(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),x.b(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const o=await n.data(),c=await r.data(),l=new Set(c);let h=0;for(let i=0;i<o.length;i++)l.has(o[i])||h++;const f=new Rt.b([h],n.dtype),m=new Rt.b([h],"int32");for(let i=0,p=0;i<o.length;i++)l.has(o[i])||(f.values[p]=o[i],m.values[p]=i,p++);return[f.toTensor(),m.toTensor()]};const Tn=Object(h.b)({sign_:function(e){const t={x:Object(d.a)(e,"x","sign")};return c.a.runKernel(l.Ic,t)}});const jn=Object(h.b)({sin_:function(e){const t={x:Object(d.a)(e,"x","sin","float32")};return c.a.runKernel(l.Jc,t)}});const Cn=Object(h.b)({sinh_:function(e){const t={x:Object(d.a)(e,"x","sinh")};return c.a.runKernel(l.Kc,t)}});const $n=Object(h.b)({slice1d_:function(e,t,n){const r=Object(d.a)(e,"x","slice1d");return x.b(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),z(r,[t],[n])}});const En=Object(h.b)({slice2d_:function(e,t,n){const r=Object(d.a)(e,"x","slice2d");return x.b(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),z(r,t,n)}});const An=Object(h.b)({slice3d_:function(e,t,n){const r=Object(d.a)(e,"x","slice3d");return x.b(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),z(r,t,n)}});const Rn=Object(h.b)({slice4d_:function(e,t,n){const r=Object(d.a)(e,"x","slice4d");return x.b(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),z(r,t,n)}});const _n=Object(h.b)({softmax_:function(e,t=-1){const n=Object(d.a)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},o={dim:t};return c.a.runKernel(l.Mc,r,o)}});const Fn=Object(h.b)({fft_:function(input){Object(x.b)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${input.dtype}.`));const e={input:input};return c.a.runKernel(l.fb,e)}});const Dn=Object(h.b)({ifft_:function(input){Object(x.b)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${input.dtype}.`));const e={input:input};return c.a.runKernel(l.sb,e)}});const Mn=Object(h.b)({irfft_:function(input){const e=input.shape[input.shape.length-1],t=input.size/e;let n;if(e<=2){const r=Object(R.a)(input,[t,e]);n=Dn(r)}else{const r=[t,2*(e-1)],o=Object(R.a)(Object(hn.a)(input),[t,e]),c=Object(R.a)(Object(et.a)(input),[t,e]),l=gn(z(o,[0,1],[t,e-2]),1),d=Object(L.a)(gn(z(c,[0,1],[t,e-2]),1),Object(De.a)(-1)),h=M([o,l],1),i=M([c,d],1),f=Object(R.a)(Object(ne.a)(h,i),[r[0],r[1]]);n=Dn(f)}if(n=Object(hn.a)(n),3===input.rank&&0!==input.shape[0]){const e=n,t=input.shape[0];n=Object(R.a)(n,[t,n.shape[0]/t,n.shape[1]]),e.dispose()}return n}});const Pn=Object(h.b)({split_:function(e,t,n=0){const r={x:Object(d.a)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return c.a.runKernel(l.Uc,r,o)}});const Ln=Object(h.b)({rfft_:function(input,e){Object(x.b)("float32"===input.dtype,(()=>`The dtype for rfft() must be real value but got ${input.dtype}`));let t=input.shape[input.shape.length-1];const n=input.size/t;let r;if(null!=e&&e<t){const n=input.shape.map((e=>0)),o=input.shape.map((e=>e));o[input.shape.length-1]=e,r=z(input,n,o),t=e}else if(null!=e&&e>t){const n=input.shape.map((e=>e));n[input.shape.length-1]=e-t,r=M([input,Et(n)],input.shape.length-1),t=e}else r=input;const o=Object(Ne.a)(r),c=Object(R.a)(Object(ne.a)(r,o),[n,t]),l=Fn(c),d=Math.floor(t/2)+1,h=Object(hn.a)(l),f=Object(et.a)(l),m=Pn(h,[d,t-d],h.shape.length-1),y=Pn(f,[d,t-d],f.shape.length-1),v=r.shape.slice();return v[r.shape.length-1]=d,Object(R.a)(Object(ne.a)(m[0],y[0]),v)}});const Bn=Object(h.b)({squaredDifference_:function(a,b){let e=Object(d.a)(a,"a","squaredDifference"),t=Object(d.a)(b,"b","squaredDifference");[e,t]=Object(j.makeTypesMatch)(e,t),Object(we.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return c.a.runKernel(l.Xc,n,{})}});const zn=Object(h.b)({squeeze_:function(e,t){const n=Object(d.a)(e,"x","squeeze","string_or_numeric");return Object(R.a)(n,Object(x.Q)(n.shape,t).newShape)}});const Vn=Object(h.b)({stack_:function(e,t=0){const n=Object(d.b)(e,"tensors","stack","string_or_numeric");x.b(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&x.b(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,o={axis:t};return c.a.runKernel(l.hc,r,o)}});var Wn=n(368);const Un=Object(h.b)({stridedSlice_:function(e,t,n,r,o=0,h=0,f=0,m=0,y=0){const x={x:Object(d.a)(e,"x","stridedSlice","string_or_numeric")},v={begin:t,end:n,strides:r,beginMask:o,endMask:h,ellipsisMask:f,newAxisMask:m,shrinkAxisMask:y};return c.a.runKernel(l.Zc,x,v)}});const Gn=Object(h.b)({tan_:function(e){const t={x:Object(d.a)(e,"x","tan","float32")};return c.a.runKernel(l.fd,t)}});var Hn=n(336),qn=n(314);function Kn(e,t){Object(x.d)(e);const n=Object(d.c)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(qn.a)(e,null,n,t)}function Xn(e,t,n){if(Object(x.d)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Object(d.c)(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(qn.a)(e,t,r,n)}var Yn=n(369);function Zn(e,t,n){if(Object(x.d)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Object(d.c)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(qn.a)(e,t,r,n)}function Qn(e,t,n){if(Object(x.d)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Object(d.c)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(qn.a)(e,t,r,n)}function Jn(e,t,n){if(Object(x.d)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Object(d.c)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Object(qn.a)(e,t,r,n)}const er=Object(h.b)({topk_:function(e,t=1,n=!0){const r=Object(d.a)(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);const h={x:r},f={k:t,sorted:n},[m,y]=c.a.runKernel(l.id,h,f);return{values:m,indices:y}}});const nr=Object(h.b)({truncatedNormal_:function(e,t=0,n=1,r,o){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const c=new an(t,n,r,!0,o),l=Object(J.a)(e,r);for(let i=0;i<l.values.length;i++)l.values[i]=c.nextValue();return l.toTensor()}});const rr=Object(h.b)({unique_:function(e,t=0){const n=Object(d.a)(e,"x","unique","string_or_numeric");Object(x.b)(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},o={axis:t},[h,f]=c.a.runKernel(l.ld,r,o);return{values:h,indices:f}}});const ar=Object(h.b)({unsortedSegmentSum_:function(e,t,n){const r=Object(d.a)(e,"x","unsortedSegmentSum"),o=Object(d.a)(t,"segmentIds","unsortedSegmentSum","int32");Object(x.b)(Object(x.v)(n),(()=>"numSegments must be of dtype int"));const h={x:r,segmentIds:o},f={numSegments:n};return c.a.runKernel(l.nd,h,f)}});const sr=Object(h.b)({unstack_:function(e,t=0){const n=Object(d.a)(e,"x","unstack","string_or_numeric");x.b(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},o={axis:t};return c.a.runKernel(l.md,r,o)}});function or(e,t){return It(e,t,"right")}function ir(e,t=!0,n,r){return c.a.makeVariable(e,t,n,r)}var ur=n(370);const cr=async function(e){const t=Object(d.a)(e,"condition","whereAsync","bool"),n=await t.data(),r=Object(ur.a)(t.shape,n);return e!==t&&t.dispose(),r};const lr=async function(e,mask,t){const n=Object(d.a)(e,"tensor","boolMask"),r=Object(d.a)(mask,"mask","boolMask","bool"),o=null==t?0:t,c=r.rank,l=n.shape;x.b(c>0,(()=>"mask cannot be scalar")),x.e(l.slice(o,o+c),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let h=1;for(let i=o;i<o+c;i++)h*=l[i];const f=l.slice(0,o).concat([h],l.slice(o+c)),m=Object(R.a)(n,f),y=Object(R.a)(r,[-1]),v=await cr(y),O=zn(v,[1]),k=Ze(m,O,o);return e!==n&&n.dispose(),mask!==r&&r.dispose(),O.dispose(),m.dispose(),y.dispose(),v.dispose(),k};var dr=n(350);const pr=Object(h.b)({movingAverage_:function(e,t,n,r,o=!0){const c=Object(d.a)(e,"v","movingAverage"),l=Object(d.a)(t,"x","movingAverage"),h=Object(d.a)(n,"decay","movingAverage");Object(j.assertTypesMatch)(c,l),x.b(x.a(c.shape,l.shape),(()=>"Shape mismatch in v and x"));const f=Object(De.a)(1),m=Object(sub.a)(f,h);let v=Object(L.a)(Object(sub.a)(l,c),m);if(o){x.b(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=Object(d.a)(r,"step","movingAverage");v=Object(div.a)(v,Object(sub.a)(f,Object(Fe.a)(h,e)))}return Object(y.a)(c,v)}});var fr=n(343);const mr=Object(h.b)({scatterND_:function(e,t,n){const r=Object(d.a)(e,"indices","scatterND","int32"),o=Object(d.a)(t,"updates","scatterND");fr.validateInput(o,r,n);const h={indices:r,updates:o},f={shape:n};return c.a.runKernel(l.Dc,h,f)}});const gr=Object(h.b)({sparseToDense_:function(e,t,n,r=0){const o=Object(d.a)(e,"sparseIndices","sparseToDense","int32"),h=Object(d.a)(t,"sparseValues","sparseToDense","string_or_numeric"),f=Object(d.a)(r,"defaultValue","sparseToDense",h.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const o=e.rank>0?e.shape[0]:1,c=e.rank>1?e.shape[1]:1;if(n.length!==c)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${c}.`);const l=t.size;if(0!==t.rank&&(1!==t.rank||l!==o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,h,n,f);const m={sparseIndices:o,sparseValues:h,defaultValue:f},y={outputShape:n};return c.a.runKernel(l.Tc,m,y)}});const yr=Object(h.b)({gatherND_:function(e,t){const n=Object(d.a)(t,"indices","gatherND","int32"),r={params:Object(d.a)(e,"x","gatherND","string_or_numeric"),indices:n};return c.a.runKernel(l.ob,r)}});const xr=Object(h.b)({dropout_:function(e,t,n,r){const o=Object(d.a)(e,"x","dropout");if(x.b("float32"===o.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`)),x.b(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Rt.a?o.clone():o;const c=function(e,t){if(null==t)return e.shape.slice();if(x.a(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let i=0;i<e.shape.length;i++)null==t[i]&&null!=e.shape[i]?n.push(e.shape[i]):n.push(t[i]);return n}return t}(o,n),l=1-t,h=Object(div.a)(Xe(Object(y.a)(dn(c,0,1,"float32",r),l)),l);return Object(L.a)(o,h)}});function vr(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Or(e,a,b){const t=1-e%2,n=new Float32Array(e);for(let i=0;i<e;++i){const r=2*Math.PI*i/(e+t-1);n[i]=a-b*Math.cos(r)}return Kn(n,"float32")}const kr=async function(e,t,n=1){const r=Object(d.a)(e,"predictions","inTopK"),o=Object(d.a)(t,"targets","inTopK");Object(x.b)(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Object(x.b)(r.rank-1===o.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`)),Object(x.e)(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const c=r.shape[r.shape.length-1];Object(x.b)(n>0&&n<=c,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${c}), but got ${n}`));const l=await r.data(),h=await o.data(),[f,m]=[l.length/c,c],y=Object(x.o)("bool",f);for(let b=0;b<f;b++){const e=b*m,t=l.subarray(e,e+m),r=[];for(let i=0;i<t.length;i++)r.push({value:t[i],index:i});r.sort(((a,b)=>b.value-a.value)),y[b]=0;for(let i=0;i<n;i++)if(r[i].index===h[b]){y[b]=1;break}}return e!==r&&r.dispose(),t!==o&&o.dispose(),Object(Hn.a)(y,o.shape,"bool")};const wr=Object(h.b)({conv2DBackpropFilter_:function(e,t,n,r,o,d="NHWC",h){let f=e;3===e.rank&&(f=Object(R.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let m=t;3===m.rank&&(m=Object(R.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),x.b(4===f.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${f.shape}.`)),x.b(4===m.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${m.shape}.`)),x.b(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const y="NHWC"===d?f.shape[3]:f.shape[1],v="NHWC"===d?m.shape[3]:m.shape[1];x.b(y===n[2],(()=>`Error in conv2dDerFilter: depth of input ${y}) must match input depth in filter (${n[2]}.`)),x.b(v===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${v}) must match output depth for filter (${n[3]}).`)),A.a("conv2dDerFilter",o,h);const O={x:f,dy:m},k={strides:r,pad:o,dataFormat:d,dimRoundingMode:h,filterShape:n};return c.a.runKernel(l.E,O,k)}});var Ir=n(323);const Sr=Object(h.b)({fusedConv2d_:function({x:e,filter:filter,strides:t,pad:n,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:h,bias:f,activation:m="linear",preluActivationWeights:v,leakyreluAlpha:O}){if(m=m||"linear",!1===Object(Ir.d)(c.a.state.gradientDepth,m)){x.b("NHWC"===r,(()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let c=ie(e,filter,t,n,r,o,h);return null!=f&&(c=Object(y.a)(c,f)),Object(Ir.a)(c,m,v,O)}const k=Object(d.a)(e,"x","conv2d","float32"),w=Object(d.a)(filter,"filter","conv2d","float32");let I=k,S=!1;3===k.rank&&(S=!0,I=Object(R.a)(k,[1,k.shape[0],k.shape[1],k.shape[2]])),x.b(4===I.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${I.rank}.`)),x.b(4===w.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${w.rank}.`)),A.a("fused conv2d",n,h);const N="NHWC"===r?I.shape[3]:I.shape[1];x.b(w.shape[2]===N,(()=>`Error in conv2d: depth of input (${N}) must match input depth for filter ${w.shape[2]}.`)),x.b(A.i(t,o),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`));const T=A.b(I.shape,w.shape,t,o,n,h);let C,$;if(null!=f&&(C=Object(d.a)(f,"bias","fused conv2d"),[C]=Object(j.makeTypesMatch)(C,k),"NHWC"===r?we.assertAndGetBroadcastShape(T.outShape,C.shape):(x.b(C.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${C.shape.length}.`)),x.b(0===C.shape.length||C.shape[0]===T.outChannels||1===C.shape[0],(()=>`Error in fused conv2d: bias shape (${C.shape}) is not compatible with the number of output channels (${T.outChannels})`)))),null!=v){const e=v.shape;if(x.b(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)x.b(1===e[0]||e[0]===T.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${T.outChannels}).`));else if(3===e.length)try{we.assertAndGetBroadcastShape(e,T.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${T.outShape}).`;throw Error(n)}$=Object(d.a)(v,"prelu weights","fused conv2d")}const E=(e,c)=>{x.b("NHWC"===r,(()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`));const[l,d,h,f]=c,y=Object(Ir.c)(e,h,m);x.b(A.j(o),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`));const v=[ce(d.shape,y,l,t,n),wr(d,y,l.shape,t,n)];if(null!=f){const e=Object(Ir.b)(f,y);v.push(e)}return v},_={x:I,filter:w,bias:C,preluActivationWeights:$},F={strides:t,pad:n,dataFormat:r,dilations:o,dimRoundingMode:h,activation:m,leakyreluAlpha:O};if(null==f){const e=Object(ht.a)(((e,filter,t)=>{let n=c.a.runKernel(l.mb,_,F);return t([filter,e,n]),S&&(n=Object(R.a)(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:E}}));return e(I,w)}{const e=Object(ht.a)(((e,filter,t,n)=>{let r=c.a.runKernel(l.mb,_,F);return n([filter,e,r,t]),S&&(r=Object(R.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:E}}));return e(I,w,C)}}});const Nr=Object(h.b)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,o,d=[1,1],h){let f=e;3===e.rank&&(f=Object(R.a)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let m=t;3===m.rank&&(m=Object(R.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const y={x:f,dy:m},x={strides:r,pad:o,dimRoundingMode:h,dilations:d,filterShape:n};return c.a.runKernel(l.R,y,x)}});const Tr=Object(h.b)({depthwiseConv2dNativeBackpropInput_:function(e,t,filter,n,r,o=[1,1],d){let h=t,f=!1;3===t.rank&&(f=!0,h=Object(R.a)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const m={dy:h,filter:filter},y={strides:n,pad:r,dimRoundingMode:d,dilations:o,inputShape:e},x=c.a.runKernel(l.S,m,y);return f?Object(R.a)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const jr=Object(h.b)({fusedDepthwiseConv2d_:function({x:e,filter:filter,strides:t,pad:n,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:h,bias:f,activation:m="linear",preluActivationWeights:v,leakyreluAlpha:O}){if(!1===Object(Ir.d)(c.a.state.gradientDepth,m)){let c=ve(e,filter,t,n,r,o,h);return null!=f&&(c=Object(y.a)(c,f)),Object(Ir.a)(c,m,v,O)}const k=Object(d.a)(e,"x","depthwiseConv2d","float32"),w=Object(d.a)(filter,"filter","depthwiseConv2d","float32");let I=k,S=!1;3===k.rank&&(S=!0,I=Object(R.a)(k,[1,k.shape[0],k.shape[1],k.shape[2]])),x.b(4===I.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${I.rank}.`)),x.b(4===w.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${w.rank}.`)),x.b(I.shape[3]===w.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${I.shape[3]}) must match the inChannels dimension in filter ${w.shape[2]}.`)),null==o&&(o=[1,1]),x.b(A.i(t,o),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`)),A.a("fused depthwiseConv2d",n,h);const N=A.b(I.shape,w.shape,t,o,n,h,!0);let T,C;null!=f&&(T=Object(d.a)(f,"bias","fused conv2d"),[T]=Object(j.makeTypesMatch)(T,k),we.assertAndGetBroadcastShape(N.outShape,T.shape)),null!=v&&(C=Object(d.a)(v,"prelu weights","fused depthwiseConv2d"));const $=(e,r)=>{x.b(A.j(o),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[c,l,d,f]=r,y=Object(Ir.c)(e,d,m),v=Tr(l.shape,y,c,t,n,o,h),O=Nr(l,y,c.shape,t,n,o,h);if(null!=f){return[v,O,Object(Ir.b)(T,y)]}return[v,O]},E={x:I,filter:w,bias:T,preluActivationWeights:C},_={strides:t,pad:n,dataFormat:r,dilations:o,dimRoundingMode:h,activation:m,leakyreluAlpha:O};if(null==f){const e=Object(ht.a)(((e,filter,t)=>{let n=c.a.runKernel(l.nb,E,_);return t([filter,e,n]),S&&(n=Object(R.a)(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:$}}));return e(I,w)}{const e=Object(ht.a)(((e,filter,t,n)=>{let r=c.a.runKernel(l.nb,E,_);return n([filter,e,r,t]),S&&(r=Object(R.a)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:$}}));return e(I,w,T)}}});const Cr=Object(h.b)({fusedMatMul_:function({a:a,b:b,transposeA:e=!1,transposeB:t=!1,bias:n,activation:r="linear",preluActivationWeights:o,leakyreluAlpha:h=.2}){if(!1===Object(Ir.d)(c.a.state.gradientDepth,r)){let c=Object(P.a)(a,b,e,t);return null!=n&&(c=Object(y.a)(c,n)),Object(Ir.a)(c,r,o,h)}let f=Object(d.a)(a,"a","fused matMul"),m=Object(d.a)(b,"b","fused matMul");[f,m]=Object(j.makeTypesMatch)(f,m);const v=e?f.shape[f.rank-2]:f.shape[f.rank-1],O=t?m.shape[m.rank-1]:m.shape[m.rank-2],k=e?f.shape[f.rank-1]:f.shape[f.rank-2],w=t?m.shape[m.rank-2]:m.shape[m.rank-1],I=f.shape.slice(0,-2),S=m.shape.slice(0,-2),N=x.O(I),T=x.O(S);x.b(v===O,(()=>`Error in fused matMul: inner shapes (${v}) and (${O}) of Tensors with shapes ${f.shape} and ${m.shape} and transposeA=${e} and transposeB=${t} must match.`));const C=we.assertAndGetBroadcastShape(f.shape.slice(0,-2),m.shape.slice(0,-2)).concat([k,w]),$=e?Object(R.a)(f,[N,v,k]):Object(R.a)(f,[N,k,v]),E=t?Object(R.a)(m,[T,w,O]):Object(R.a)(m,[T,O,w]);let A,_;null!=n&&(A=Object(d.a)(n,"bias","fused matMul"),[A]=Object(j.makeTypesMatch)(A,f),we.assertAndGetBroadcastShape(C,A.shape)),null!=o&&(_=Object(d.a)(o,"prelu weights","fused matMul"));const F=(o,c)=>{const[l,d,h,f]=c,m=Object(Ir.c)(Object(R.a)(o,h.shape),h,r);let y,x;if(e||t?!e&&t?(y=Object(P.a)(m,d,!1,!1),x=Object(P.a)(m,l,!0,!1)):e&&!t?(y=Object(P.a)(d,m,!1,!0),x=Object(P.a)(l,m,!1,!1)):(y=Object(P.a)(d,m,!0,!0),x=Object(P.a)(m,l,!0,!0)):(y=Object(P.a)(m,d,!1,!0),x=Object(P.a)(l,m,!0,!1)),null!=n){return[y,x,Object(Ir.b)(f,m)]}return[y,x]},D={a:$,b:E,bias:A,preluActivationWeights:_},M={transposeA:e,transposeB:t,activation:r,leakyreluAlpha:h};if(null==n){const e=Object(ht.a)(((e,t,n)=>{const r=c.a.runKernel(l.qd,D,M);return n([e,t,r]),{value:Object(R.a)(r,C),gradFunc:F}}));return e($,E)}{const e=Object(ht.a)(((e,t,n,r)=>{const o=c.a.runKernel(l.qd,D,M);return r([e,t,o,n]),{value:Object(R.a)(o,C),gradFunc:F}}));return e($,E,A)}}});const $r=Object(h.b)({hammingWindow_:function(e){return Or(e,.54,.46)}});const Er=Object(h.b)({hannWindow_:function(e){return Or(e,.5,.5)}});const Ar=Object(h.b)({frame_:function(e,t,n,r=!1,o=0){let c=0;const output=[];for(;c+t<=e.size;)output.push(z(e,c,t)),c+=n;if(r)for(;c<e.size;){const r=c+t-e.size,l=M([z(e,c,t-r),Object(Ke.a)([r],o)]);output.push(l),c+=n}return 0===output.length?Xn([],[0,t]):Object(R.a)(M(output),[output.length,t])}});const Rr=Object(h.b)({stft_:function(e,t,n,r,o=Er){null==r&&(r=vr(t));const c=Ar(e,t,n),l=Object(L.a)(c,o(t));return Ln(l,r)}});const _r=Object(h.b)({cropAndResize_:function(image,e,t,n,r="bilinear",o=0){const h=Object(d.a)(image,"image","cropAndResize"),f=Object(d.a)(e,"boxes","cropAndResize","float32"),m=Object(d.a)(t,"boxInd","cropAndResize","int32"),y=f.shape[0];x.b(4===h.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${h.rank}.`)),x.b(2===f.rank&&4===f.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${y},4] but had shape ${f.shape}.`)),x.b(1===m.rank&&m.shape[0]===y,(()=>`Error in cropAndResize: boxInd must be have size [${y}] but had shape ${f.shape}.`)),x.b(2===n.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`)),x.b(n[0]>=1&&n[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${n}`)),x.b("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const v={image:h,boxes:f,boxInd:m},O={method:r,extrapolationValue:o,cropSize:n};return c.a.runKernel(l.L,v,O)}});const Fr=Object(h.b)({flipLeftRight_:function(image){const e=Object(d.a)(image,"image","flipLeftRight","float32");x.b(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const t={image:e};return c.a.runKernel(l.hb,t,{})}});const Dr=Object(h.b)({grayscaleToRGB_:function(image){const e=Object(d.a)(image,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];x.b(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),x.b(1===n,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`));const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,He(e,r)}});const Mr=Object(h.b)({rotateWithOffset_:function(image,e,t=0,n=.5){const r=Object(d.a)(image,"image","rotateWithOffset","float32");x.b(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const o={image:r},h={radians:e,fillValue:t,center:n};return c.a.runKernel(l.Ac,o,h)}});function Pr(e,t,n,r,o,c){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==c&&(c=0);const l=e.shape[0];return n=Math.min(n,l),x.b(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),x.b(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),x.b(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),x.b(1===t.rank,(()=>"scores must be a 1D tensor")),x.b(t.shape[0]===l,(()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${t.shape[0]}`)),x.b(0<=c&&c<=1,(()=>`softNmsSigma must be in [0, 1], but was '${c}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:c}}const Lr=Object(h.b)({nonMaxSuppression_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY){const h=Object(d.a)(e,"boxes","nonMaxSuppression","float32"),f=Object(d.a)(t,"scores","nonMaxSuppression","float32"),m=Pr(h,f,n,r,o),y={maxOutputSize:n=m.maxOutputSize,iouThreshold:r=m.iouThreshold,scoreThreshold:o=m.scoreThreshold};return c.a.runKernel(l.bc,{boxes:h,scores:f},y)}});var Br=n(327);const zr=async function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(d.a)(e,"boxes","nonMaxSuppressionAsync"),l=Object(d.a)(t,"scores","nonMaxSuppressionAsync"),h=Pr(c,l,n,r,o);n=h.maxOutputSize,r=h.iouThreshold,o=h.scoreThreshold;const f=await Promise.all([c.data(),l.data()]),m=f[0],y=f[1],{selectedIndices:x}=Object(Br.a)(m,y,n,r,o);return c!==e&&c.dispose(),l!==t&&l.dispose(),Kn(x,"int32")};const Vr=Object(h.b)({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,h=0){const f=Object(d.a)(e,"boxes","nonMaxSuppression"),m=Object(d.a)(t,"scores","nonMaxSuppression"),y=Pr(f,m,n,r,o,h),x={boxes:f,scores:m},v={maxOutputSize:n=y.maxOutputSize,iouThreshold:r=y.iouThreshold,scoreThreshold:o=y.scoreThreshold,softNmsSigma:h=y.softNmsSigma},O=c.a.runKernel(l.dc,x,v);return{selectedIndices:O[0],selectedScores:O[1]}}});const Wr=async function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const l=Object(d.a)(e,"boxes","nonMaxSuppressionAsync"),h=Object(d.a)(t,"scores","nonMaxSuppressionAsync"),f=Pr(l,h,n,r,o,c);n=f.maxOutputSize,r=f.iouThreshold,o=f.scoreThreshold,c=f.softNmsSigma;const m=await Promise.all([l.data(),h.data()]),y=m[0],x=m[1],{selectedIndices:v,selectedScores:O}=Object(Br.c)(y,x,n,r,o,c);return l!==e&&l.dispose(),h!==t&&h.dispose(),{selectedIndices:Kn(v,"int32"),selectedScores:Kn(O)}};const Ur=Object(h.b)({nonMaxSuppressionPadded_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,h=!1){const f=Object(d.a)(e,"boxes","nonMaxSuppression"),m=Object(d.a)(t,"scores","nonMaxSuppression"),y=Pr(f,m,n,r,o,null),x={boxes:f,scores:m},v={maxOutputSize:y.maxOutputSize,iouThreshold:y.iouThreshold,scoreThreshold:y.scoreThreshold,padToMaxOutputSize:h},O=c.a.runKernel(l.cc,x,v);return{selectedIndices:O[0],validOutputs:O[1]}}});const Gr=async function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const l=Object(d.a)(e,"boxes","nonMaxSuppressionAsync"),h=Object(d.a)(t,"scores","nonMaxSuppressionAsync"),f=Pr(l,h,n,r,o,null),m=f.maxOutputSize,y=f.iouThreshold,x=f.scoreThreshold,[v,O]=await Promise.all([l.data(),h.data()]),{selectedIndices:k,validOutputs:w}=Object(Br.b)(v,O,m,y,x,c);return l!==e&&l.dispose(),h!==t&&h.dispose(),{selectedIndices:Kn(k,"int32"),validOutputs:Object(De.a)(w,"int32")}};const Hr=Object(h.b)({resizeBilinear_:function(e,t,n=!1,r=!1){const o=Object(d.a)(e,"images","resizeBilinear");x.b(3===o.rank||4===o.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),x.b(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),x.b(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let h=o,f=!1;3===o.rank&&(f=!0,h=Object(R.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[]=t,m={images:h},y={alignCorners:n,halfPixelCenters:r,size:t},v=c.a.runKernel(l.vc,m,y);return f?Object(R.a)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const qr=Object(h.b)({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const o=Object(d.a)(e,"images","resizeNearestNeighbor");x.b(3===o.rank||4===o.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),x.b(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),x.b("float32"===o.dtype||"int32"===o.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),x.b(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let h=o,f=!1;3===o.rank&&(f=!0,h=Object(R.a)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[]=t,m={images:h},y={alignCorners:n,halfPixelCenters:r,size:t},v=c.a.runKernel(l.xc,m,y);return f?Object(R.a)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const Kr=Object(h.b)({threshold_:function(image,e="binary",t=!1,n=.5){const r=Object(d.a)(image,"image","threshold"),o=r.shape[0]*r.shape[1];let c,g,b,l,h=Object(L.a)(Kn([n]),255);if(x.b(3===r.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`)),x.b(3===r.shape[2]||1===r.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)),x.b("int32"===r.dtype||"float32"===r.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)),x.b("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===r.shape[2]){[c,g,b]=Pn(r,[1,1,1],-1);const e=Object(L.a)(c,.2989),t=Object(L.a)(g,.587),n=Object(L.a)(b,.114);l=Object(y.a)(Object(y.a)(e,t),n)}else l=image;if("otsu"===e){h=function(e,t){let n,r,o,c,l,d,h=Kn([-1]),f=Kn([0]),m=Kn([0]);for(let x=0;x<e.size-1;x++){n=z(e,0,x+1),r=z(e,x+1),l=Object(div.a)(Object(Le.a)(n),t),d=Object(div.a)(Object(Le.a)(r),t);const v=Object(Le.a)(Object(L.a)(n,pn(0,n.size)));o=Object(div.a)(v,Object(Le.a)(n));const O=Object(Ke.a)(r.shape,n.size),k=Object(y.a)(pn(0,r.size),O),w=Object(L.a)(r,k);c=Object(div.a)(Object(Le.a)(w),Object(Le.a)(r));const I=Object(sub.a)(o,c),S=Object(sub.a)(o,c),N=Object(L.a)(l,d);m=Object(L.a)(Object(L.a)(N,I),S);const T=Qe(m,f);f=Se(T,m,f),h=Se(T,Kn([x]),h)}return h}(Y(Object(E.a)(kn(l),"int32"),Object(Hn.a)([]),256),o)}const f=t?it(l,h):Qe(l,h);return Object(E.a)(Object(L.a)(f,255),"int32")}});const Xr=Object(h.b)({transform_:function(image,e,t="nearest",n="constant",r=0,o){const h=Object(d.a)(image,"image","transform","float32"),f=Object(d.a)(e,"transforms","transform","float32");x.b(4===h.rank,(()=>`Error in transform: image must be rank 4,but got rank ${h.rank}.`)),x.b(2===f.rank&&(f.shape[0]===h.shape[0]||1===f.shape[0])&&8===f.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),x.b(null==o||2===o.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`));const m={image:h,transforms:f},y={interpolation:t,fillMode:n,fillValue:r,outputShape:o};return c.a.runKernel(l.jd,m,y)}});const Yr=Object(h.b)({bandPart_:function(a,e,t){Object(x.b)(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),Object(x.b)(t%1==0,(()=>`bandPart(): numUpper must be an integer, got ${t}.`));const n=Object(d.a)(a,"a","bandPart");Object(x.b)(n.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`));const r=n.shape,[o,c]=n.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=c))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${c}).`);e<0&&(e=o),t<0&&(t=c);const i=Object(R.a)(pn(0,o,1,"int32"),[-1,1]),l=pn(0,c,1,"int32"),h=Object(sub.a)(i,l),f=xt(it(h,Object(De.a)(+e,"int32")),Je(h,Object(De.a)(-t,"int32"))),m=Et([o,c],n.dtype);return Object(R.a)(Vn(sr(Object(R.a)(n,[-1,o,c])).map((e=>Se(f,e,m)))),r)}});const Zr=Object(h.b)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Object(x.b)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let i=1;i<e.length;++i)Object(x.b)(e[i].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${n})`))}else t=!0,e=Pn(e,e.shape[0],0).map((e=>zn(e,[0])));Object(x.b)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let i=0;i<e.length;++i)n.push(c.a.tidy((()=>{let e=r[i];if(i>0)for(let t=0;t<i;++t){const r=Object(L.a)(Object(Le.a)(Object(L.a)(n[t],e)),n[t]);e=Object(sub.a)(e,r)}return Object(div.a)(e,ze(e,"euclidean"))})));return t?Vn(n,0):n}});var Qr=n(304);function Jr(e,t=!1){return c.a.tidy((()=>{Object(x.b)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let q=qe(n),o=Object(D.a)(e);const l=Xn([[1]],[1,1]);let d=Object(D.a)(l);const h=n>=r?r:n;for(let e=0;e<h;++e){const t=o,h=d,f=q;[d,o,q]=c.a.tidy((()=>{const t=z(o,[e,e],[n-e,1]),c=ze(t),h=z(o,[e,e],[1,1]),s=Se(Qe(h,0),Xn([[-1]]),Xn([[1]])),f=Object(sub.a)(h,Object(L.a)(s,c)),m=Object(div.a)(t,f);d=1===m.shape[0]?Object(D.a)(l):M([l,z(m,[1,0],[m.shape[0]-1,m.shape[1]])],0);const y=Object(ft.a)(Object(div.a)(Object(P.a)(s,f),c)),x=z(o,[e,0],[n-e,r]),v=Object(L.a)(y,d),O=Object(dr.a)(d);if(0===e)o=Object(sub.a)(x,Object(P.a)(v,Object(P.a)(O,x)));else{const t=Object(sub.a)(x,Object(P.a)(v,Object(P.a)(O,x)));o=M([z(o,[0,0],[e,r]),t],0)}const k=Object(dr.a)(v),w=z(q,[0,e],[n,q.shape[1]-e]);if(0===e)q=Object(sub.a)(w,Object(P.a)(Object(P.a)(w,d),k));else{const t=Object(sub.a)(w,Object(P.a)(Object(P.a)(w,d),k));q=M([z(q,[0,0],[n,e]),t],1)}return[d,o,q]})),Object(Qr.d)([t,h,f])}return!t&&n>r&&(q=z(q,[0,0],[n,r]),o=z(o,[0,0],[r,r])),[q,o]}))}const ea=Object(h.b)({qr_:function(e,t=!1){if(Object(x.b)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Jr(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=sr(Object(R.a)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),o=[],c=[];r.forEach((e=>{const[n,r]=Jr(e,t);o.push(n),c.push(r)}));return[Object(R.a)(Vn(o,0),e.shape),Object(R.a)(Vn(c,0),e.shape)]}}});var ta=n(308);const na=Object(h.b)({computeWeightedLoss_:function(e,t,n=ta.a.SUM_BY_NONZERO_WEIGHTS){const r=Object(d.a)(e,"losses","computeWeightedLoss");let o=null;null!=t&&(o=Object(d.a)(t,"weights","computeWeightedLoss"));const c=null==o?r:Object(L.a)(r,o);if(n===ta.a.NONE)return c;if(n===ta.a.SUM)return Object(Le.a)(c);if(n===ta.a.MEAN){if(null==o)return $t(c);{const e=r.size/o.size,t=Object(div.a)(Object(Le.a)(c),Object(Le.a)(o));return e>1?Object(div.a)(t,Object(De.a)(e)):t}}if(n===ta.a.SUM_BY_NONZERO_WEIGHTS){if(null==o)return Object(div.a)(Object(Le.a)(c),Object(De.a)(r.size));{const e=Object(L.a)(o,At(r.shape)),t=Object(E.a)(Object(Le.a)(zt(e,Object(De.a)(0))),"float32");return Object(div.a)(Object(Le.a)(c),t)}}throw Error(`Unknown reduction: ${n}`)}});const ra=Object(h.b)({absoluteDifference_:function(e,t,n,r=ta.a.SUM_BY_NONZERO_WEIGHTS){const c=Object(d.a)(e,"labels","absoluteDifference"),l=Object(d.a)(t,"predictions","absoluteDifference");let h=null;null!=n&&(h=Object(d.a)(n,"weights","absoluteDifference")),Object(x.e)(c.shape,l.shape,"Error in absoluteDifference: ");const f=Object(o.a)(Object(sub.a)(c,l));return na(f,h,r)}});const aa=Object(h.b)({cosineDistance_:function(e,t,n,r,o=ta.a.SUM_BY_NONZERO_WEIGHTS){const c=Object(d.a)(e,"labels","cosineDistance"),l=Object(d.a)(t,"predictions","cosineDistance");let h=null;null!=r&&(h=Object(d.a)(r,"weights","cosineDistance")),Object(x.e)(c.shape,l.shape,"Error in cosineDistance: ");const f=Object(De.a)(1),m=Object(sub.a)(f,Object(Le.a)(Object(L.a)(c,l),n,!0));return na(m,h,o)}});const sa=Object(h.b)({hingeLoss_:function(e,t,n,r=ta.a.SUM_BY_NONZERO_WEIGHTS){let o=Object(d.a)(e,"labels","hingeLoss");const c=Object(d.a)(t,"predictions","hingeLoss");let l=null;null!=n&&(l=Object(d.a)(n,"weights","hingeLoss")),Object(x.e)(o.shape,c.shape,"Error in hingeLoss: ");const h=Object(De.a)(1);o=Object(sub.a)(Object(L.a)(Object(De.a)(2),o),h);const f=Object(mn.a)(Object(sub.a)(h,Object(L.a)(o,c)));return na(f,l,r)}});const oa=Object(h.b)({huberLoss_:function(e,t,n,r=1,c=ta.a.SUM_BY_NONZERO_WEIGHTS){const l=Object(d.a)(e,"labels","huberLoss"),h=Object(d.a)(t,"predictions","huberLoss");let f=null;null!=n&&(f=Object(d.a)(n,"weights","huberLoss")),Object(x.e)(l.shape,h.shape,"Error in huberLoss: ");const m=Object(De.a)(r),v=Object(o.a)(Object(sub.a)(h,l)),O=Ft(v,m),k=Object(sub.a)(v,O),w=Object(y.a)(Object(L.a)(Object(De.a)(.5),Object(Pe.a)(O)),Object(L.a)(m,k));return na(w,f,c)}});const ia=Object(h.b)({logLoss_:function(e,t,n,r=1e-7,o=ta.a.SUM_BY_NONZERO_WEIGHTS){const c=Object(d.a)(e,"labels","logLoss"),l=Object(d.a)(t,"predictions","logLoss");let h=null;null!=n&&(h=Object(d.a)(n,"weights","logLoss")),Object(x.e)(c.shape,l.shape,"Error in logLoss: ");const f=Object(De.a)(1),m=Object(De.a)(r),v=Object(ft.a)(Object(L.a)(c,lt(Object(y.a)(l,m)))),O=Object(L.a)(Object(sub.a)(f,c),lt(Object(y.a)(Object(sub.a)(f,l),m))),k=Object(sub.a)(v,O);return na(k,h,o)}});const ua=Object(h.b)({meanSquaredError_:function(e,t,n,r=ta.a.SUM_BY_NONZERO_WEIGHTS){const o=Object(d.a)(e,"labels","meanSquaredError"),c=Object(d.a)(t,"predictions","meanSquaredError");let l=null;null!=n&&(l=Object(d.a)(n,"weights","meanSquaredError")),Object(x.e)(o.shape,c.shape,"Error in meanSquaredError: ");const h=Bn(o,c);return na(h,l,r)}});const ca=Object(h.b)({sigmoidCrossEntropy_:function(e,t,n,r=0,c=ta.a.SUM_BY_NONZERO_WEIGHTS){let l=Object(d.a)(e,"multiClassLabels","sigmoidCrossEntropy");const h=Object(d.a)(t,"logits","sigmoidCrossEntropy");let f=null;if(null!=n&&(f=Object(d.a)(n,"weights","sigmoidCrossEntropy")),Object(x.e)(l.shape,h.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Object(De.a)(r),t=Object(De.a)(1),n=Object(De.a)(.5);l=Object(y.a)(Object(L.a)(l,Object(sub.a)(t,e)),Object(L.a)(n,e))}const m=function(e,t){const n=Object(d.a)(e,"labels","sigmoidCrossEntropyWithLogits"),r=Object(d.a)(t,"logits","sigmoidCrossEntropyWithLogits");Object(x.e)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const c=Object(mn.a)(r),l=Object(L.a)(r,n),h=pt(We(Object(ft.a)(Object(o.a)(r))));return Object(y.a)(Object(sub.a)(c,l),h)}(l,h);return na(m,f,c)}});const la=Object(h.b)({softmaxCrossEntropy_:function(e,t,n,r=0,o=ta.a.SUM_BY_NONZERO_WEIGHTS){let c=Object(d.a)(e,"onehotLabels","softmaxCrossEntropy");const l=Object(d.a)(t,"logits","softmaxCrossEntropy");let h=null;if(null!=n&&(h=Object(d.a)(n,"weights","softmaxCrossEntropy")),Object(x.e)(c.shape,l.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Object(De.a)(r),t=Object(De.a)(1),n=Object(De.a)(c.shape[1]);c=Object(y.a)(Object(L.a)(c,Object(sub.a)(t,e)),Object(div.a)(e,n))}const f=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=Object(ht.a)(((e,t,r)=>{const o=yt(t,[n],!0),c=Object(sub.a)(Object(E.a)(t,"float32"),o);r([e,c]);const l=Object(ft.a)(Object(L.a)(c,e));return{value:Object(Le.a)(l,[n]),gradFunc:(e,t)=>{const[r,o]=t,c=Object(Ae.e)(e.shape,[n]);return[Object(L.a)(Object(R.a)(e,c),Object(sub.a)(Object(E.a)(r,"float32"),We(o))),Object(L.a)(Object(R.a)(e,c),Object(sub.a)(We(o),Object(E.a)(r,"float32")))]}}}));return r(e,t)}(c,l);return na(f,h,o)}});const da=Object(h.b)({sparseFillEmptyRows_:function(e,t,n,r){const o=Object(d.a)(e,"indices","sparseFillEmptyRows","int32"),h=Object(d.a)(t,"values","sparseFillEmptyRows"),f=Object(d.a)(n,"denseShape","sparseFillEmptyRows","int32"),m=Object(d.a)(r,"defaultValue","sparseFillEmptyRows",h.dtype);if(2!==o.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${o.shape}`);if(1!==h.rank)throw new Error(`Values should be Tensor1D but received shape ${h.shape}`);if(1!==f.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${f.shape}`);if(0!==m.rank)throw new Error(`Default value should be a scalar but received shape ${m.shape}`);const y={indices:o,values:h,denseShape:f,defaultValue:m},x=c.a.runKernel(l.Pc,y);return{outputIndices:x[0],outputValues:x[1],emptyRowIndicator:x[2],reverseIndexMap:x[3]}}});const pa=Object(h.b)({sparseReshape_:function(e,t,n){const r=Object(d.a)(e,"inputIndices","sparseReshape","int32"),o=Object(d.a)(t,"inputShape","sparseReshape","int32"),h=Object(d.a)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==o.rank)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(1!==h.rank)throw new Error(`New shape should be Tensor1D but received shape ${h.shape}`);const f={inputIndices:r,inputShape:o,newShape:h},m=c.a.runKernel(l.Qc,f);return{outputIndices:m[0],outputShape:m[1]}}});const ha=Object(h.b)({sparseSegmentMean_:function(data,e,t){const n=Object(d.a)(data,"data","sparseSegmentMean"),r=Object(d.a)(e,"indices","sparseSegmentMean","int32"),o=Object(d.a)(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);const h={data:n,indices:r,segmentIds:o};return c.a.runKernel(l.Rc,h)}});const fa=Object(h.b)({sparseSegmentSum_:function(data,e,t){const n=Object(d.a)(data,"data","sparseSegmentSum"),r=Object(d.a)(e,"indices","sparseSegmentSum","int32"),o=Object(d.a)(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);const h={data:n,indices:r,segmentIds:o};return c.a.runKernel(l.Sc,h)}});const ma=Object(h.b)({stringNGrams_:function(data,e,t,n,r,o,h,f){const m=Object(d.a)(data,"data","stringNGrams","string");if("string"!==m.dtype)throw new Error("Data must be of datatype string");if(1!==m.shape.length)throw new Error(`Data must be a vector, saw: ${m.shape}`);const y=Object(d.a)(e,"dataSplits","stringNGrams");if("int32"!==y.dtype)throw new Error("Data splits must be of datatype int32");const x={separator:t,nGramWidths:n,leftPad:r,rightPad:o,padWidth:h,preserveShortSequences:f},v={data:m,dataSplits:y},O=c.a.runKernel(l.ad,v,x);return{nGrams:O[0],nGramsSplits:O[1]}}});const ba=Object(h.b)({stringSplit_:function(input,e,t=!0){const n=Object(d.a)(input,"input","stringSplit","string"),r=Object(d.a)(e,"delimiter","stringSplit","string");if(1!==n.rank)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},h={input:n,delimiter:r},f=c.a.runKernel(l.bd,h,o);return{indices:f[0],values:f[1],shape:f[2]}}});const ga=Object(h.b)({stringToHashBucketFast_:function(input,e){const t=Object(d.a)(input,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return c.a.runKernel(l.cd,r,n)}}),ya={fft:Fn,ifft:Dn,rfft:Ln,irfft:Mn},xa={hammingWindow:$r,hannWindow:Er,frame:Ar,stft:Rr},va={flipLeftRight:Fr,grayscaleToRGB:Dr,resizeNearestNeighbor:qr,resizeBilinear:Hr,rotateWithOffset:Mr,cropAndResize:_r,nonMaxSuppression:Lr,nonMaxSuppressionAsync:zr,nonMaxSuppressionWithScore:Vr,nonMaxSuppressionWithScoreAsync:Wr,nonMaxSuppressionPadded:Ur,nonMaxSuppressionPaddedAsync:Gr,threshold:Kr,transform:Xr},Oa={bandPart:Yr,gramSchmidt:Zr,qr:ea},ka={absoluteDifference:ra,computeWeightedLoss:na,cosineDistance:aa,hingeLoss:sa,huberLoss:oa,logLoss:ia,meanSquaredError:ua,sigmoidCrossEntropy:ca,softmaxCrossEntropy:la},wa={sparseFillEmptyRows:da,sparseReshape:pa,sparseSegmentMean:ha,sparseSegmentSum:fa},Ia={stringNGrams:ma,stringSplit:ba,stringToHashBucketFast:ga}},function(e,t,n){"use strict";(function(e){n(282);var t=n(358),r=n(294);const o=Object(r.c)();o.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),o.registerFlag("IS_BROWSER",(()=>t.isBrowser())),o.registerFlag("IS_NODE",(()=>void 0!==e&&void 0!==e.versions&&void 0!==e.versions.node)),o.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),o.registerFlag("PROD",(()=>!1)),o.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>o.getBool("DEBUG"))),o.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),o.registerFlag("IS_TEST",(()=>!1)),o.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),o.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),o.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),o.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1))}).call(this,n(133))},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(281),o=n(314);function c(e,t,n){const c=Object(r.c)(e,n);return Object(o.a)(e,t,c,n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(282),o=n(283);function c(e,t,n){const c={shape:e,value:t,dtype:n};return r.a.runKernel(o.gb,{},c)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const h=Object(d.b)({pow_:function(base,e){let t=Object(l.a)(base,"base","pow"),n=Object(l.a)(e,"exp","pow");[t,n]=Object(c.makeTypesMatch)(t,n);const d={a:t,b:n};return r.a.runKernel(o.kc,d)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({sigmoid_:function(e){const t={x:Object(c.a)(e,"x","sigmoid","float32")};return r.a.runKernel(o.Hc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({imag_:function(input){const e={input:Object(c.a)(input,"input","imag")};return r.a.runKernel(o.ub,e)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({real_:function(input){const e={input:Object(c.a)(input,"input","real")};return r.a.runKernel(o.pc,e)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({relu_:function(e){const t={x:Object(c.a)(e,"x","relu")};return r.a.runKernel(o.sc,t)}})},function(e,t,n){"use strict";n.r(t),n.d(t,"validateUpdateShape",(function(){return o})),n.d(t,"validateInput",(function(){return c})),n.d(t,"calculateShapes",(function(){return l}));var r=n(320);function o(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,c=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(c+` update.rank < ${o}. `);if(e.length<r+(n.rank-o))throw new Error(c+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+e.length-r)throw new Error(c+" update.rank != "+(o+e.length-r));for(let e=0;e<o;++e)if(n.shape[e]!==t.shape[e])throw new Error(c+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-o;++t)if(n.shape[t+o]!==e[t+r])throw new Error(c+` updates.shape[${t+o}] (${n.shape[t+o]}) != shape[${t+o}] (${e[t+o]})`)}function c(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}o(n,t,e)}function l(e,t,n){const o=t.shape.length,c=o>1?t.shape[o-1]:1,l=n.length;let d=1;for(let i=c;i<l;++i)d*=n[i];const h=c<1?1:c;return{sliceRank:c,numUpdates:Object(r.O)(t.shape)/h,sliceSize:d,strides:[...Object(r.j)(n.slice(0,c)),1],outputSize:Object(r.O)(n)}}},function(e,t,n){"use strict";n.d(t,"c",(function(){return o})),n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l}));const r={};function o(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};r[e]=n}function c(e){return r[e]}function l(e){delete r[e]}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return c}));var r=n(279);function o(e,t,n,o,c){const l=r.util.sizeFromShape(o),d=r.util.makeZerosTypedArray(c,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=c||(d[n]+=l>0?t[i]:1)}return d}function c(e,t,n,o=!1){const c=e.shape[0],l=e.shape[1],d=Object(r.buffer)([c,n],t.dtype);for(let i=0;i<c;i++)for(let r=0;r<l;r++){const c=e.get(i,r);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(o?d.set(1,i,c):t.size>0?d.set(d.get(i,c)+t.get(i,r),i,c):d.set(d.get(i,c)+1,i,c))}return d}},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return sub})),n.d(t,"b",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((e,t)=>e-t)),d=Object(c.b)(((e,t,n,r)=>({real:e-n,imag:t-r}))),sub=Object(c.a)(r.Sub,l,d),h={kernelName:r.Sub,backendName:"cpu",kernelFunc:sub}},function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return c}));var r=n(294);function o(...e){Object(r.c)().getBool("IS_TEST")||Object(r.c)().getBool("PROD")||console.warn(...e)}function c(...e){Object(r.c)().getBool("IS_TEST")||Object(r.c)().getBool("PROD")||console.log(...e)}},function(e,t,n){"use strict";n.d(t,"c",(function(){return h})),n.d(t,"b",(function(){return f})),n.d(t,"d",(function(){return m})),n.d(t,"f",(function(){return y})),n.d(t,"e",(function(){return x})),n.d(t,"h",(function(){return v})),n.d(t,"g",(function(){return O})),n.d(t,"a",(function(){return k}));var r=n(294),o=n(357),c=n(347);const l=Object(o.a)("kernelRegistry",(()=>new Map)),d=Object(o.a)("gradRegistry",(()=>new Map));function h(e,t){const n=w(e,t);return l.get(n)}function f(e){return d.get(e)}function m(e){const t=l.entries(),n=[];for(;;){const{done:r,value:o}=t.next();if(r)break;const[c,l]=o,[d]=c.split("_");d===e&&n.push(l)}return n}function y(e){const{kernelName:t,backendName:n}=e,r=w(t,n);l.has(r)&&c.b(`The kernel '${t}' for backend '${n}' is already registered`),l.set(r,e)}function x(e){const{kernelName:t}=e;d.has(t)&&Object(r.c)().getBool("DEBUG")&&c.b(`Overriding the gradient for '${t}'`),d.set(t,e)}function v(e,t){const n=w(e,t);if(!l.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);l.delete(n)}function O(e){if(!d.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);d.delete(e)}function k(e,t){m(e).forEach((e=>{y(Object.assign({},e,{backendName:t}))}))}function w(e,t){return`${t}_${e}`}},function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o}));class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class o{refCount(e){return c("refCount")}incRef(e){return c("incRef")}timerAvailable(){return!0}time(e){return c("time")}read(e){return c("read")}readSync(e){return c("readSync")}readToGPU(e,t){return c("readToGPU")}numDataIds(){return c("numDataIds")}disposeData(e,t){return c("disposeData")}write(e,t,n){return c("write")}move(e,t,n,r,o){return c("move")}memory(){return c("memory")}floatPrecision(){return c("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return c("dispose")}}function c(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return v}));var r=n(282),o=n(304),c=n(283),l=n(281),d=n(320),h=n(315),f=n(340),m=n(316),y=n(280),x=n(341);const v=Object(y.b)({transpose_:function(e,t,n){const y=Object(l.a)(e,"x","transpose");if(null==t&&(t=y.shape.map(((s,i)=>i)).reverse()),d.b(y.rank===t.length,(()=>`Error in transpose: rank of input ${y.rank} must match length of perm ${t}.`)),t.forEach((e=>{d.b(e>=0&&e<y.rank,(()=>"All entries in 'perm' must be between 0 and "+(y.rank-1)+` but got ${t}`))})),y.rank<=1)return y.clone();const v={x:y},O={perm:t};return"complex64"===y.dtype?Object(o.t)((()=>{let e=Object(x.a)(y),t=Object(f.a)(y);return e=r.a.runKernel(c.kd,{x:e},O),t=r.a.runKernel(c.kd,{x:t},O),n&&(t=Object(m.a)(t)),Object(h.a)(e,t)})):r.a.runKernel(c.kd,v,O)}})},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a===b?1:0)),d=Object(c.a)(r.Equal,l,null,"bool"),h={kernelName:r.Equal,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.exp(e))),d=Object(c.b)(r.Exp,l,"float32"),h={kernelName:r.Exp,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o,c){const l=t.length,d=r.util.sizeFromShape(t),h=r.util.computeStrides(t),f=r.util.computeStrides(c),m=r.util.getTypedArrayFromDType(n,r.util.sizeFromShape(c));for(let i=0;i<d;++i){const t=r.util.indexToLoc(i,l,h),n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[o[i]];m[r.util.locToIndex(n,l,f)]=e[i]}return m}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o,c,l,d,h,f,m){const y=[o/c,c],x=e.values,v=t.values;if(0===o)return Object(r.buffer)(n,t.dtype);const O=Object(r.buffer)(y,t.dtype);"string"==typeof f||"number"==typeof f?O.values.fill(f):"boolean"==typeof f&&O.values.fill(+f);for(let i=0;i<l;i++){const e=[];let r=0;for(let t=0;t<d;t++){const n=x[i*d+t];e.push(n),r+=n*h[t]}if(r<0||r>=o/c)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let e=0;e<c;e++)m?O.values[r*c+e]+=v[i*c+e]:O.values[r*c+e]=0===t.rank?v[0]:v[i*c+e]}return O}},function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>1/(1+Math.exp(-e)))),d=Object(c.a)(r.Sigmoid,(e=>1/(1+Math.exp(-e)))),h={kernelName:r.Sigmoid,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(input,e,t,n,o,c=!1,l=0){const d=n.length,h=[e[0],input.length/e[0]],f=h[1],m=d>0?o[d-1]+1:0;if(m<0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const y=e.slice();y[0]=m;const x=y.reduce(((e,t)=>e*t),1),output=r.util.getArrayFromDType(t,x);if(0===d)return m>0&&output.fill(l),[output,y];if(m<=0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let v=0,O=1,k=0,w=o[v];for(;;){let e=0;if(O<d){if(e=o[O],w===e){++O;continue}if(w>=e)throw new Error(r.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=m)throw new Error(r.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,m));w>k&&output.fill(l,k*f,w*f);for(let i=v;i<O;++i){const e=n[i];if(e<0||e>=h[0])throw new Error(r.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i,n[i],h[0]));for(let t=0;t<f;t++)output[w*f+t]+=input[e*f+t]}if(c)for(let e=0;e<f;e++)output[w*f+e]/=O-v;if(v=O,++O,k=w+1,w=e,O>d)break}return k<m&&output.fill(l,k*f,m*f),[output,y]}},function(e,t,n){"use strict";(function(e,r){let o;function c(){if(null==o){let t;if("undefined"!=typeof window)t=window;else if(void 0!==e)t=e;else if(void 0!==r)t=r;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}o=t}return o}function l(e,t){const n=function(){const e=c();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l}))}).call(this,n(39),n(133))},function(e,t,n){"use strict";let r;function o(e){r=e}function c(nav){if(void 0!==r)return r;if(nav||"undefined"!=typeof navigator&&null!=navigator){if(nav||(nav=navigator),"ReactNative"===nav.product)return!0;const a=nav.userAgent||nav.vendor||("undefined"!=typeof window?window.opera:"");if(!a){const e=nav;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function l(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}n.r(t),n.d(t,"mockIsMobile",(function(){return o})),n.d(t,"isMobile",(function(){return c})),n.d(t,"isBrowser",(function(){return l}))},function(e,t,n){"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,"a",(function(){return r}))},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(280);const h=Object(d.b)({floorDiv_:function(a,b){let e=Object(l.a)(a,"a","floorDiv"),t=Object(l.a)(b,"b","floorDiv");[e,t]=Object(c.makeTypesMatch)(e,t);const n={a:e,b:t};return r.a.runKernel(o.jb,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return m}));var r=n(282),o=n(283),c=n(288),l=n(281),d=n(292),h=n(298),f=n(280);const m=Object(f.b)({maximum_:function(a,b){let e=Object(l.a)(a,"a","maximum"),t=Object(l.a)(b,"b","maximum");[e,t]=Object(c.makeTypesMatch)(e,t),"bool"===e.dtype&&(e=Object(h.a)(e,"int32"),t=Object(h.a)(t,"int32")),Object(d.assertAndGetBroadcastShape)(e.shape,t.shape);const n={a:e,b:t};return r.a.runKernel(o.Sb,n)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({elu_:function(e){const t={x:Object(c.a)(e,"x","elu","float32")};return r.a.runKernel(o.Y,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({leakyRelu_:function(e,t=.2){const n={x:Object(c.a)(e,"x","leakyRelu")},l={alpha:t};return r.a.runKernel(o.Ab,n,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({oneHot_:function(e,t,n=1,l=0,d="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const h={indices:Object(c.a)(e,"indices","oneHot","int32")},f={dtype:d,depth:t,onValue:n,offValue:l};return r.a.runKernel(o.fc,h,f)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({prelu_:function(e,t){const n={x:Object(c.a)(e,"x","prelu"),alpha:Object(c.a)(t,"alpha","prelu")};return r.a.runKernel(o.lc,n)}})},function(e,t,n){"use strict";n.r(t),n.d(t,"TEST_EPSILON_FLOAT16",(function(){return d})),n.d(t,"expectArraysClose",(function(){return h})),n.d(t,"testEpsilon",(function(){return f})),n.d(t,"expectPromiseToFail",(function(){return y})),n.d(t,"expectArraysEqual",(function(){return x})),n.d(t,"expectNumbersClose",(function(){return v})),n.d(t,"expectValuesInRange",(function(){return k})),n.d(t,"expectArrayBuffersEqual",(function(){return w})),n.d(t,"encodeStrings",(function(){return I})),n.d(t,"createVideoElement",(function(){return S})),n.d(t,"play",(function(){return N}));var r=n(282),o=n(281),c=n(320),l=n(284);const d=.1;function h(e,t,n){return null==n&&(n=f()),m(e,t,((a,b)=>O(a,b,n)))}function f(){return 32===r.a.backend.floatPrecision()?.001:d}function m(e,t,n){let r=!0;if((Object(c.A)(e)||Object(c.A)(t))&&(r=!1),Object(c.A)(e)&&Object(c.A)(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=Object(o.c)(e),r=Object(o.c)(t);if(!Object(c.a)(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const l=Object(c.A)(e)?e:Object(c.m)(e),d=Object(c.A)(t)?t:Object(c.m)(t);if(l.length!==d.length)throw new Error(`Arrays have different lengths actual: ${l.length} vs expected: ${d.length}.\nActual:   ${l}.\nExpected: ${d}.`);for(let i=0;i<d.length;++i){const a=l[i],e=d[i];if(!n(a,e))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\nActual:   ${l}.\nExpected: ${d}.`)}"undefined"!=typeof expect&&expect().nothing()}function y(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function x(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Object(c.z)(e)||Object(c.z)(e[0])||Object(c.z)(t)||Object(c.z)(t[0])?m(e,n,((a,b)=>a==b)):m(e,t,((a,b)=>O(a,b,0)))}function v(a,e,t){if(null==t&&(t=f()),!O(a,e,t))throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);"undefined"!=typeof expect&&expect().nothing()}function O(a,e,t){return!isFinite(a)&&!isFinite(e)||!(isNaN(a)||isNaN(e)||Math.abs(a-e)>t)}function k(e,t,n){for(let i=0;i<e.length;i++)if(e[i]<t||e[i]>n)throw new Error(`Value out of range:${e[i]} low: ${t}, high: ${n}`)}function w(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let i=0;i<r.length;i++)if(n[i]!==r[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${r[i]} but got ${n[i]} instead`)}function I(a){for(let i=0;i<a.length;i++){const e=a[i];Array.isArray(e)?I(e):a[i]=Object(l.encodeString)(e)}return a}function S(source){const video=document.createElement("video");return"playsInline"in video&&(video.playsInline=!0),video.muted=!0,video.loop=!0,video.style.position="fixed",video.style.left="0px",video.style.top="0px",video.preload="auto",video.appendChild(source),new Promise((e=>{video.addEventListener("loadeddata",(t=>e(video))),video.load()}))}async function N(video){await video.play(),"requestVideoFrameCallback"in video&&await new Promise((e=>{video.requestVideoFrameCallback(e)}))}},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({relu6_:function(e){const t={x:Object(c.a)(e,"x","relu6")};return r.a.runKernel(o.tc,t)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n(282),o=n(283),c=n(281),l=n(280);const d=Object(l.b)({step_:function(e,t=0){const n={x:Object(c.a)(e,"x","step")},l={alpha:t};return r.a.runKernel(o.Yc,n,l)}})},function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n(281),o=n(320),c=n(314);function l(e,t,n){if(Object(o.d)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const l=Object(r.c)(e,n);if(3!==l.length&&1!==l.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===l.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(c.a)(e,t,l,n)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(309);function o(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const o=Object(r.a)(e,"int32"),c=Object(r.a)([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const t=o.indexToLoc(n[i]),r=i*e.length;c.values.set(t,r)}return c.toTensor()}},function(e,t,n){"use strict";n.r(t);var r=n(372);n.d(t,"simpleAbsImpl",(function(){return r.b}));var o=n(324);n.d(t,"addImpl",(function(){return o.c}));var c=n(345);n.d(t,"bincountImpl",(function(){return c.a})),n.d(t,"bincountReduceImpl",(function(){return c.b}));var l=n(325);n.d(t,"castImpl",(function(){return l.c}));var d=n(373);n.d(t,"ceilImpl",(function(){return d.b}));var h=n(374);n.d(t,"concatImpl",(function(){return h.a}));var f=n(351);n.d(t,"equalImpl",(function(){return f.c}));var m=n(352);n.d(t,"expImpl",(function(){return m.c}));var y=n(375);n.d(t,"expm1Impl",(function(){return y.b}));var x=n(376);n.d(t,"floorImpl",(function(){return x.b}));var v=n(377);n.d(t,"gatherNdImpl",(function(){return v.a}));var O=n(378);n.d(t,"gatherV2Impl",(function(){return O.a}));var k=n(379);n.d(t,"greaterImpl",(function(){return k.b}));var w=n(380);n.d(t,"greaterEqualImpl",(function(){return w.b}));var I=n(381);n.d(t,"lessImpl",(function(){return I.b}));var S=n(382);n.d(t,"lessEqualImpl",(function(){return S.b}));var N=n(383);n.d(t,"linSpaceImpl",(function(){return N.a}));var T=n(384);n.d(t,"logImpl",(function(){return T.b}));var j=n(385);n.d(t,"maxImpl",(function(){return j.a}));var C=n(386);n.d(t,"maximumImpl",(function(){return C.b}));var $=n(387);n.d(t,"minimumImpl",(function(){return $.b}));var E=n(326);n.d(t,"multiplyImpl",(function(){return E.c}));var A=n(388);n.d(t,"negImpl",(function(){return A.b}));var R=n(389);n.d(t,"notEqualImpl",(function(){return R.b}));var _=n(390);n.d(t,"prodImpl",(function(){return _.b}));var F=n(391);n.d(t,"raggedTensorToTensorImpl",(function(){return F.a}));var D=n(392);n.d(t,"rangeImpl",(function(){return D.a}));var M=n(393);n.d(t,"rsqrtImpl",(function(){return M.b}));var P=n(354);n.d(t,"scatterImpl",(function(){return P.a}));var L=n(355);n.d(t,"sigmoidImpl",(function(){return L.c}));var B=n(319);n.d(t,"sliceImpl",(function(){return B.c}));var z=n(394);n.d(t,"sparseFillEmptyRowsImpl",(function(){return z.a}));var V=n(395);n.d(t,"sparseReshapeImpl",(function(){return V.a}));var W=n(356);n.d(t,"sparseSegmentReductionImpl",(function(){return W.a}));var U=n(396);n.d(t,"sqrtImpl",(function(){return U.b}));var G=n(397);n.d(t,"squaredDifferenceImpl",(function(){return G.b}));var H=n(398);n.d(t,"stridedSliceImpl",(function(){return H.a}));var K=n(399);n.d(t,"stringNGramsImpl",(function(){return K.a}));var X=n(400);n.d(t,"stringSplitImpl",(function(){return X.a}));var Y=n(401);n.d(t,"stringToHashBucketFastImpl",(function(){return Y.a}));var Z=n(346);n.d(t,"subImpl",(function(){return Z.c}));var Q=n(402);n.d(t,"tileImpl",(function(){return Q.a}));var J=n(403);n.d(t,"topKImpl",(function(){return J.a}));var ee=n(353);n.d(t,"transposeImpl",(function(){return ee.a}));var te=n(404);n.d(t,"uniqueImpl",(function(){return te.a}))},function(e,t,n){"use strict";n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l}));var r=n(279),o=n(285);function c(e){const t=new Float32Array(e.length);for(let i=0;i<e.length;++i)t[i]=Math.abs(e[i]);return t}const l={kernelName:r.Abs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;Object(o.a)(t,"abs");let l=new Float32Array(r.util.sizeFromShape(t.shape));return l=c(n.data.get(t.dataId).values),n.makeOutput(l,t.shape,t.dtype)}}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.ceil(e))),d=Object(c.b)(r.Ceil,l),h={kernelName:r.Ceil,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o){const c=r.util.getArrayFromDType(n,r.util.sizeFromShape(t));if(o&&"string"!==n){let t=0;e.forEach((input=>{const e=r.util.sizeFromShape(input.shape);c.set(input.vals,t),t+=e}))}else{let o=0;e.forEach((input=>{const e="string"===n?r.backend_util.fromUint8ToStringArray(input.vals):input.vals;let l=0;for(let n=0;n<input.shape[0];++n){const r=n*t[1]+o;for(let col=0;col<input.shape[1];++col)c[r+col]=e[l++]}o+=input.shape[1]}))}return c}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.expm1(e))),d=Object(c.b)(r.Expm1,l),h={kernelName:r.Expm1,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.floor(e))),d=Object(c.b)(r.Floor,l),h={kernelName:r.Floor,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o,c,l,d,h,f){const m=Object(r.buffer)([o,l],n);for(let i=0;i<o;i++){const n=[];let r=0;for(let t=0;t<c;t++){const o=e[i*c+t];r+=o*d[t],n.push(o)}if(r<0||r>=f/l)throw new Error(`Invalid indices: ${n} does not index into ${h}`);for(let e=0;e<l;e++)m.values[i*l+e]=t.get(...t.indexToLoc(r*l+e))}return m}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n){const o=Object(r.buffer)(n,e.dtype);for(let i=0;i<o.size;++i){const n=o.indexToLoc(i).slice(),r=n[0],c=n[2],l=t.locToIndex([r,c]);n[2]=t.values[l];const d=e.locToIndex(n);0<=d&&d<e.values.length&&(o.values[i]=e.values[d])}return o}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a>b?1:0)),d=Object(c.a)(r.Greater,l,null,"bool"),h={kernelName:r.Greater,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a>=b?1:0)),d=Object(c.a)(r.GreaterEqual,l,null,"bool"),h={kernelName:r.GreaterEqual,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a<b?1:0)),d=Object(c.a)(r.Less,l,null,"bool"),h={kernelName:r.Less,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a<=b?1:0)),d=Object(c.a)(r.LessEqual,l,null,"bool"),h={kernelName:r.LessEqual,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n){const o=(t-e)/(n-1),c=r.util.makeZerosTypedArray(n,"float32");c[0]=e;for(let i=1;i<c.length;i++)c[i]=c[i-1]+o;return c}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.log(e))),d=Object(c.b)(r.Log,l),h={kernelName:r.Log,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o){const c=r.util.getTypedArrayFromDType(o,r.util.sizeFromShape(n));for(let i=0;i<c.length;++i){const n=i*t;let r=e[n];for(let o=0;o<t;++o){const t=e[n+o];(Number.isNaN(t)||t>r)&&(r=t)}c[i]=r}return c}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((e,t)=>Math.max(e,t))),d=Object(c.a)(r.Maximum,l),h={kernelName:r.Maximum,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((e,t)=>Math.min(e,t))),d=Object(c.a)(r.Minimum,l),h={kernelName:r.Minimum,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return d}));var r=n(279),o=n(285),c=n(326);function l(e,t,n){const o=r.util.createScalarValue(-1,n);return Object(c.c)([],t,o,e,n)}const d={kernelName:r.Neg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;Object(o.a)(r,"neg");const c=n.data.get(r.dataId).values,[d,h]=l(c,r.shape,r.dtype);return n.makeTensorInfo(h,r.dtype,d)}}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>a!==b?1:0)),d=Object(c.a)(r.NotEqual,l,null,"bool"),h={kernelName:r.NotEqual,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return d}));var r=n(279),o=n(285),c=n(303);function l(e,t,n,o){const[c,l]=r.backend_util.computeOutAndReduceShapes(e,o),d=Object(r.upcastType)(t,"int32"),h=r.util.makeZerosTypedArray(r.util.sizeFromShape(c),d),f=r.util.sizeFromShape(l);for(let i=0;i<h.length;++i){const e=i*f;let t=1;for(let r=0;r<f;++r)t*=n[e+r];h[i]=t}return{outVals:h,outShape:c,outDtype:d}}const d={kernelName:r.Prod,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:d}=e,{x:h}=t,{axis:f,keepDims:m}=d;Object(o.a)(h,"prod");const y=h.shape.length,x=r.util.parseAxisParam(f,h.shape),v=r.backend_util.getAxesPermutation(x,y);let O=x,k=h;const w=[];null!=v&&(k=Object(c.a)({inputs:{x:h},backend:n,attrs:{perm:v}}),w.push(k),O=r.backend_util.getInnerMostAxes(O.length,y));const I=n.data.get(k.dataId).values,{outVals:S,outShape:N,outDtype:T}=l(k.shape,k.dtype,I,O);let j=N;return m&&(j=r.backend_util.expandShapeToKeepDim(N,x)),w.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(j,T,S)}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(279),o=r.backend_util.RowPartitionType;class c{constructor(e,t,n,o,c,l,d,h,f,m){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=o,this.valuesDType=c,this.defaultValue=l,this.defaultValueShape=d,this.rowPartitionValues=h,this.rowPartitionValuesShapes=f,this.rowPartitionTypes=r.backend_util.getRowPartitionTypesHelper(m),this.raggedRank=r.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===o.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===o.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case o.VALUE_ROWIDS:return c.getMaxWidthValueRowID(t);case o.ROW_SPLITS:return c.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${o[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let i=0;i<t-1;++i){const t=e[i+1]-e[i];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],o=0;for(let i=1;i<t;++i){const t=e[i];t!==r&&(r=t,o=Math.max(i-n,o),n=i)}return Math.max(t-n,o)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return d(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;r.backend_util.validateDefaultValueShape(n,t);const o=this.tensorShapeFromTensor(this.shape,this.shapeShape),c=r.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);c[0]<0&&(c[0]=e);for(let i=1;i<=this.raggedRank;++i)c[i]<0&&(c[i]=this.getMaxWidth(i));return c}calculateFirstParentOutputIndex(e,t,n){const o=Math.min(e,n),c=[];let l=0;for(let i=0;i<o;++i,l+=t)c.push(l);for(let i=o;i<e;++i)c.push(-1);return r.util.assert(c.length===e,(()=>"Final length of result must be equal to firstDimension.")),c}calculateOutputIndexRowSplit(e,t,n,r){const o=e.length,c=[];for(let i=0;i<o-1;++i){const o=e[i+1]-e[i];let l=Math.min(r,o),d=t[i];-1===d&&(l=0);for(let e=0;e<l;++e)c.push(d),d+=n;for(let e=0;e<o-l;++e)c.push(-1)}if(o>0&&c.length!==e[o-1])throw new Error("Invalid row split size.");return c}calculateOutputIndexValueRowID(e,t,n,r){const o=e.length,c=[];if(0===o)return[];let l=0,d=e[0];if(d>=t.length)throw new Error(`Got currentValueRowId=${d}, which is not less than ${t.length}`);let h=t[d];c.push(h);for(let i=1;i<o;++i){const o=e[i];if(o===d)h>=0&&(++l,l<r?h+=n:h=-1);else{if(l=0,d=o,o>=t.length)throw new Error(`Got nextValueRowId=${o} which is not less than ${t.length}`);h=t[o]}c.push(h)}if(c.length!==e.length)throw new Error("Invalid row ids.");return c}calculateOutputIndex(e,t,n,r){const c=this.getRowPartitionTensor(e),l=this.getRowPartitionTypeByDimension(e);switch(l){case o.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(c,t,n,r);case o.ROW_SPLITS:if(c.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${c.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(c,t,n,r);default:throw new Error(`Unsupported partition type: ${o[l]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case o.FIRST_DIM_SIZE:return e[0];case o.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case o.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${o[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*t[i+1];const o=d(t,!1),c=r.util.getArrayFromDType(this.valuesDType,r.util.sizeFromShape(o));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let i=1;i<=this.raggedRank;++i){r=this.calculateOutputIndex(i-1,r,n[i],t[i])}this.setOutput(this.raggedRank,r,c,o)}return[o,c]}setOutput(e,t,n,o){if(0===n.length)return;const c=this.values,d=n;let h=o.slice();h=h.slice(e+1);const f=r.util.sizeFromShape(h),m=t.length;let y=this.defaultValue;if(y.length!==f&&1!==y.length){const e=this.defaultValueShape;Object(r.tidy)((()=>{const t=Object(r.reshape)(y,e),n=Object(r.broadcastTo)(t,h);y=n.dataSync()}))}let x=0,v=0,O=0;for(let e=0;e<=m;++e){let r=e<m?t[e]:-1;if(r!==O){if(v<O){const e=c.subarray(x*f);l(d.subarray(v*f),e,(O-v)*f)}if(e>=m){const e=n.length;r=Math.floor(e/f)}if(r>O)if(1===this.defaultValue.length)d.subarray(O*f,r*f).fill(this.defaultValue[0]),O=r;else for(;r>O;){l(d.slice(O*f),y,f),++O}r<0?(x=e+1,v=O):(x=e,v=O,O=v+1)}else++O}}}function l(e,t,n){for(let i=0;i<n;i++)e[i]=t[i]}function d(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function h(e,t,n,r,o,l,d,h,f,m){return new c(e,t,n,r,o,l,d,h,f,m).compute()}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o){if(e===t||e<t&&n<0||t<e&&n>1)return r.util.makeZerosTypedArray(0,o);const c=Math.abs(Math.ceil((t-e)/n)),l=r.util.makeZerosTypedArray(c,o);t<e&&1===n&&(n=-1),l[0]=e;for(let i=1;i<l.length;i++)l[i]=l[i-1]+n;return l}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>1/Math.sqrt(e))),d=Object(c.b)(r.Rsqrt,l),h={kernelName:r.Rsqrt,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o,c,l,d){const h=t[0],f=l[0],m=new Array(f),y=new Array(h),x=t[1];if(0===f){if(0!==h)throw new Error(r.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(h));return[r.util.getArrayFromDType(n,0),[0,x],r.util.getArrayFromDType(c,0),m,y]}let v=!0,O=0;const k=new Array(f).fill(0);for(let i=0;i<h;++i){const t=e[i*x];if(t<0)throw new Error(r.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(i,t));if(t>=f)throw new Error(r.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i,t,f));++k[t],v=v&&t>=O,O=t}let w=!0;for(let e=0;e<f;++e){const t=0===k[e];m[e]=t,w=w&&!t,k[e]=Math.max(k[e],1),e>0&&(k[e]+=k[e-1])}if(w&&v){const t=e,n=o;for(let i=0;i<h;++i)y[i]=i;return[t,[h,x],n,m,y]}{const t=k[f-1],l=r.util.getArrayFromDType(n,t*x),v=r.util.getArrayFromDType(c,t),O=new Array(f).fill(0);for(let i=0;i<h;++i){const t=e[i*x],n=O[t],r=(0===t?0:k[t-1])+n;O[t]++;for(let t=0;t<x;++t)l[r*x+t]=e[i*x+t];v[r]=o[i],y[i]=r}for(let e=0;e<f;++e){if(0===O[e]){const t=0===e?0:k[e-1];l[t*x+0]=e;for(let col=1;col<x;++col)l[t*x+col]=0;v[t]=d}}return[l,[t,x],v,m,y]}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o,c){const l=r.util.sizeFromShape(o),d=t[0],h=c.length,f=[];let m=1,y=-1;for(let e=0;e<h;++e){const t=c[e];if(-1===t){if(-1!==y)throw new Error(r.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y,e));y=e,f.push(1)}else{if(t<0)throw new Error(r.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,t));m*=t,f.push(t)}}if(-1!==y){if(m<=0)throw new Error(r.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(l/m);if(m*e!==l)throw new Error(r.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(o,f));f[y]=e}if(r.util.sizeFromShape(f)!==l)throw new Error(r.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(o,f));const x=o.length,v=[];if(x>0){v[x-1]=1;for(let e=x-2;e>=0;--e)v[e]=v[e+1]*o[e+1]}const O=[];if(h>0){O[h-1]=1;for(let e=h-2;e>=0;--e)O[e]=O[e+1]*f[e+1]}const k=r.util.getArrayFromDType(n,d*h);for(let i=0;i<d;++i){let t=0;for(let n=0;n<x;++n)t+=e[i*x+n]*v[n];for(let e=0;e<h;++e)k[i*h+e]=Math.trunc(t/O[e]),t%=O[e]}return[k,[d,h],f]}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(318),c=n(287);const l=Object(o.a)((e=>Math.sqrt(e))),d=Object(c.a)(r.Sqrt,(e=>Math.sqrt(e))),h={kernelName:r.Sqrt,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"b",(function(){return l})),n.d(t,"a",(function(){return h}));var r=n(279),o=n(293),c=n(296);const l=Object(o.a)(((a,b)=>{const e=a-b;return e*e})),d=Object(c.a)(r.SquaredDifference,l),h={kernelName:r.SquaredDifference,backendName:"cpu",kernelFunc:d}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o){const c=Object(r.buffer)(e,t.dtype);for(let i=0;i<c.size;i++){const e=c.indexToLoc(i),r=new Array(e.length);for(let t=0;t<r.length;t++)r[t]=e[t]*n[t]+o[t];c.set(t.get(...r),...e)}return c}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(279);class o{constructor(e,t,n,o,c,l){this.separator=r.util.encodeString(e),this.nGramWidths=t,this.leftPad=r.util.encodeString(n),this.rightPad=r.util.encodeString(o),this.padWidth=c,this.preserveShort=l}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(data,e,output,t,n,r){for(let o=0;o<n;++o){const c=this.getPadWidth(r),l=Math.max(0,c-o),d=Math.max(0,c-(n-(o+1))),h=r-(l+d),f=e+(l>0?0:o-c);let m=0;m+=l*this.leftPad.length;for(let e=0;e<h;++e)m+=data[f+e].length;m+=d*this.rightPad.length;m+=(l+d+h-1)*this.separator.length,output[t+o]=new Uint8Array(m);const y=output[t+o];let x=0;const v=e=>e.forEach((e=>y[x++]=e));for(let e=0;e<l;++e)v(this.leftPad),v(this.separator);for(let e=0;e<h-1;++e)v(data[f+e]),v(this.separator);if(h>0){v(data[f+h-1]);for(let e=0;e<d;++e)v(this.separator),v(this.rightPad)}else{for(let e=0;e<d-1;++e)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(data,e){const t=data.length,n=e.length;if(n>0){let r=e[0];if(0!==r)throw new Error(`First split value must be 0, got ${r}`);for(let i=1;i<n;++i){let n=e[i]>=r;if(n=n&&e[i]<=t,!n)throw new Error(`Invalid split value ${e[i]}, must be in [${r}, ${t}]`);r=e[i]}if(r!==t)throw new Error(`Last split value must be data size. Expected ${t}, got ${r}`)}const o=n-1,c=r.util.getArrayFromDType("int32",n);if(0===t||0===n){const e=new Array(t);for(let i=0;i<=o;++i)c[i]=0;return[e,c]}c[0]=0;for(let i=1;i<=o;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach((e=>{n+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===n&&(n=1),c[i]=c[i-1]+n}const l=new Array(c[o]);for(let i=0;i<o;++i){const t=e[i];let n=c[i];if(this.nGramWidths.forEach((r=>{const o=e[i+1]-e[i],c=this.getNumNGrams(o,r);this.createNGrams(data,t,l,n,c,r),n+=c})),this.preserveShort&&n===c[i]){const r=e[i+1]-e[i];if(0===r)continue;const o=r+2*this.padWidth,c=1;this.createNGrams(data,t,l,n,c,o)}}return[l,c]}}function c(data,e,t,n,r,c,l,d){return new o(t,n,r,c,l,d).compute(data,e)}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(279);function o(e,t,n,r){if(!e.length)return;if(0===t.length){for(let i=0;i<e.length;++i)r.push(e.subarray(i,i+1));return}if(1===t.length){const o=t[0];let c=e.indexOf(o);for(;-1!==c;){const t=e.subarray(0,c);n&&0===t.length||r.push(t),c=(e=e.subarray(c+1)).indexOf(o)}return void(n&&0===e.length||r.push(e))}let o=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){const t=e.subarray(o,i);n&&0===t.length||r.push(t),o=i+1}}function c(input,e,t){const n=input.length,c=[];let l=0,d=0;const h=new Array(n);for(let i=0;i<n;++i){const n=c.length;o(input[i],e,t,c);const r=c.length-n;h[i]=r,l+=r,d=Math.max(d,r)}const f=r.util.getArrayFromDType("int32",2*l),m=new Array(l),y=[n,d];let x=0;for(let i=0;i<n;++i)for(let e=0;e<h[i];++e)f[2*x]=i,f[2*x+1]=e,m[x]=c[x],++x;return[f,m,y]}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(input,e){const output=r.util.getArrayFromDType("int32",input.length);for(let i=0;i<input.length;++i)output[i]=r.util.fingerPrint64(input[i]).modulo(e).getLowBitsUnsigned();return output}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t){const n=new Array(e.rank);for(let i=0;i<n.length;i++)n[i]=e.shape[i]*t[i];const o=Object(r.buffer)(n,e.dtype);for(let i=0;i<o.values.length;++i){const t=o.indexToLoc(i),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const r=e.locToIndex(n);o.values[i]=e.values[r]}return o}},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(279);const o=(a,b)=>{const e=b.value-a.value;return 0===e?a.index-b.index:e};function select(e,t,n=0,c=e.length-1){for(;c>n;){if(c-n>600){const r=c-n+1,i=t-n+1,o=Math.log(r),s=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*s*(r-s)/r)*Math.sign(i-r/2);select(e,t,Math.max(n,Math.floor(t-i*s/r+l)),Math.min(c,Math.floor(t+(r-i)*s/r+l)))}const l=e[t];let i=n,d=c;for(r.util.swap(e,n,t),o(e[c],l)>0&&r.util.swap(e,n,c);i<d;){for(r.util.swap(e,i,d),i++,d--;o(e[i],l)<0;)i+=1;for(;o(e[d],l)>0;)d-=1}0===o(e[n],l)?r.util.swap(e,n,d):(d+=1,r.util.swap(e,d,c)),d<=t&&(n=d+1),t<=d&&(c=d-1)}}function c(e,t,n,c,l){const d=t[t.length-1],[h,f]=[e.length/d,d],m=r.util.getTypedArrayFromDType(n,h*c),y=r.util.getTypedArrayFromDType("int32",h*c);for(let b=0;b<h;b++){const t=b*f,n=e.subarray(t,t+f);let r=new Array(n.length);n.forEach(((e,t)=>r[t]={value:e,index:t})),c<r.length&&(select(r,c),r=r.slice(0,c)),l&&r.sort(o);const d=b*c,h=m.subarray(d,d+c),x=y.subarray(d,d+c);for(let i=0;i<c;i++)h[i]=r[i].value,x[i]=r[i].index}const x=t.slice();return x[x.length-1]=c,[Object(r.buffer)(x,n,m),Object(r.buffer)(x,"int32",y)]}},function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(279);function o(e,t,n,o){const c=r.util.parseAxisParam(t,n)[0],l=[1,n[0],1];for(let i=0;i<c;i++)l[0]*=n[i];l[1]=n[c];for(let i=c+1;i<n.length;i++)l[2]*=n[i];const d={},h=new Int32Array(n[c]),f=new r.TensorBuffer(l,o,e),m=[],y=1===l[0]&&1===l[2];for(let i=0;i<n[c];i++){let element;if(y)element=e[i].toString();else{const e=[];for(let t=0;t<l[0];t++)for(let n=0;n<l[2];n++)e.push(f.get(t,i,n));element=e.join(",")}if(void 0!==d[element])h[i]=d[element];else{const e=Object.keys(d).length;d[element]=e,h[i]=e,m.push(i)}}const x=l.slice();x[1]=Object.keys(d).length;const v=new r.TensorBuffer(x,o);m.forEach(((e,i)=>{for(let t=0;t<l[0];t++)for(let n=0;n<l[2];n++)v.set(f.get(t,e,n),t,i,n)}));const O=n.slice();return O[c]=x[1],{outputValues:v.values,outputShape:O,indices:h}}},function(e,t,n){"use strict";(function(e){var r=n(414),o=n(415),c=n(416);function l(){return h.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function d(e,t){if(l()<t)throw new RangeError("Invalid typed array length");return h.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=h.prototype:(null===e&&(e=new h(t)),e.length=t),e}function h(e,t,n){if(!(h.TYPED_ARRAY_SUPPORT||this instanceof h))return new h(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return y(this,e)}return f(this,e,t,n)}function f(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);h.TYPED_ARRAY_SUPPORT?(e=t).__proto__=h.prototype:e=x(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!h.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|O(t,n),o=(e=d(e,r)).write(t,n);o!==r&&(e=e.slice(0,o));return e}(e,t,n):function(e,t){if(h.isBuffer(t)){var n=0|v(t.length);return 0===(e=d(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(r=t.length)!=r?d(e,0):x(e,t);if("Buffer"===t.type&&c(t.data))return x(e,t.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function m(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function y(e,t){if(m(t),e=d(e,t<0?0:0|v(t)),!h.TYPED_ARRAY_SUPPORT)for(var i=0;i<t;++i)e[i]=0;return e}function x(e,t){var n=t.length<0?0:0|v(t.length);e=d(e,n);for(var i=0;i<n;i+=1)e[i]=255&t[i];return e}function v(e){if(e>=l())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+l().toString(16)+" bytes");return 0|e}function O(e,t){if(h.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return X(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return Y(e).length;default:if(r)return X(e).length;t=(""+t).toLowerCase(),r=!0}}function k(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return M(this,t,n);case"utf8":case"utf-8":return R(this,t,n);case"ascii":return F(this,t,n);case"latin1":case"binary":return D(this,t,n);case"base64":return A(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function w(b,e,t){var i=b[e];b[e]=b[t],b[t]=i}function I(e,t,n,r,o){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(o)return-1;n=e.length-1}else if(n<0){if(!o)return-1;n=0}if("string"==typeof t&&(t=h.from(t,r)),h.isBuffer(t))return 0===t.length?-1:S(e,t,n,r,o);if("number"==typeof t)return t&=255,h.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):S(e,[t],n,r,o);throw new TypeError("val must be string, number or Buffer")}function S(e,t,n,r,o){var i,c=1,l=e.length,d=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;c=2,l/=2,d/=2,n/=2}function h(e,i){return 1===c?e[i]:e.readUInt16BE(i*c)}if(o){var f=-1;for(i=n;i<l;i++)if(h(e,i)===h(t,-1===f?0:i-f)){if(-1===f&&(f=i),i-f+1===d)return f*c}else-1!==f&&(i-=i-f),f=-1}else for(n+d>l&&(n=l-d),i=n;i>=0;i--){for(var m=!0,y=0;y<d;y++)if(h(e,i+y)!==h(t,y)){m=!1;break}if(m)return i}return-1}function N(e,t,n,r){n=Number(n)||0;var o=e.length-n;r?(r=Number(r))>o&&(r=o):r=o;var c=t.length;if(c%2!=0)throw new TypeError("Invalid hex string");r>c/2&&(r=c/2);for(var i=0;i<r;++i){var l=parseInt(t.substr(2*i,2),16);if(isNaN(l))return i;e[n+i]=l}return i}function T(e,t,n,r){return Z(X(t,e.length-n),e,n,r)}function j(e,t,n,r){return Z(function(e){for(var t=[],i=0;i<e.length;++i)t.push(255&e.charCodeAt(i));return t}(t),e,n,r)}function C(e,t,n,r){return j(e,t,n,r)}function $(e,t,n,r){return Z(Y(t),e,n,r)}function E(e,t,n,r){return Z(function(e,t){for(var n,r,o,c=[],i=0;i<e.length&&!((t-=2)<0);++i)r=(n=e.charCodeAt(i))>>8,o=n%256,c.push(o),c.push(r);return c}(t,e.length-n),e,n,r)}function A(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function R(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,c,l,d,h=e[i],f=null,m=h>239?4:h>223?3:h>191?2:1;if(i+m<=n)switch(m){case 1:h<128&&(f=h);break;case 2:128==(192&(o=e[i+1]))&&(d=(31&h)<<6|63&o)>127&&(f=d);break;case 3:o=e[i+1],c=e[i+2],128==(192&o)&&128==(192&c)&&(d=(15&h)<<12|(63&o)<<6|63&c)>2047&&(d<55296||d>57343)&&(f=d);break;case 4:o=e[i+1],c=e[i+2],l=e[i+3],128==(192&o)&&128==(192&c)&&128==(192&l)&&(d=(15&h)<<18|(63&o)<<12|(63&c)<<6|63&l)>65535&&d<1114112&&(f=d)}null===f?(f=65533,m=1):f>65535&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=m}return function(e){var t=e.length;if(t<=_)return String.fromCharCode.apply(String,e);var n="",i=0;for(;i<t;)n+=String.fromCharCode.apply(String,e.slice(i,i+=_));return n}(r)}t.Buffer=h,t.SlowBuffer=function(e){+e!=e&&(e=0);return h.alloc(+e)},t.INSPECT_MAX_BYTES=50,h.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=l(),h.poolSize=8192,h._augment=function(e){return e.__proto__=h.prototype,e},h.from=function(e,t,n){return f(null,e,t,n)},h.TYPED_ARRAY_SUPPORT&&(h.prototype.__proto__=Uint8Array.prototype,h.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&h[Symbol.species]===h&&Object.defineProperty(h,Symbol.species,{value:null,configurable:!0})),h.alloc=function(e,t,n){return function(e,t,n,r){return m(t),t<=0?d(e,t):void 0!==n?"string"==typeof r?d(e,t).fill(n,r):d(e,t).fill(n):d(e,t)}(null,e,t,n)},h.allocUnsafe=function(e){return y(null,e)},h.allocUnsafeSlow=function(e){return y(null,e)},h.isBuffer=function(b){return!(null==b||!b._isBuffer)},h.compare=function(a,b){if(!h.isBuffer(a)||!h.isBuffer(b))throw new TypeError("Arguments must be Buffers");if(a===b)return 0;for(var e=a.length,t=b.length,i=0,n=Math.min(e,t);i<n;++i)if(a[i]!==b[i]){e=a[i],t=b[i];break}return e<t?-1:t<e?1:0},h.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},h.concat=function(e,t){if(!c(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return h.alloc(0);var i;if(void 0===t)for(t=0,i=0;i<e.length;++i)t+=e[i].length;var n=h.allocUnsafe(t),r=0;for(i=0;i<e.length;++i){var o=e[i];if(!h.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,r),r+=o.length}return n},h.byteLength=O,h.prototype._isBuffer=!0,h.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var i=0;i<e;i+=2)w(this,i,i+1);return this},h.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var i=0;i<e;i+=4)w(this,i,i+3),w(this,i+1,i+2);return this},h.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var i=0;i<e;i+=8)w(this,i,i+7),w(this,i+1,i+6),w(this,i+2,i+5),w(this,i+3,i+4);return this},h.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?R(this,0,e):k.apply(this,arguments)},h.prototype.equals=function(b){if(!h.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||0===h.compare(this,b)},h.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},h.prototype.compare=function(e,t,n,r,o){if(!h.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),t<0||n>e.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&t>=n)return 0;if(r>=o)return-1;if(t>=n)return 1;if(this===e)return 0;for(var c=(o>>>=0)-(r>>>=0),l=(n>>>=0)-(t>>>=0),d=Math.min(c,l),f=this.slice(r,o),m=e.slice(t,n),i=0;i<d;++i)if(f[i]!==m[i]){c=f[i],l=m[i];break}return c<l?-1:l<c?1:0},h.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},h.prototype.indexOf=function(e,t,n){return I(this,e,t,n,!0)},h.prototype.lastIndexOf=function(e,t,n){return I(this,e,t,n,!1)},h.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var o=this.length-t;if((void 0===n||n>o)&&(n=o),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var c=!1;;)switch(r){case"hex":return N(this,e,t,n);case"utf8":case"utf-8":return T(this,e,t,n);case"ascii":return j(this,e,t,n);case"latin1":case"binary":return C(this,e,t,n);case"base64":return $(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,t,n);default:if(c)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),c=!0}},h.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var _=4096;function F(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function D(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function M(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var o="",i=t;i<n;++i)o+=K(e[i]);return o}function P(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}function L(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function B(e,t,n,r,o,c){if(!h.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>o||t<c)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function z(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function V(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255}function W(e,t,n,r,o,c){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function U(e,t,n,r,c){return c||W(e,0,n,4),o.write(e,t,n,r,23,4),n+4}function G(e,t,n,r,c){return c||W(e,0,n,8),o.write(e,t,n,r,52,8),n+8}h.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e),h.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=h.prototype;else{var o=t-e;n=new h(o,void 0);for(var i=0;i<o;++i)n[i]=this[i+e]}return n},h.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var r=this[e],o=1,i=0;++i<t&&(o*=256);)r+=this[e+i]*o;return r},h.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var r=this[e+--t],o=1;t>0&&(o*=256);)r+=this[e+--t]*o;return r},h.prototype.readUInt8=function(e,t){return t||L(e,1,this.length),this[e]},h.prototype.readUInt16LE=function(e,t){return t||L(e,2,this.length),this[e]|this[e+1]<<8},h.prototype.readUInt16BE=function(e,t){return t||L(e,2,this.length),this[e]<<8|this[e+1]},h.prototype.readUInt32LE=function(e,t){return t||L(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},h.prototype.readUInt32BE=function(e,t){return t||L(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},h.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var r=this[e],o=1,i=0;++i<t&&(o*=256);)r+=this[e+i]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*t)),r},h.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||L(e,t,this.length);for(var i=t,r=1,o=this[e+--i];i>0&&(r*=256);)o+=this[e+--i]*r;return o>=(r*=128)&&(o-=Math.pow(2,8*t)),o},h.prototype.readInt8=function(e,t){return t||L(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},h.prototype.readInt16LE=function(e,t){t||L(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt16BE=function(e,t){t||L(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt32LE=function(e,t){return t||L(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},h.prototype.readInt32BE=function(e,t){return t||L(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},h.prototype.readFloatLE=function(e,t){return t||L(e,4,this.length),o.read(this,e,!0,23,4)},h.prototype.readFloatBE=function(e,t){return t||L(e,4,this.length),o.read(this,e,!1,23,4)},h.prototype.readDoubleLE=function(e,t){return t||L(e,8,this.length),o.read(this,e,!0,52,8)},h.prototype.readDoubleBE=function(e,t){return t||L(e,8,this.length),o.read(this,e,!1,52,8)},h.prototype.writeUIntLE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||B(this,e,t,n,Math.pow(2,8*n)-1,0);var o=1,i=0;for(this[t]=255&e;++i<n&&(o*=256);)this[t+i]=e/o&255;return t+n},h.prototype.writeUIntBE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||B(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+n},h.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,1,255,0),h.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},h.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,!0),t+2},h.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,!1),t+2},h.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):V(this,e,t,!0),t+4},h.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):V(this,e,t,!1),t+4},h.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var o=Math.pow(2,8*n-1);B(this,e,t,n,o-1,-o)}var i=0,c=1,sub=0;for(this[t]=255&e;++i<n&&(c*=256);)e<0&&0===sub&&0!==this[t+i-1]&&(sub=1),this[t+i]=(e/c>>0)-sub&255;return t+n},h.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var o=Math.pow(2,8*n-1);B(this,e,t,n,o-1,-o)}var i=n-1,c=1,sub=0;for(this[t+i]=255&e;--i>=0&&(c*=256);)e<0&&0===sub&&0!==this[t+i+1]&&(sub=1),this[t+i]=(e/c>>0)-sub&255;return t+n},h.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,1,127,-128),h.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},h.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,!0),t+2},h.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,!1),t+2},h.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,4,2147483647,-2147483648),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):V(this,e,t,!0),t+4},h.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||B(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):V(this,e,t,!1),t+4},h.prototype.writeFloatLE=function(e,t,n){return U(this,e,t,!0,n)},h.prototype.writeFloatBE=function(e,t,n){return U(this,e,t,!1,n)},h.prototype.writeDoubleLE=function(e,t,n){return G(this,e,t,!0,n)},h.prototype.writeDoubleBE=function(e,t,n){return G(this,e,t,!1,n)},h.prototype.copy=function(e,t,n,r){if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;i>=0;--i)e[i+t]=this[i+n];else if(o<1e3||!h.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},h.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var code=e.charCodeAt(0);code<256&&(e=code)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!h.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var i;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(i=t;i<n;++i)this[i]=e;else{var o=h.isBuffer(e)?e:X(new h(e,r).toString()),c=o.length;for(i=0;i<n-t;++i)this[i+t]=o[i%c]}return this};var H=/[^+\/0-9A-Za-z-_]/g;function K(e){return e<16?"0"+e.toString(16):e.toString(16)}function X(e,t){var n;t=t||1/0;for(var r=e.length,o=null,c=[],i=0;i<r;++i){if((n=e.charCodeAt(i))>55295&&n<57344){if(!o){if(n>56319){(t-=3)>-1&&c.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&c.push(239,191,189);continue}o=n;continue}if(n<56320){(t-=3)>-1&&c.push(239,191,189),o=n;continue}n=65536+(o-55296<<10|n-56320)}else o&&(t-=3)>-1&&c.push(239,191,189);if(o=null,n<128){if((t-=1)<0)break;c.push(n)}else if(n<2048){if((t-=2)<0)break;c.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;c.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;c.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return c}function Y(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(H,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function Z(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,n(39))},function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},function(e,t,n){var r=n(420),o=n(421),c=n(422),l=n(423),d=n(424),h=n(425),f=n(426);f.alea=r,f.xor128=o,f.xorwow=c,f.xorshift7=l,f.xor4096=d,f.tychei=h,e.exports=f},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return o}));const r="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:void 0!==e?e:e=>e();function o(){return new Promise((e=>r((()=>e()))))}}).call(this,n(193).setImmediate)},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return R})),n.d(t,"i",(function(){return F})),n.d(t,"c",(function(){return D})),n.d(t,"f",(function(){return M})),n.d(t,"e",(function(){return B})),n.d(t,"d",(function(){return z})),n.d(t,"k",(function(){return W})),n.d(t,"g",(function(){return U})),n.d(t,"h",(function(){return G})),n.d(t,"j",(function(){return H})),n.d(t,"b",(function(){return K}));var r=n(279),o=n(428),c=n(344),l=n(290),d=n(429),h=n(430),f=n(431),m=n(432),y=n(433),x=n(434),v=n(435),O=n(436),k=n(437),w=n(438),I=n(439),S=n(440),N=n(441),T=n(442),j=n(443),C=n(444),$=n(445),E=n(446),A=n(447);class R{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[d,h,f,m,y,x,v,O,k,w,I,S,N,T,j,C,$,E,A].map((e=>e.json)));this.opMappers=e.reduce(((map,e)=>(map[e.tfOpName]=e,map)),{})}transformGraph(e,t={}){const n=e.node,r=[],o=[],c=[],d=n.reduce(((map,e)=>(map[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?r.push(map[e.name]):"Const"===e.op?o.push(map[e.name]):null!=e.input&&0!==e.input.length||c.push(map[e.name]),map)),{});let h=[];const f=[];let m={},y={};null!=t&&(m=this.mapSignatureEntries(t.inputs),y=this.mapSignatureEntries(t.outputs));const x=Object.keys(d);x.forEach((e=>{const t=d[e];t.inputNames.forEach(((e,n)=>{const[r,,o]=Object(l.b)(e),c=d[r];if(null!=c.outputs){const e=c.outputs.indexOf(o);if(-1!==e){const o=`${r}:${e}`;t.inputNames[n]=o}}t.inputs.push(c),c.children.push(t)}))})),0===Object.keys(y).length?x.forEach((e=>{const t=d[e];0===t.children.length&&f.push(t)})):Object.keys(y).forEach((e=>{const[t]=Object(l.b)(e),n=d[t];null!=n&&(n.signatureKey=y[e],f.push(n))})),Object.keys(m).length>0?Object.keys(m).forEach((e=>{const[t]=Object(l.b)(e),n=d[t];n&&(n.signatureKey=m[e],h.push(n))})):h=r;let v={};null!=e.library&&null!=e.library.function&&(v=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const O={nodes:d,inputs:h,outputs:f,weights:o,placeholders:r,signature:t,functions:v};return c.length>0&&(O.initNodes=c),O}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=Object(c.b)(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((input=>input.startsWith("^")?input.slice(1):input)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((map,param)=>(map[param.name]={type:param.type,inputIndexStart:param.start,inputIndexEnd:param.end},map)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((map,param)=>{const t=param.type;let n;switch(param.type){case"string":n=F(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=F(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"string[]":n=G(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=G(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"number":n=M(e.attr,param.tfName,param.defaultValue||0),void 0===n&&param.tfDeprecatedName&&(n=M(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"number[]":n=U(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=U(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool":n=D(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=D(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"bool[]":n=K(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=K(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape":n=W(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=W(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"shape[]":n=H(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=H(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype":n=B(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=B(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"dtype[]":n=z(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=z(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"func":n=L(e.attr,param.tfName,param.defaultValue),void 0===n&&param.tfDeprecatedName&&(n=L(e.attr,param.tfDeprecatedName,param.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${param.type} for op: ${e.op}`)}return map[param.name]={value:n,type:t},map}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((map,e)=>(map[e.name]=this.mapNode(e),"Const"===e.op&&n.push(map[e.name]),map)),{}));const o=[],c=[];e.signature.inputArg.forEach((e=>{const[t]=Object(l.b)(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:P(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,o.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[o,,c]=Object(l.b)(e),d=r[o];if(null!=d.outputs){const e=d.outputs.indexOf(c);if(-1!==e){const r=`${o}:${e}`;t.inputNames[n]=r}}t.inputs.push(d),d.children.push(t)}))}));const d=e.ret;e.signature.outputArg.forEach((output=>{const[e,t]=Object(l.b)(d[output.name]),n=r[e];null!=n&&(n.defaultOutput=t,c.push(n))}));const h=this.mapArgsToSignature(e);return{nodes:r,inputs:o,outputs:c,weights:n,placeholders:[],signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((map,e)=>(map[e.name]=this.mapArgToTensorInfo(e),map)),{}),outputs:e.signature.outputArg.reduce(((map,t)=>(map[t.name]=this.mapArgToTensorInfo(t,e.ret),map)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function _(s,t){const n=Array.isArray(s)?String.fromCharCode.apply(null,s):function(text){const t=Object(r.env)().global;if(void 0!==t.atob)return t.atob(text);if(void 0!==e)return new e(text,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(s);return t?n:n.toLowerCase()}function F(e,t,n,r=!1){const param=e[t];return null!=param?_(param.s,r):n}function D(e,t,n){const param=e[t];return param?param.b:n}function M(e,t,n){const param=e[t]||{},r=null!=param.i?param.i:null!=param.f?param.f:n;return"number"==typeof r?r:parseInt(r,10)}function P(e){switch("string"==typeof e&&(e=o.a[e]),e){case o.a.DT_FLOAT:case o.a.DT_HALF:return"float32";case o.a.DT_INT32:case o.a.DT_INT64:case o.a.DT_INT8:case o.a.DT_UINT8:return"int32";case o.a.DT_BOOL:return"bool";case o.a.DT_DOUBLE:return"float32";case o.a.DT_STRING:return"string";default:return null}}function L(e,t,n){const param=e[t];return param&&param.func?param.func.name:n}function B(e,t,n){const param=e[t];return param&&param.type?P(param.type):n}function z(e,t,n){const param=e[t];return param&&param.list&&param.list.type?param.list.type.map((e=>P(e))):n}function V(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function W(e,t,n){const param=e[t];return param&&param.shape?V(param.shape):n}function U(e,t,n){const param=e[t];return param?((param.list.f&&param.list.f.length?param.list.f:param.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function G(e,t,n,r=!1){const param=e[t];return param&&param.list&&param.list.s?param.list.s.map((e=>_(e,r))):n}function H(e,t,n){const param=e[t];return param&&param.list&&param.list.shape?param.list.shape.map((e=>V(e))):n}function K(e,t,n){const param=e[t];return param&&param.list&&param.list.b?param.list.b:n}}).call(this,n(405).Buffer)},function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(279),o=n(317);function c(e,t,n="float32"){if("complex64"===n){const n=c(e,t,"float32"),r=c(e,t,"float32");return Object(o.a)({inputs:{real:n,imag:r},backend:e})}const l=r.util.makeZerosTypedArray(r.util.sizeFromShape(t),n);return e.makeTensorInfo(t,n,l)}},,function(e,t,n){!function(e,a,t){"use strict";const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class n{constructor(e,a){this.modelPath=a||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(e)}/model.json`}getPrefix(e){return"lite_mobilenet_v2"===e?`ssd${e}`:`ssd_${e}`}async load(){this.model=await a.loadGraphModel(this.modelPath);const e=t.zeros([1,300,300,3],"int32"),i=await this.model.executeAsync(e);await Promise.all(i.map((e=>e.data()))),i.map((e=>e.dispose())),e.dispose()}async infer(e,a,i){const n=t.tidy((()=>(e instanceof t.Tensor||(e=t.browser.fromPixels(e)),t.expandDims(e)))),s=n.shape[1],r=n.shape[2],o=await this.model.executeAsync(n),c=o[0].dataSync(),l=o[1].dataSync();n.dispose(),t.dispose(o);const[p,d]=this.calculateMaxScores(c,o[0].shape[1],o[0].shape[2]),h=t.getBackend();"webgl"===t.getBackend()&&t.setBackend("cpu");const f=t.tidy((()=>{const e=t.tensor2d(l,[o[1].shape[1],o[1].shape[3]]);return t.image.nonMaxSuppression(e,p,a,i,i)})),m=f.dataSync();return f.dispose(),h!==t.getBackend()&&t.setBackend(h),this.buildDetectedObjects(r,s,l,p,m,d)}buildDetectedObjects(e,a,t,n,s,r){const o=s.length,c=[];for(let l=0;l<o;l++){const o=[];for(let e=0;e<4;e++)o[e]=t[4*s[l]+e];const p=o[0]*a,d=o[1]*e,h=o[2]*a,f=o[3]*e;o[0]=d,o[1]=p,o[2]=f-d,o[3]=h-p,c.push({bbox:o,class:i[r[s[l]]+1].displayName,score:n[s[l]]})}return c}calculateMaxScores(e,a,t){const i=[],n=[];for(let s=0;s<a;s++){let a=Number.MIN_VALUE,r=-1;for(let i=0;i<t;i++)e[s*t+i]>a&&(a=e[s*t+i],r=i);i[s]=a,n[s]=r}return[i,n]}async detect(e,a=20,t=.5){return this.infer(e,a,t)}dispose(){null!=this.model&&this.model.dispose()}}e.ObjectDetection=n,e.load=async function(e={}){if(null==t)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const a=e.base||"lite_mobilenet_v2",i=e.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(a))throw new Error(`ObjectDetection constructed with invalid base model ${a}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const s=new n(a,i);return await s.load(),s},e.version="2.2.2",Object.defineProperty(e,"__esModule",{value:!0})}(t,n(452),n(279))},function(e,t){e.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function o(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=o;var c={},l={};function d(e,t){var n,r,o;return t?(o=0<=(e>>>=0)&&e<256)&&(r=l[e])?r:(n=f(e,(0|e)<0?-1:0,!0),o&&(l[e]=n),n):(o=-128<=(e|=0)&&e<128)&&(r=c[e])?r:(n=f(e,e<0?-1:0,!1),o&&(c[e]=n),n)}function h(e,t){if(isNaN(e))return t?S:I;if(t){if(e<0)return S;if(e>=O)return $}else{if(e<=-k)return E;if(e+1>=k)return C}return e<0?h(-e,t).neg():f(e%v|0,e/v|0,t)}function f(e,t,n){return new r(e,t,n)}r.fromInt=d,r.fromNumber=h,r.fromBits=f;var m=Math.pow;function y(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return I;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var p;if((p=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===p)return y(e.substring(1),t,n).neg();for(var r=h(m(n,8)),o=I,i=0;i<e.length;i+=8){var c=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+c),n);if(c<8){var d=h(m(n,c));o=o.mul(d).add(h(l))}else o=(o=o.mul(r)).add(h(l))}return o.unsigned=t,o}function x(e,t){return"number"==typeof e?h(e,t):"string"==typeof e?y(e,t):f(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=y,r.fromValue=x;var v=4294967296,O=v*v,k=O/2,w=d(1<<24),I=d(0);r.ZERO=I;var S=d(0,!0);r.UZERO=S;var N=d(1);r.ONE=N;var T=d(1,!0);r.UONE=T;var j=d(-1);r.NEG_ONE=j;var C=f(-1,2147483647,!1);r.MAX_VALUE=C;var $=f(-1,-1,!0);r.MAX_UNSIGNED_VALUE=$;var E=f(0,-2147483648,!1);r.MIN_VALUE=E;var A=r.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*v+(this.low>>>0):this.high*v+(this.low>>>0)},A.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(E)){var t=h(e),div=this.div(t),n=div.mul(t).sub(this);return div.toString(e)+n.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=h(m(e,6),this.unsigned),o=this,c="";;){var l=o.div(r),d=(o.sub(l.mul(r)).toInt()>>>0).toString(e);if((o=l).isZero())return d+c;for(;d.length<6;)d="0"+d;c=""+d+c}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(E)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},A.isZero=function(){return 0===this.high&&0===this.low},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return 1==(1&this.low)},A.isEven=function(){return 0==(1&this.low)},A.equals=function(e){return o(e)||(e=x(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},A.eq=A.equals,A.notEquals=function(e){return!this.eq(e)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(e){return this.comp(e)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(e){return this.comp(e)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(e){return this.comp(e)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(e){return this.comp(e)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(e){if(o(e)||(e=x(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(E)?E:this.not().add(N)},A.neg=A.negate,A.add=function(e){o(e)||(e=x(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,c=65535&this.low,l=e.high>>>16,d=65535&e.high,h=e.low>>>16,m=0,y=0,v=0,O=0;return v+=(O+=c+(65535&e.low))>>>16,y+=(v+=r+h)>>>16,m+=(y+=n+d)>>>16,m+=t+l,f((v&=65535)<<16|(O&=65535),(m&=65535)<<16|(y&=65535),this.unsigned)},A.subtract=function(e){return o(e)||(e=x(e)),this.add(e.neg())},A.sub=A.subtract,A.multiply=function(e){if(this.isZero())return I;if(o(e)||(e=x(e)),n)return f(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return I;if(this.eq(E))return e.isOdd()?E:I;if(e.eq(E))return this.isOdd()?E:I;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(w)&&e.lt(w))return h(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,c=this.low>>>16,l=65535&this.low,d=e.high>>>16,m=65535&e.high,y=e.low>>>16,v=65535&e.low,O=0,k=0,S=0,N=0;return S+=(N+=l*v)>>>16,k+=(S+=c*v)>>>16,S&=65535,k+=(S+=l*y)>>>16,O+=(k+=r*v)>>>16,k&=65535,O+=(k+=c*y)>>>16,k&=65535,O+=(k+=l*m)>>>16,O+=t*v+r*y+c*m+l*d,f((S&=65535)<<16|(N&=65535),(O&=65535)<<16|(k&=65535),this.unsigned)},A.mul=A.multiply,A.divide=function(e){if(o(e)||(e=x(e)),e.isZero())throw Error("division by zero");var t,r,c;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?f((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?S:I;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return S;if(e.gt(this.shru(1)))return T;c=S}else{if(this.eq(E))return e.eq(N)||e.eq(j)?E:e.eq(E)?N:(t=this.shr(1).div(e).shl(1)).eq(I)?e.isNegative()?N:j:(r=this.sub(e.mul(t)),c=t.add(r.div(e)));if(e.eq(E))return this.unsigned?S:I;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();c=I}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var l=Math.ceil(Math.log(t)/Math.LN2),d=l<=48?1:m(2,l-48),y=h(t),v=y.mul(e);v.isNegative()||v.gt(r);)v=(y=h(t-=d,this.unsigned)).mul(e);y.isZero()&&(y=N),c=c.add(y),r=r.sub(v)}return c},A.div=A.divide,A.modulo=function(e){return o(e)||(e=x(e)),n?f((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return f(~this.low,~this.high,this.unsigned)},A.and=function(e){return o(e)||(e=x(e)),f(this.low&e.low,this.high&e.high,this.unsigned)},A.or=function(e){return o(e)||(e=x(e)),f(this.low|e.low,this.high|e.high,this.unsigned)},A.xor=function(e){return o(e)||(e=x(e)),f(this.low^e.low,this.high^e.high,this.unsigned)},A.shiftLeft=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?f(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):f(0,this.low<<e-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?f(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):f(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(e){if(o(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?f(this.low>>>e|t<<32-e,t>>>e,this.unsigned):f(32===e?t:t>>>e-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?f(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:f(this.low,this.high,!0)},A.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},A.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},function(e,t,n){"use strict";t.byteLength=function(e){var t=d(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,i,n=d(e),r=n[0],l=n[1],h=new c(function(e,t,n){return 3*(t+n)/4-n}(0,r,l)),f=0,m=l>0?r-4:r;for(i=0;i<m;i+=4)t=o[e.charCodeAt(i)]<<18|o[e.charCodeAt(i+1)]<<12|o[e.charCodeAt(i+2)]<<6|o[e.charCodeAt(i+3)],h[f++]=t>>16&255,h[f++]=t>>8&255,h[f++]=255&t;2===l&&(t=o[e.charCodeAt(i)]<<2|o[e.charCodeAt(i+1)]>>4,h[f++]=255&t);1===l&&(t=o[e.charCodeAt(i)]<<10|o[e.charCodeAt(i+1)]<<4|o[e.charCodeAt(i+2)]>>2,h[f++]=t>>8&255,h[f++]=255&t);return h},t.fromByteArray=function(e){for(var t,n=e.length,o=n%3,c=[],l=16383,i=0,d=n-o;i<d;i+=l)c.push(h(e,i,i+l>d?d:i+l));1===o?(t=e[n-1],c.push(r[t>>2]+r[t<<4&63]+"==")):2===o&&(t=(e[n-2]<<8)+e[n-1],c.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return c.join("")};for(var r=[],o=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,l=code.length;i<l;++i)r[i]=code[i],o[code.charCodeAt(i)]=i;function d(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function h(e,t,n){for(var o,c,output=[],i=t;i<n;i+=3)o=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(255&e[i+2]),output.push(r[(c=o)>>18&63]+r[c>>12&63]+r[c>>6&63]+r[63&c]);return output.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,r,o){var c,l,d=8*o-r-1,h=(1<<d)-1,f=h>>1,m=-7,i=n?o-1:0,y=n?-1:1,s=e[t+i];for(i+=y,c=s&(1<<-m)-1,s>>=-m,m+=d;m>0;c=256*c+e[t+i],i+=y,m-=8);for(l=c&(1<<-m)-1,c>>=-m,m+=r;m>0;l=256*l+e[t+i],i+=y,m-=8);if(0===c)c=1-f;else{if(c===h)return l?NaN:1/0*(s?-1:1);l+=Math.pow(2,r),c-=f}return(s?-1:1)*l*Math.pow(2,c-r)},t.write=function(e,t,n,r,o,c){var l,d,h,f=8*c-o-1,m=(1<<f)-1,y=m>>1,rt=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,i=r?0:c-1,x=r?1:-1,s=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(d=isNaN(t)?1:0,l=m):(l=Math.floor(Math.log(t)/Math.LN2),t*(h=Math.pow(2,-l))<1&&(l--,h*=2),(t+=l+y>=1?rt/h:rt*Math.pow(2,1-y))*h>=2&&(l++,h/=2),l+y>=m?(d=0,l=m):l+y>=1?(d=(t*h-1)*Math.pow(2,o),l+=y):(d=t*Math.pow(2,y-1)*Math.pow(2,o),l=0));o>=8;e[n+i]=255&d,i+=x,d/=256,o-=8);for(l=l<<o|d,f+=o;f>0;e[n+i]=255&l,i+=x,l/=256,f-=8);e[n+i-x]|=128*s}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(e,t,n){"use strict";(function(e){var t=n(294);const r=()=>n(418);let o;class c{constructor(){this.util=n(419),this.textEncoder=new this.util.TextEncoder}fetch(path,e){return null!=Object(t.c)().global.fetch?Object(t.c)().global.fetch(path,e):(null==o&&(o=r()),o(path,e))}now(){const time=e.hrtime();return 1e3*time[0]+time[1]/1e6}encode(text,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(text)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}Object(t.c)().get("IS_NODE")&&!Object(t.c)().get("IS_BROWSER")&&Object(t.c)().setPlatform("node",new c)}).call(this,n(133))},,,function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t,n=this,r=(t=4022871197,function(data){data=String(data);for(var i=0;i<data.length;i++){var e=.02519603282416938*(t+=data.charCodeAt(i));e-=t=e>>>0,t=(e*=t)>>>0,t+=4294967296*(e-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function d(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function h(e,t){var n=new l(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.alea=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function d(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function h(e,t){var n=new l(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.xor128=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function d(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function h(e,t){var n=new l(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.xorwow=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],n=(e^=e>>>7)^e<<24,n^=(e=r[i+1&7])^e>>>10,n^=(e=r[i+3&7])^e>>>3,n^=(e=r[i+4&7])^e<<7,e=r[i+7&7],n^=(e^=e<<13)^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function d(e,t){return t.x=e.x.slice(),t.i=e.i,t}function h(e,t){null==e&&(e=+new Date);var n=new l(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.xorshift7=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,i=t.i;return t.w=r=r+1640531527|0,n=o[i+34&127],e=o[i=i+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[i]=n^e,t.i=i,n+(r^r>>>16)|0},function(e,t){var n,r,i,o,c,l=[],d=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,d=Math.max(d,t.length)),i=0,o=-32;o<d;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(c=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(c=c+1640531527|0,i=0==(n=l[127&o]^=r+c)?i+1:0);for(i>=128&&(l[127&(t&&t.length||0)]=-1),i=127,o=512;o>0;--o)r=l[i+34&127],n=l[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,l[i]=r^n;e.w=c,e.X=l,e.i=i}(t,e)}function d(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function h(e,t){null==e&&(e=+new Date);var n=new l(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.xor4096=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){(function(e){var r;!function(e,o,c){function l(e){var t=this,n="";t.next=function(){var b=t.b,e=t.c,n=t.d,a=t.a;return b=b<<25^b>>>7^e,e=e-n|0,n=n<<24^n>>>8^a,a=a-b|0,t.b=b=b<<20^b>>>12^e,t.c=e=e-n|0,t.d=n<<16^e>>>16^a,t.a=a-b|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function d(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function h(e,t){var n=new l(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&d(r,n),o.state=function(){return d(n,{})}),o}o&&o.exports?o.exports=h:n(305)&&n(332)?void 0===(r=function(){return h}.call(t,n,t,o))||(o.exports=r):this.tychei=h}(0,e,n(305))}).call(this,n(331)(e))},function(e,t,n){var r;!function(o,c,l){var d,h=256,f=l.pow(h,6),m=l.pow(2,52),y=2*m,mask=255;function x(e,t,n){var r=[],x=w(k((t=1==t?{entropy:!0}:t||{}).entropy?[e,I(c)]:null==e?function(){try{var e;return d&&(e=d.randomBytes)?e=e(h):(e=new Uint8Array(h),(o.crypto||o.msCrypto).getRandomValues(e)),I(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,I(c)]}}():e,3),r),S=new v(r),N=function(){for(var e=S.g(6),t=f,n=0;e<m;)e=(e+n)*h,t*=h,n=S.g(1);for(;e>=y;)e/=2,t/=2,n>>>=1;return(e+n)/t};return N.int32=function(){return 0|S.g(4)},N.quick=function(){return S.g(4)/4294967296},N.double=N,w(I(S.S),c),(t.pass||n||function(e,t,n,r){return r&&(r.S&&O(r,S),e.state=function(){return O(S,{})}),n?(l.random=e,t):e})(N,x,"global"in t?t.global:this==l,t.state)}function v(e){var t,n=e.length,r=this,i=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);i<h;)s[i]=i++;for(i=0;i<h;i++)s[i]=s[o=mask&o+e[i%n]+(t=s[i])],s[o]=t;(r.g=function(e){for(var t,n=0,i=r.i,o=r.j,s=r.S;e--;)t=s[i=mask&i+1],n=n*h+s[mask&(s[i]=s[o=mask&o+t])+(s[o]=t)];return r.i=i,r.j=o,n})(h)}function O(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function k(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(k(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function w(e,t){for(var n,r=e+"",o=0;o<r.length;)t[mask&o]=mask&(n^=19*t[mask&o])+r.charCodeAt(o++);return I(t)}function I(a){return String.fromCharCode.apply(0,a)}if(w(l.random(),c),e.exports){e.exports=x;try{d=n(427)}catch(e){}}else void 0===(r=function(){return x}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},,function(e,t,n){"use strict";var r,o;n.d(t,"a",(function(){return r})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(r||(r={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(o||(o={}))},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]},function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]},,,function(e,t,n){"use strict";n.r(t),n.d(t,"version_webgl",(function(){return Rn})),n.d(t,"MathBackendWebGL",(function(){return An})),n.d(t,"setWebGLContext",(function(){return h})),n.d(t,"GPGPUContext",(function(){return kt})),n.d(t,"gpgpu_util",(function(){return o})),n.d(t,"webgl_util",(function(){return r})),n.d(t,"forceHalfFloat",(function(){return _n})),n.d(t,"webgl",(function(){return Fn}));var r={};n.r(r),n.d(r,"callAndCheck",(function(){return I})),n.d(r,"canBeRepresented",(function(){return S})),n.d(r,"getWebGLErrorMessage",(function(){return N})),n.d(r,"getExtensionOrThrow",(function(){return T})),n.d(r,"createVertexShader",(function(){return j})),n.d(r,"createFragmentShader",(function(){return C})),n.d(r,"logShaderSourceAndInfoLog",(function(){return E})),n.d(r,"createProgram",(function(){return A})),n.d(r,"linkProgram",(function(){return R})),n.d(r,"validateProgram",(function(){return _})),n.d(r,"createStaticVertexBuffer",(function(){return F})),n.d(r,"createStaticIndexBuffer",(function(){return D})),n.d(r,"getNumChannels",(function(){return M})),n.d(r,"createTexture",(function(){return P})),n.d(r,"validateTextureSize",(function(){return L})),n.d(r,"createFramebuffer",(function(){return B})),n.d(r,"bindVertexBufferToProgramAttribute",(function(){return z})),n.d(r,"bindTextureUnit",(function(){return V})),n.d(r,"unbindTextureUnit",(function(){return W})),n.d(r,"getProgramUniformLocationOrThrow",(function(){return U})),n.d(r,"getProgramUniformLocation",(function(){return G})),n.d(r,"bindTextureToProgramUniformSampler",(function(){return H})),n.d(r,"bindCanvasToFramebuffer",(function(){return K})),n.d(r,"bindColorTextureToFramebuffer",(function(){return X})),n.d(r,"unbindColorTextureFromFramebuffer",(function(){return Y})),n.d(r,"validateFramebuffer",(function(){return Z})),n.d(r,"getFramebufferErrorMessage",(function(){return Q})),n.d(r,"getBatchDim",(function(){return te})),n.d(r,"getRowsCols",(function(){return ne})),n.d(r,"getShapeAs3D",(function(){return re})),n.d(r,"getTextureShapeFromLogicalShape",(function(){return ae})),n.d(r,"isReshapeFree",(function(){return oe})),n.d(r,"getWebGLMaxTextureSize",(function(){return ce})),n.d(r,"resetMaxTextureSize",(function(){return le})),n.d(r,"resetMaxTexturesInShader",(function(){return de})),n.d(r,"getMaxTexturesInShader",(function(){return pe})),n.d(r,"getWebGLDisjointQueryTimerVersion",(function(){return he})),n.d(r,"hasExtension",(function(){return fe})),n.d(r,"isWebGLVersionEnabled",(function(){return me})),n.d(r,"isCapableOfRenderingToFloatTexture",(function(){return be})),n.d(r,"isDownloadFloatTextureEnabled",(function(){return ge})),n.d(r,"isWebGLFenceEnabled",(function(){return xe})),n.d(r,"assertNotComplex",(function(){return ve}));var o={};n.r(o),n.d(o,"createVertexShader",(function(){return Qe})),n.d(o,"createVertexBuffer",(function(){return Je})),n.d(o,"createIndexBuffer",(function(){return et})),n.d(o,"getInternalFormatForFloat32MatrixTexture",(function(){return nt})),n.d(o,"createFloat32MatrixTexture",(function(){return at})),n.d(o,"getInternalFormatForFloat16MatrixTexture",(function(){return st})),n.d(o,"createFloat16MatrixTexture",(function(){return ot})),n.d(o,"getInternalFormatForUnsignedBytesMatrixTexture",(function(){return it})),n.d(o,"createUnsignedBytesMatrixTexture",(function(){return ut})),n.d(o,"getInternalFormatForPackedMatrixTexture",(function(){return ct})),n.d(o,"createPackedMatrixTexture",(function(){return lt})),n.d(o,"getInternalFormatForFloat16PackedMatrixTexture",(function(){return pt})),n.d(o,"createFloat16PackedMatrixTexture",(function(){return ht})),n.d(o,"bindVertexProgramAttributeStreams",(function(){return ft})),n.d(o,"uploadDenseMatrixToTexture",(function(){return mt})),n.d(o,"uploadPixelDataToTexture",(function(){return bt})),n.d(o,"createBufferFromOutputTexture",(function(){return gt})),n.d(o,"downloadFloat32MatrixFromBuffer",(function(){return yt})),n.d(o,"downloadByteEncodedFloatMatrixFromOutputTexture",(function(){return xt})),n.d(o,"downloadPackedMatrixFromBuffer",(function(){return vt})),n.d(o,"downloadMatrixFromPackedOutputTexture",(function(){return Ot}));var c=n(279);const l={},d={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function h(e,t){l[e]=t}function f(e,t){if(!(e in l)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const canvas=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;canvas.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete l[e]}),!1),Object(c.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(d.failIfMajorPerformanceCaveat=!1);if(1===e)return canvas.getContext("webgl",d)||canvas.getContext("experimental-webgl",d);return canvas.getContext("webgl2",d)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;l[e]=n}const n=l[e];return null==n||n.isContextLost()?(delete l[e],f(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),l[e])}var m,y,x;function v(e,t){return[t,e]}function O(e){const t=c.util.sizeFromShape(e),n=Math.ceil(t/4);return c.util.sizeToSquarishShape(n)}function k(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function w(e,t){const n=e;let r,o,l,d,h,f,m,y,x,v;return 2===Object(c.env)().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,l=n.RGBA16F,d=n.RGBA32F,h=n.RED,m=4,y=1,x=n.HALF_FLOAT,v=n.FLOAT,f=n.RGBA8):(r=e.RGBA,o=e.RGBA,l=e.RGBA,d=n.RGBA,h=e.RGBA,m=4,y=4,x=null!=t?t.HALF_FLOAT_OES:null,v=e.FLOAT,f=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:l,internalFormatPackedFloat:d,textureFormatFloat:h,downloadTextureFormat:f,downloadUnpackNumChannels:m,defaultNumChannels:y,textureTypeHalfFloat:x,textureTypeFloat:v}}function I(e,t){const n=t();return Object(c.env)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+N(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(m||(m={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(y||(y={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(x||(x={}));function S(e){return!!(Object(c.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function N(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function T(e,t){return J(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function j(e,t){const n=J(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(I(e,(()=>e.shaderSource(n,t))),I(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function C(e,t){const n=J(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(I(e,(()=>e.shaderSource(n,t))),I(e,(()=>e.compileShader(n))),Object(c.env)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw E(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const $=/ERROR: [0-9]+:([0-9]+):/g;function E(e,t){const n=$.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],o=e.split("\n"),l=o.length.toString().length+2,d=o.map(((line,e)=>c.util.rightPad((e+1).toString(),l)+line));let h=0;for(let i=0;i<d.length;i++)h=Math.max(d[i].length,h);const f=d.slice(0,r-1),m=d.slice(r-1,r),y=d.slice(r);console.log(f.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${c.util.rightPad(m[0],h)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(y.join("\n"))}function A(e){return J(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function R(e,t){if(I(e,(()=>e.linkProgram(t))),!Object(c.env)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function _(e,t){if(I(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function F(e,data){const t=J(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return I(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,t))),I(e,(()=>e.bufferData(e.ARRAY_BUFFER,data,e.STATIC_DRAW))),t}function D(e,data){const t=J(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return I(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t))),I(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,data,e.STATIC_DRAW))),t}function M(){return 2===Object(c.env)().getNumber("WEBGL_VERSION")?1:4}function P(e){return J(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function L(e,t){const n=Object(c.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function B(e){return J(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function z(e,t,n,r,o,c,l){const d=e.getAttribLocation(t,n);return-1!==d&&(I(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),I(e,(()=>e.vertexAttribPointer(d,o,e.FLOAT,!1,c,l))),I(e,(()=>e.enableVertexAttribArray(d))),!0)}function V(e,t,n){ee(e,n),I(e,(()=>e.activeTexture(e.TEXTURE0+n))),I(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function W(e,t){ee(e,t),I(e,(()=>e.activeTexture(e.TEXTURE0+t))),I(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function U(e,t,n){return J(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function G(e,t,n){return e.getUniformLocation(t,n)}function H(e,t,n,r){I(e,(()=>V(e,t,r))),I(e,(()=>e.uniform1i(n,r)))}function K(e){I(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),I(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),I(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function X(e,t,n){I(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),I(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Y(e,t){I(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),I(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Z(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Q(e,t))}function Q(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function J(e,t,n){const r=I(e,(()=>t()));if(null==r)throw new Error(n);return r}function ee(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function te(e,t=2){return c.util.sizeFromShape(e.slice(0,e.length-t))}function ne(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function re(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[te(e),...ne(e)]),t}function ae(e,t=!1){let n=Object(c.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,i)=>i>=e.length-2?c.util.nearestLargerEven(e[i]):e[i]))).length&&(e=[2,e[0]])),2!==e.length){const t=c.util.squeezeShape(e);e=t.newShape}let r=c.util.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=te(e);let n=2,o=2;return e.length&&([n,o]=ne(e)),r=t*(n/2)*(o/2),c.util.sizeToSquarishShape(r).map((e=>2*e))}return c.util.sizeToSquarishShape(r)}function se(e){return e%2==0}function oe(e,t){if(e=e.slice(-2),t=t.slice(-2),c.util.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(se(n)&&se(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&se(e[0])&&se(t[0])}let ie,ue;function ce(e){if(null==ie){const t=f(e);ie=t.getParameter(t.MAX_TEXTURE_SIZE)}return ie}function le(){ie=null}function de(){ue=null}function pe(e){if(null==ue){const t=f(e);ue=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ue)}function he(e){if(0===e)return 0;let t;const n=f(e);return t=fe(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:fe(n,"EXT_disjoint_timer_query")?1:0,t}function fe(e,t){return null!=e.getExtension(t)}function me(e){try{if(null!=f(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function be(e){if(0===e)return!1;const t=f(e);if(1===e){if(!fe(t,"OES_texture_float"))return!1}else if(!fe(t,"EXT_color_buffer_float"))return!1;return ye(t)}function ge(e){if(0===e)return!1;const t=f(e);if(1!==e){if(fe(t,"EXT_color_buffer_float"))return ye(t);const e="EXT_color_buffer_half_float";if(fe(t,e)){const n=t.getExtension(e);return function(e,t){const n=w(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const o=1,c=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,o,c,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const l=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,l),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const d=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(l),d}(t,n)}return!1}if(!fe(t,"OES_texture_float"))return!1;if(!fe(t,"WEBGL_color_buffer_float"))return!1;return ye(t)}function ye(e){const t=w(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}function xe(e){if(2!==e)return!1;return null!=f(e).fenceSync}function ve(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&c.util.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const Oe=Object(c.env)();function ke(){let e,t,n,r,o,output,l,d,h,f;return 2===Object(c.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",o="texture",output="outputColor",l="out vec4 outputColor;",d="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",h="",f="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",o="texture2D",output="gl_FragColor",l="",d="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",h="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",f="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:o,output:output,defineOutput:l,defineSpecialNaN:d,defineSpecialInf:h,defineRound:f}}function we(e,t,n="index"){const r=c.util.computeStrides(t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / ${t}`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${t}`:`index -= ${e[i]} * ${t}`};`)).join("")}function Ie(e,t,n="index"){const r=c.util.computeStrides(t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / outShapeStrides[${i}]`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`};`)).join("")}function Se(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),o=new Array(n-1);o[n-2]=r[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}(e.map(((e,i)=>i)),t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / ${r[i]}`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`};`)).join("")}function Ne(e){const t=c.util.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Oe.registerFlag("HAS_WEBGL",(()=>Oe.getNumber("WEBGL_VERSION")>0)),Oe.registerFlag("WEBGL_VERSION",(()=>me(2)?2:me(1)?1:0)),Oe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),Oe.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===Oe.get("WEBGL_VERSION"))),Oe.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),Oe.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),Oe.registerFlag("WEBGL_PACK",(()=>Oe.getBool("HAS_WEBGL"))),Oe.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_CLIP",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_PACK_REDUCE",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_LAZILY_UNPACK",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_CONV_IM2COL",(()=>Oe.getBool("WEBGL_PACK"))),Oe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>ce(Oe.getNumber("WEBGL_VERSION")))),Oe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>pe(Oe.getNumber("WEBGL_VERSION")))),Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=Oe.getNumber("WEBGL_VERSION");return 0===e?0:he(e)})),Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>Oe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!c.device_util.isMobile())),Oe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>be(Oe.getNumber("WEBGL_VERSION")))),Oe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!Oe.getBool("WEBGL_FORCE_F16_TEXTURES")&&Oe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),Oe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>ge(Oe.getNumber("WEBGL_VERSION")))),Oe.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>xe(Oe.getNumber("WEBGL_VERSION")))),Oe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>Oe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),Oe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),Oe.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>c.device_util.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),Oe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),Oe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),Oe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),Oe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),Oe.registerFlag("WEBGL_EXP_CONV",(()=>!1)),Oe.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>Oe.getBool("IS_TEST")));const Te="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:je}=c.backend_util;function Ce(e,t,n){const r=[];if(e.forEach((e=>{const t=c.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=Be(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const o=r.join("\n"),l=e.map((e=>function(e,t,n=!1,r){let o="";o+=n?Ee(e,r):$e(e,r);const l=e.shapeInfo.logicalShape,d=t.logicalShape;l.length<=d.length&&(o+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",l=e.shapeInfo.logicalShape.length,d=t.logicalShape.length,h=je(e.shapeInfo.logicalShape,t.logicalShape),f=Le(d),m=d-l;let y;const x=["x","y","z","w","u","v"];y=0===l?"":d<2&&h.length>=1?"coords = 0;":h.map((e=>`coords.${x[e+m]} = 0;`)).join("\n");let v="";v=d<2&&l>0?"coords":e.shapeInfo.logicalShape.map(((s,i)=>`coords.${x[i+m]}`)).join(", ");let output="return outputValue;";const O=1===c.util.sizeFromShape(e.shapeInfo.logicalShape),k=1===c.util.sizeFromShape(t.logicalShape);if(1!==l||O||k){if(O&&!k)output=1===d?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(h.length){const e=l-2,t=l-1;h.indexOf(e)>-1&&h.indexOf(t)>-1?output="return vec4(outputValue.x);":h.indexOf(e)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(t)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}}else output="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${f} coords = getOutputCoords();\n      ${y}\n      vec4 outputValue = get${r}(${v});\n      ${output}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",l=t.texShape,d=e.shapeInfo.texShape,h=e.shapeInfo.logicalShape.length,f=t.logicalShape.length;if(!e.shapeInfo.isUniform&&h===f&&null==e.shapeInfo.flatOffset&&c.util.arraysEqual(d,l))return`\n      float ${o}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const m=Le(f),y=je(e.shapeInfo.logicalShape,t.logicalShape),x=f-h;let v;const O=["x","y","z","w","u","v"];v=0===h?"":f<2&&y.length>=1?"coords = 0;":y.map((e=>`coords.${O[e+x]} = 0;`)).join("\n");let k="";k=f<2&&h>0?"coords":e.shapeInfo.logicalShape.map(((s,i)=>`coords.${O[i+x]}`)).join(", ");return`\n    float ${o}() {\n      ${m} coords = getOutputCoords();\n      ${v}\n      return get${r}(${k});\n    }\n  `}(e,t));return o}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),d=t.texShape,h=ke(),f=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(h);let m,y,x=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Ae}\n    ${Re}\n    ${_e}\n  `}(h);t.isPacked?(m=function(e,t,n){switch(e.length){case 0:return De();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(c.util.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[2]/2),c=o*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${c};\n      index -= b * ${c};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[e.length-1]/2),c=o*Math.ceil(e[e.length-2]/2);let l=c,d="",h="b, r, c";for(let b=2;b<e.length-1;b++)l*=e[e.length-b-1],d=`\n      int b${b} = index / ${l};\n      index -= b${b} * ${l};\n    `+d,h=`b${b}, `+h;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${d}\n\n      int b = index / ${c};\n      index -= b * ${c};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${e.length}(${h});\n    }\n  `}(e,t,n)}}(t.logicalShape,d,n.enableShapeUniforms),y=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(h)):(m=function(e,t,n){switch(e.length){case 0:return De();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(c.util.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ie(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=we(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ie(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=we(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=we(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=we(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,d,n.enableShapeUniforms),y=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(h)),n.packedInputs&&(x+=Fe);return[x,f,y,o,m,l,n.userCode].join("\n")}function $e(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[o,c]=e.shapeInfo.texShape;if(1===o&&1===c)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const l=Me(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${l});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[d,h]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${d}, ${h}, ${l});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Pe(e)}\n      }\n    `;const o=e.shapeInfo.texShape,c=o[0],l=o[1];if(1===l&&1===c)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const d=Me(n);if(1===l)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${d}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${d}) + 0.5) / ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===c)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${d}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${d}) + 0.5) / ${l}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${d});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${c}, ${l}, index + ${d});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),l=e.shapeInfo.texShape;if(null!=l&&c.util.arraysEqual(n,l)){if(t)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=l[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${l[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:d,keptDims:h}=c.util.squeezeShape(n),f=d;if(f.length<n.length){const n=["row","col"];return`\n      ${$e(ze(e,f),t)}\n      float ${o}(int row, int col) {\n        return ${o}(${Ve(n,h)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Pe(e)}\n      }\n    `;const m=l[0],y=l[1],x=Me(r);if(1===y)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${m}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===m)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${y}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${x};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${x};\n    vec2 uv = uvFromFlat(${m}, ${y}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),l=n[1]*n[2],d=n[2],{newShape:h,keptDims:f}=c.util.squeezeShape(n),m=h;if(m.length<n.length){const n=["row","col","depth"];return`\n        ${$e(ze(e,m),t)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${Ve(n,f)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${l}, ${d}, 1)));\n        ${Pe(e)}\n      }\n    `;const y=e.shapeInfo.texShape,x=y[0],v=y[1],O=e.shapeInfo.flatOffset;if(v===l&&null==O)return t?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${d}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${v}.0, ${x}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(v===d&&null==O)return t?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}.0, ${x}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const k=Me(r);if(t)return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${l} + col * ${d} + depth + ${k};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${l} + col * ${d} + depth + ${k};\n        vec2 uv = uvFromFlat(${x}, ${v}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),l=n[3],d=n[2]*l,h=n[1]*d,{newShape:f,keptDims:m}=c.util.squeezeShape(n);if(f.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${$e(ze(e,f),t)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${Ve(n,m)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${h}, ${d}, ${l}, 1)));\n        ${Pe(e)}\n      }\n    `;const y=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,v=x[0],O=x[1],k=`int stride2 = ${r}Shape[3];`,w=`int stride1 = ${r}Shape[2] * stride2;`,I=`int stride0 = ${r}Shape[1] * stride1;`;if(O===h&&null==y)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${k}\n        ${w}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${d}, ${l}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${O}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(O===l&&null==y)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${O}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const S=Me(r);if(t)return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${k}\n      ${w}\n      ${I}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${S});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${d} +\n          depth * ${l} + depth2;\n      vec2 uv = uvFromFlat(${v}, ${O}, index + ${S});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[4],l=t[3]*o,d=t[2]*l,h=t[1]*d,{newShape:f,keptDims:m}=c.util.squeezeShape(t);if(f.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${$e(ze(e,f))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Ve(t,m)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${h}, ${d}, ${l}, ${o})) +\n          depth3;\n        ${Pe(e)}\n      }\n    `;const y=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,v=x[0],O=x[1];if(O===h&&null==y)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${d}, ${l}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${O}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(O===o&&null==y)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${O}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const k=Me(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${h} + col * ${d} + depth * ${l} +\n          depth2 * ${o} + depth3 + ${k};\n      vec2 uv = uvFromFlat(${v}, ${O}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:o,keptDims:l}=c.util.squeezeShape(t);if(o.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${$e(ze(e,o))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Ve(t,l)});\n      }\n    `}const d=t[5],h=t[4]*d,f=t[3]*h,m=t[2]*f,y=t[1]*m;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${y}, ${m}, ${f}, ${h})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${d}, 1)));\n        ${Pe(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,O=v[0],k=v[1];if(k===y&&null==x)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${m}, ${f}, ${h}, ${d})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${k}.0, ${O}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(k===d&&null==x)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${k}.0, ${O}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const w=Me(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${y} + col * ${m} + depth * ${f} +\n          depth2 * ${h} + depth3 * ${d} + depth4 + ${w};\n      vec2 uv = uvFromFlat(${O}, ${k}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Ee(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ke();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,c=ke();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${l[0]}, ${l[1]}, index);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),l=e.shapeInfo.texShape,d=l[0],h=l[1],f=ke();if(null!=l&&c.util.arraysEqual(n,l))return t?`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${f.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${d}.0);\n\n        return ${f.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${f.texture2D}(${r}, uv);\n    }\n  `;const m=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],y=Math.ceil(n[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${y}, ${m[0]}, ${m[1]}, row, col);\n      return ${f.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,l=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];if(1===n[0]){const r=[1,2],c=["b","row","col"];return`\n        ${Ee(ze(e,n.slice(1)),t)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${Ve(c,r)});\n        }\n      `}const d=ke();if(t)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `;const h=l[0],f=l[1],m=Math.ceil(n[2]/2),y=m*Math.ceil(n[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${h}, ${f}, ${y}, ${m}, b, row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=ke();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${n}, uv);\n    }\n  `;const c=e.shapeInfo.logicalShape,l=c.length,d=e.shapeInfo.texShape,h=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],f=h[0],m=h[1],y=Math.ceil(c[l-1]/2);let x=y*Math.ceil(c[l-2]/2),v="int b, int row, int col",O=`b * ${x} + (row / 2) * ${y} + (col / 2)`;for(let b=2;b<l-1;b++)v=`int b${b}, `+v,x*=c[l-b-1],O=`b${b} * ${x} + `+O;return`\n    vec4 ${r}(${v}) {\n      int index = ${O};\n      int texR = index / ${m};\n      int texC = index - texR * ${m};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}, ${f});\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const Ae="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Re="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Fe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function De(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Me(e){return`offset${e}`}function Pe(e){const t=e.name,n=c.util.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Le(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Be(e,t,n){const{newShape:r,keptDims:o}=c.util.squeezeShape(t),l=t.length,d=e&&3===l&&1===t[0],h=d?t.slice(1):r,f=!e&&l>1&&!c.util.arraysEqual(t,n)&&r.length<l||d;return{useSqueezeShape:f,uniformShape:f?h:t,keptDims:o}}function ze(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Ve(e,t){return t.map((t=>e[t])).join(", ")}function We(e,t,n){const r={},o={},l={},d=[];let h,f,m,y=null,x=null;x=e.getUniformLocation(n,"NAN",!1),1===Object(c.env)().getNumber("WEBGL_VERSION")&&(y=e.getUniformLocation(n,"INFINITY",!1));const v=!1;for(let i=0;i<t.variableNames.length;i++){const c=t.variableNames[i];r[c]=e.getUniformLocation(n,c,v),r[`offset${c}`]=e.getUniformLocation(n,`offset${c}`,v),t.enableShapeUniforms&&(o[`${c}Shape`]=e.getUniformLocation(n,`${c}Shape`,v),l[`${c}TexShape`]=e.getUniformLocation(n,`${c}TexShape`,v))}return t.enableShapeUniforms&&(h=e.getUniformLocation(n,"outShape",v),m=e.getUniformLocation(n,"outShapeStrides",v),f=e.getUniformLocation(n,"outTexShape",v)),t.customUniforms&&t.customUniforms.forEach(((t,i)=>{d[i]=e.getUniformLocation(n,t.name,v)})),{uniformLocations:r,customUniformLocations:d,infLoc:y,nanLoc:x,inShapesLocations:o,inTexShapesLocations:l,outShapeLocation:h,outShapeStridesLocation:m,outTexShapeLocation:f}}function Ue(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((s,i)=>{const e=s.logicalShape,input=t[i],n=input.shape;if(!c.util.arraysEqual(e,n))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${e} and ${n} must match`);if(s.isUniform&&input.isUniform)return;const r=s.texShape,o=input.isUniform?null:input.texData.texShape;if(!c.util.arraysEqual(r,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${r} and ${o} must match`)}))}function Ge(e){return Object(c.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class He{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=m.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ke();this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ie(["r","c","d"],e):we(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class qe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=m.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ke();this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ie(["r","c","d"],e):we(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Ke{constructor(e){this.variableNames=["A"],this.outTexUsage=y.DOWNLOAD;const t=ke();this.outputShape=e,this.userCode=`\n      ${Te}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Xe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=y.DOWNLOAD;const t=ke();this.outputShape=e,this.userCode=`\n      ${Te}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Ye{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=ke();this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length);let output="result";t&&(output="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ne(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `}}class Ze{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=ke();this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length);let r="",output="result";t&&(output="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let col=0;col<=1;col++){const o=2*t+col;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${col};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ne(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${output};\n        }\n    `}}function Qe(e){const t=ke();return j(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Je(e){return F(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function et(e){return D(e,new Uint16Array([0,1,2,2,1,3]))}function tt(e,t,n,r,o,l){L(t,n);const d=P(e),h=e.TEXTURE_2D;return I(e,(()=>e.bindTexture(h,d))),I(e,(()=>e.texParameteri(h,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),I(e,(()=>e.texParameteri(h,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),I(e,(()=>e.texParameteri(h,e.TEXTURE_MIN_FILTER,e.NEAREST))),I(e,(()=>e.texParameteri(h,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Object(c.env)().getNumber("WEBGL_VERSION")?I(e,(()=>e.texImage2D(h,0,r,t,n,0,o,l,null))):I(e,(()=>e.texStorage2D(h,1,r,t,n))),I(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:d,texShape:[n,t]}}function nt(e){return e.internalFormatFloat}function at(e,t,n,r){const[o,c]=v(t,n);return tt(e,o,c,nt(r),r.textureFormatFloat,e.FLOAT)}function st(e){return e.internalFormatHalfFloat}function ot(e,t,n,r){const[o,c]=v(t,n);return tt(e,o,c,st(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function it(e){return e.downloadTextureFormat}function ut(e,t,n,r){const[o,c]=v(t,n);return tt(e,o,c,it(r),e.RGBA,e.UNSIGNED_BYTE)}function ct(e){return e.internalFormatPackedFloat}function lt(e,t,n,r){const[o,c]=k(t,n);return tt(e,o,c,ct(r),e.RGBA,e.FLOAT)}function pt(e){return e.internalFormatPackedHalfFloat}function ht(e,t,n,r){const[o,c]=k(t,n);return tt(e,o,c,pt(r),e.RGBA,r.textureTypeHalfFloat)}function ft(e,t,n){I(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));return z(e,t,"clipSpacePos",n,3,20,0)&&z(e,t,"uv",n,2,20,12)}function mt(e,t,n,r,data,o){let l,d,h;I(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),data instanceof Uint8Array?(l=new Uint8Array(n*r*4),d=e.UNSIGNED_BYTE,h=e.RGBA):(l=new Float32Array(n*r*4),d=e.FLOAT,h=o.internalFormatPackedFloat),l.set(data),2===Object(c.env)().getNumber("WEBGL_VERSION")?I(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,d,l))):I(e,(()=>e.texImage2D(e.TEXTURE_2D,0,h,n,r,0,e.RGBA,d,l))),I(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function bt(e,t,n){I(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Object(c.env)().getNumber("WEBGL_VERSION")?I(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):I(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Object(c.env)().getNumber("WEBGL_VERSION")?I(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):I(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),I(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function gt(e,t,n,r){const o=e.createBuffer();I(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o)));const c=16*t*n;return I(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,c,e.STREAM_READ))),I(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),I(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),o}function yt(e,t,n){const r=e,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function xt(e,t,n,r){const[o,c]=v(t,n),l=new Uint8Array(t*n*4);return I(e,(()=>e.readPixels(0,0,o,c,r.downloadTextureFormat,e.UNSIGNED_BYTE,l))),new Float32Array(l.buffer)}function vt(e,t,n,r,o,c,l,d){const h=e,f=new Float32Array(function(e,t){const[n,r]=k(e,t);return n*r*4}(c,l));return h.bindBuffer(h.PIXEL_PACK_BUFFER,t),h.getBufferSubData(h.PIXEL_PACK_BUFFER,0,f),h.bindBuffer(h.PIXEL_PACK_BUFFER,null),f}function Ot(e,t,n){const r=new Float32Array(t*n*4);return I(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}class kt{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Object(c.env)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,h(t,e)):this.gl=f(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Object(c.env)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=T(this.gl,e),fe(this.gl,t))this.textureHalfFloatExtension=T(this.gl,t);else if(Object(c.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),fe(this.gl,r))this.colorBufferHalfFloatExtension=T(this.gl,r);else if(Object(c.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",fe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!fe(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Je(this.gl),this.indexBuffer=et(this.gl),this.framebuffer=B(this.gl),this.textureConfig=w(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(c.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;I(e,(()=>e.finish())),I(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),I(e,(()=>e.deleteFramebuffer(this.framebuffer))),I(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),I(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),I(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),at(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),ot(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),ut(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),bt(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,data){this.throwIfDisposed(),mt(this.gl,e,t,n,data,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ht(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),lt(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Y(this.gl,this.framebuffer),this.outputTexture=null),I(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>xt(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,o,c){return vt(this.gl,e,0,0,0,o,c,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return yt(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=gt(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(c.env)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(o,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=o}else Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Ot(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=Qe(t));const n=A(t);return I(t,(()=>t.attachShader(n,this.vertexShader))),I(t,(()=>t.attachShader(n,e))),R(t,n),this.debug&&_(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=ft(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&I(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&_(this.gl,this.program),I(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?U(this.gl,e,t):G(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),I(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),H(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,o]=k(t,n);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&_(this.gl,this.program),Z(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),I(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),I(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=T(this.gl,2===Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await c.util.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let i=0;for(;i<e.length;++i){if(!e[i]())break}return i-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let i=0;i<=e;++i){const{resolveFn:e}=this.itemsToPoll[i];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||c.util.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),X(this.gl,e,this.framebuffer),this.debug&&Z(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(X(this.gl,this.outputTexture,this.framebuffer),this.debug&&Z(this.gl)):Y(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;X(r,e,this.framebuffer),this.debug&&Z(r),this.outputTexture=e,I(r,(()=>r.viewport(0,0,t,n))),I(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),I(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}var wt=n(371);const{addImpl:It,bincountImpl:St,bincountReduceImpl:Nt,castImpl:Tt,ceilImpl:jt,concatImpl:Ct,equalImpl:$t,expImpl:Et,expm1Impl:At,floorImpl:Rt,gatherNdImpl:_t,gatherV2Impl:Ft,greaterImpl:Dt,greaterEqualImpl:Mt,lessImpl:Pt,lessEqualImpl:Lt,linSpaceImpl:Bt,logImpl:zt,maxImpl:Vt,maximumImpl:Wt,minimumImpl:Ut,multiplyImpl:Gt,negImpl:Ht,notEqualImpl:qt,prodImpl:Kt,raggedTensorToTensorImpl:Xt,rangeImpl:Yt,rsqrtImpl:Zt,scatterImpl:Qt,sigmoidImpl:Jt,simpleAbsImpl:en,sliceImpl:tn,sparseFillEmptyRowsImpl:nn,sparseReshapeImpl:rn,sparseSegmentReductionImpl:an,sqrtImpl:sn,stridedSliceImpl:on,stringNGramsImpl:un,stringSplitImpl:cn,stringToHashBucketFastImpl:ln,subImpl:dn,tileImpl:pn,topKImpl:hn,transposeImpl:fn,uniqueImpl:mn}=wt;function bn(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function gn(e,t){return 1===t?[e]:bn(e,t)}class yn{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ge(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=gn("rc",this.rank),t=Le(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),output=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let col=0;col<=1;col++){let r=`${0===n?"r":"rp1"}, ${0===col?"c":"cp1"}`;for(let t=2;t<this.rank;t++)r=`${e[e.length-1-t]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let i=this.rank-2;i<this.rank;i++)t+=`${e[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),col=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${col};\n      bool rEdge = rp1 >= ${n};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class xn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length);let n="";for(let i=0;i<4;i++){let e="thisRC = rc;";i%2==1&&(e+="thisRC.z += 1;"),i>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}var r,o;this.userCode=`\n      ${r=t,o=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${o?Se(["r","c","d"],"inputShape"):we(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Ne(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class vn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=kn(t,n),o=wn(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const c=On(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();const e=this.freeTextures[o].shift();return this.usedTextures[o].push(e),e}let l;return r===x.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===x.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===x.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===x.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===x.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),l}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const o=kn(n,r),l=wn(t,o,r);l in this.freeTextures||(this.freeTextures[l]=[]);const d=On(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),h=Object(c.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==h&&this._numBytesAllocated>h?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=d):(this.freeTextures[l].push(e),this.numFreeTextures++,this._numBytesFree+=d),this.numUsedTextures--;const f=this.usedTextures[l],m=f.indexOf(e);if(m<0)throw new Error("Cannot release a texture that was never provided by this texture manager");f.splice(m,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function On(e,t,n,r,o){const c=function(e,t){switch(e){case x.PACKED_2X2_FLOAT32:return ct(t);case x.PACKED_2X2_FLOAT16:return pt(t);case x.UNPACKED_FLOAT32:return nt(t);case x.UNPACKED_FLOAT16:return st(t);case x.PACKED_4X1_UNSIGNED_BYTE:return it(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let l;if(o){const[t,n]=k(e[0],e[1]);l=t*n}else{const[t,n]=v(e[0],e[1]);l=t*n}const d=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,c);return l*d}function kn(e,t){if(e===y.UPLOAD)return x.PACKED_2X2_FLOAT32;if(e===y.RENDER||null==e)return function(e){return Object(c.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?x.PACKED_2X2_FLOAT32:x.UNPACKED_FLOAT32:e?x.PACKED_2X2_FLOAT16:x.UNPACKED_FLOAT16}(t);if(e===y.DOWNLOAD||e===y.PIXELS)return x.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function wn(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class In{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Sn="return abs(x);";const Nn="return x;";class Tn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class jn{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length);const t=e.length,n=gn("rc",t),r=Le(t),o=function(e,t){if(1===e)return"rc";let n="";for(let i=0;i<e;i++)n+=t[i],i<e-1&&(n+=",");return n}(t,n),c=n.slice(-2),l=t<=1?"rc":`vec2(${c.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}const Cn=c.kernel_impls.whereImpl,$n={};const En=Object(c.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class An extends c.KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(c.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof kt)t=e;else{const n=f(Object(c.env)().getNumber("WEBGL_VERSION"),e);t=new kt(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=f(Object(c.env)().getNumber("WEBGL_VERSION"));t=new kt(e),this.binaryCache=((n=Object(c.env)().getNumber("WEBGL_VERSION"))in $n||($n[n]={}),$n[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new vn(this.gpgpu),this.numMBBeforeWarning=null==Object(c.env)().global.screen?1024:Object(c.env)().global.screen.height*Object(c.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new c.DataStorage(this,Object(c.engine)())}nextDataId(){return An.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Object(c.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(c.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:y.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,o){if(Object(c.env)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:y.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:o,slice:l,shape:d,isPacked:h}=t;if(null!=l){let t;t=h?new Tn(d,Nn):new In(d,Nn);const n=this.runWebGLProgram(t,[{dataId:e,shape:d,dtype:r}],r),data=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const f=null!=this.activeTimers;let m,y;if(f&&(m=c.util.now()),"complex64"===r){const e=this.readSync(o.real.dataId),t=this.readSync(o.imag.dataId);y=c.backend_util.mergeRealAndImagArrays(e,t)}else y=this.getValuesFromTexture(e);return f&&(this.downloadWaitMs+=c.util.now()-m),this.convertAndCacheOnCPU(e,y)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:o,dtype:l,complexTensorInfos:d,isPacked:h}=t;if(null!=o){let t;t=h?new Tn(r,Nn):new In(r,Nn);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:l}],l),data=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(e);if(Object(c.env)().getBool("DEBUG")&&!Object(c.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(c.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let f,m,y=null;if("complex64"!==l&&Object(c.env)().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(e);const t=this.texData.get(f.dataId);y=this.gpgpu.createBufferFromTexture(t.texture.texture,...O(r))}if(this.pendingRead.set(e,[]),"complex64"!==l&&await this.gpgpu.createAndWaitForFence(),"complex64"===l){const e=await Promise.all([this.read(d.real.dataId),this.read(d.imag.dataId)]),t=e[0],n=e[1];m=c.backend_util.mergeRealAndImagArrays(t,n)}else if(null==y)m=this.getValuesFromTexture(e);else{const e=c.util.sizeFromShape(r);m=this.gpgpu.downloadFloat32MatrixFromBuffer(y,e)}if(null!=f&&this.disposeIntermediateTensorInfo(f),null!=y){const e=this.gpgpu.gl;I(e,(()=>e.deleteBuffer(y)))}const x=this.convertAndCacheOnCPU(e,m),v=this.pendingRead.get(e);return this.pendingRead.delete(e),v.forEach((e=>e(x))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Object(c.engine)().removeDataId(e,this),this.pendingDeletes--),x}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:o,slice:l,dtype:d,isPacked:h,texture:f}=n;if("complex64"===d)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=l){let n;n=h?new Tn(o,Nn):new In(o,Nn);const r=this.runWebGLProgram(n,[{dataId:e,shape:o,dtype:d}],d),c=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),c}if(null==f)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const m=this.decode(e,t.customTexShape),y=Object(c.engine)().makeTensorFromTensorInfo(m),x=this.texData.get(m.dataId);return Object.assign({tensorRef:y},x.texture)}bufferSync(e){const data=this.readSync(e.dataId);if("string"===e.dtype)try{const t=data.map((e=>c.util.decodeString(e)));return Object(c.buffer)(e.shape,e.dtype,t)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(c.buffer)(e.shape,e.dtype,data)}checkNumericalProblems(e){if(null!=e)for(let i=0;i<e.length;i++){const t=e[i];if(!S(t)){if(Object(c.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${t} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${t} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),o=c.util.sizeFromShape(t);if(Object(c.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),c=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...O(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(n),c}const l=Object(c.env)().getBool("WEBGL_PACK")&&!0===r,d=l?re(t):t,h=l?new Xe(d):new Ke(d),output=this.runWebGLProgram(h,[{shape:d,dtype:n,dataId:e}],"float32"),f=this.texData.get(output.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture.texture,f.texShape[0],f.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(output),m}timerAvailable(){return Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=c.util.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),l=c.util.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const d={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);d.kernelMs=c.util.sum(e),d.getExtraProfileInfo=()=>e.map(((e,i)=>({name:l[i],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else d.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,d})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:c.util.now(),endMs:null}}endTimer(e){return Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=c.util.now(),e)}async getQueryTime(e){if(Object(c.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:o,isPacked:c,slice:l}=this.texData.get(e),d=l&&l.origDataId||e,h=this.dataRefCount.get(d);h>1?this.dataRefCount.set(d,h-1):(this.dataRefCount.delete(d),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,o,c)));const f=this.texData.get(e);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=En){return Object(c.env)().getBool("WEBGL_CPU_FORWARD")&&e.every((input=>null==this.texData.get(input.dataId).texture&&c.util.sizeFromShape(input.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){c.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Cn(e.shape,t)}packedUnaryOp(e,t,n){const r=new Tn(e.shape,t),o=this.compileAndRun(r,[e],n);return Object(c.engine)().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=en(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(c.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Sn,e.dtype);const t=new In(e.shape,Sn),n=this.compileAndRun(t,[e]);return Object(c.engine)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&c.util.isString(n[0])){const o=n.map((e=>c.util.encodeString(e)));r=this.write(o,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Object(c.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(input){const e=new jn(input.shape);return this.runWebGLProgram(e,[input],input.dtype)}packTensor(input){const e=new yn(input.shape);return this.runWebGLProgram(e,[input],input.dtype,null,!0)}packedReshape(input,e){const t=[te(input.shape),...ne(input.shape)],n={dtype:input.dtype,shape:t,dataId:input.dataId},r=[te(e),...ne(e)],o=new xn(r,t),c=[t],output=this.runWebGLProgram(o,[n],input.dtype,c,!0);return{dataId:output.dataId,shape:e,dtype:output.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:o,dtype:l}=n;if(null!=t){const e=c.util.sizeFromShape(o),n=t[0]*t[1]*4;c.util.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const d=re(o);let h;h=r?new qe(d):new He(d);const f=[null!=t?t:O(d)];return{dtype:l,shape:o,dataId:this.runWebGLProgram(h,[{shape:d,dtype:l,dataId:e}],l,f,!0,t).dataId}}runWebGLProgram(e,t,n,r,o=!1,l){const output=this.makeTensorInfo(e.outputShape,n),d=this.texData.get(output.dataId);if(e.packedOutput&&(d.isPacked=!0),e.outPackingScheme===m.DENSE){const t=null!=l?l:O(e.outputShape);d.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(d.usage=e.outTexUsage),0===c.util.sizeFromShape(output.shape))return d.values=c.util.getTypedArrayFromDType(output.dtype,0),output;const h=[],f=t.map((input=>{if("complex64"===input.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let t=this.texData.get(input.dataId);if(null==t.texture){if(!e.packedInputs&&c.util.sizeFromShape(input.shape)<=Object(c.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:input.shape,texData:null,isUniform:!0,uniformValues:t.values};e.packedInputs&&(t.isPacked=!0,t.shape=input.shape)}if(this.uploadToGPU(input.dataId),!!t.isPacked!=!!e.packedInputs)input=t.isPacked?this.unpackTensor(input):this.packTensor(input),h.push(input),t=this.texData.get(input.dataId);else if(t.isPacked&&!oe(t.shape,input.shape)){const e=input,n=input.shape;input.shape=t.shape,input=this.packedReshape(input,n),h.push(input),t=this.texData.get(input.dataId),e.shape=n}return{shape:input.shape,texData:t,isUniform:!1}}));this.uploadToGPU(output.dataId);const y={shape:output.shape,texData:d,isUniform:!1},x=function(e,t,output){let n="";t.concat(output).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:l,uniformShape:d,keptDims:h}=Be(e.packedInputs,t.shape,o);let f="",m="",y="";if(1===d.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];f=`${e[0]>1}_${e[1]>1}`}else if(2!==d.length||e.packedInputs){if(d.length>2&&!e.packedInputs){const e=c.util.computeStrides(d);y=`${e[0]===o[1]}_${e[e.length-1]===o[1]}`}}else m=`${d[0]>1}_${d[1]>1}`;const x=t.shape.length,v=2===d.length&&c.util.arraysEqual(t.shape,o),O=1===c.util.sizeFromShape(t.shape),k=c.backend_util.getBroadcastDims(t.shape,output.shape),w=!e.packedInputs&&x===output.shape.length&&c.util.arraysEqual(o,output.texData.texShape),I=e.packedInputs||d.length>2?"":`${o[0]>1}_${o[1]>1}`;n+=`${x}_${w}_${l?h:""}_${d.length}_${O}_${k}_${v}_${f}_${m}_${y}_${I}_${r}`}else{const e=t.isUniform?"uniform":t.texData.texShape;n+=`${t.shape}_${e}_${r}`}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+n+"_"+r+`${Object(c.env)().getNumber("WEBGL_VERSION")}`,o}(e,f,y),v=this.getAndSaveBinary(x,(()=>function(e,t,n,output){const r=n.map(((input,i)=>{const e={logicalShape:input.shape,texShape:input.isUniform?null:input.texData.texShape,isUniform:input.isUniform,isPacked:!input.isUniform&&input.texData.isPacked,flatOffset:null};return null!=input.texData&&null!=input.texData.slice&&input.texData.slice.flatOffset>0&&(e.flatOffset=input.texData.slice.flatOffset),{name:t.variableNames[i],shapeInfo:e}})),o=r.map((e=>e.shapeInfo)),l={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:!1,isPacked:output.texData.isPacked,flatOffset:null},source=Ce(r,l,t),d=C(e.gl,source),h=e.createProgram(d);return Object(c.env)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:d,source:source,webGLProgram:h,inShapeInfos:o,outShapeInfo:l,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:d,source:source,webGLProgram:h,inShapeInfos:o,outShapeInfo:l},We(e,t,h))}(this.gpgpu,e,f,y))),k=null!=this.activeTimers;let w;k&&(w=this.startTimer()),Object(c.env)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,output,r){t.program.enableShapeUniforms||(Ue(t.inShapeInfos,n),Ue([t.outShapeInfo],[output]));const o=output.texData.texture,l=output.texData.texShape;output.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,l[0],l[1]):e.setOutputMatrixTexture(o.texture,l[0],l[1]),e.setProgram(t.webGLProgram),1===Object(c.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((input,i)=>{const n=t.program.variableNames[i],r=t.uniformLocations[n],o=t.uniformLocations[`offset${n}`],l=t.inShapesLocations[`${n}Shape`],d=t.inTexShapesLocations[`${n}TexShape`];if(l){const{uniformShape:n}=Be(t.program.packedInputs,input.shape,input.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(l,new Int32Array(n));break;case 2:e.gl.uniform2iv(l,new Int32Array(n));break;case 3:e.gl.uniform3iv(l,new Int32Array(n));break;case 4:e.gl.uniform4iv(l,new Int32Array(n))}}if(d&&e.gl.uniform2i(d,input.texData.texShape[0],input.texData.texShape[1]),null!=r)if(input.isUniform)if(c.util.sizeFromShape(input.shape)<2)e.gl.uniform1f(r,input.uniformValues[0]);else{let t=input.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=input.texData.slice&&null!=o&&e.gl.uniform1i(o,input.texData.slice.flatOffset),e.setInputMatrixTexture(input.texData.texture.texture,r,i)}));const d=t.outShapeLocation;if(d)switch(output.shape.length){case 1:e.gl.uniform1iv(d,new Int32Array(output.shape));break;case 2:e.gl.uniform2iv(d,new Int32Array(output.shape));break;case 3:e.gl.uniform3iv(d,new Int32Array(output.shape));break;case 4:e.gl.uniform4iv(d,new Int32Array(output.shape))}if(t.outShapeStridesLocation){const n=c.util.computeStrides(output.shape);switch(output.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,output.texData.texShape[0],output.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach(((n,i)=>{const o=t.customUniformLocations[i],c=r[i];if("float"===n.type)e.gl.uniform1fv(o,c);else if("vec2"===n.type)e.gl.uniform2fv(o,c);else if("vec3"===n.type)e.gl.uniform3fv(o,c);else if("vec4"===n.type)e.gl.uniform4fv(o,c);else if("int"===n.type)e.gl.uniform1iv(o,c);else if("ivec2"===n.type)e.gl.uniform2iv(o,c);else if("ivec3"===n.type)e.gl.uniform3iv(o,c);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(o,c)}})),e.executeProgram()}(this.gpgpu,v,f,y,r),h.forEach((e=>this.disposeIntermediateTensorInfo(e))),k&&(w=this.endTimer(w),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(w)}));const I=Object(c.env)().get("WEBGL_FLUSH_THRESHOLD");if(I>0){const time=c.util.now();time-this.lastGlFlushTime>I&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=time)}if(!Object(c.env)().getBool("WEBGL_LAZILY_UNPACK")&&d.isPacked&&!1===o){const e=this.unpackTensor(output);return this.disposeIntermediateTensorInfo(output),e}return output}compileAndRun(e,t,n,r,o=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(c.env)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(c.tidy)((()=>{if(!Object(c.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(c.env)().getBool("DEBUG");Object(c.env)().set("DEBUG",!1);const t=this.abs(Object(c.scalar)(1e-8)).dataSync()[0];if(Object(c.env)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:o,texture:l,usage:d,isPacked:h}=t;if(null!=l)return;const f=null!=this.activeTimers;let m;f&&(m=c.util.now());let x=t.texShape;if(null==x&&(x=ae(n,h),t.texShape=x),null!=o){const e=re(n);let l,d=x[1],v=x[0];const O=o instanceof Uint8Array||o instanceof Uint8ClampedArray;!h&&O||([d,v]=k(x[0],x[1])),l=h?new Ze(e,O):new Ye(e,O);const w=O?[v,d]:x,I=this.makeTensorInfo(w,r),S=this.texData.get(I.dataId);S.usage=O?y.PIXELS:y.UPLOAD,S.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(I.dataId),d,v,o);const N=[[v,d]],T=!0,j=this.runWebGLProgram(l,[I],r,N,T),C=this.texData.get(j.dataId);t.texShape=C.texShape,t.isPacked=C.isPacked,t.usage=C.usage,Object(c.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(j.dataId):(t.texture=C.texture,t.values=null,this.texData.delete(j.dataId)),this.disposeIntermediateTensorInfo(I),f&&(this.uploadWaitMs+=c.util.now()-m)}else{const e=this.acquireTexture(x,d,r,h);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(a,e){if("float32"===e||"complex64"===e)return a;if("int32"===e||"bool"===e){const t="int32"===e?new Int32Array(a.length):new Uint8Array(a.length);for(let i=0;i<t.length;++i)t[i]=Math.round(a[i]);return t}throw new Error(`Unknown dtype ${e}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*c.util.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const p=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(p)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Object(c.nextFrame)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw E(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:o,inShapesLocations:c,inTexShapesLocations:l,outShapeLocation:d,outShapeStridesLocation:h,outTexShapeLocation:f}=We(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=o,e.inShapesLocations=c,e.inTexShapesLocations=l,e.outShapeLocation=d,e.outShapeStridesLocation=h,e.outTexShapeLocation=f}}}An.nextDataId=0;const Rn="3.20.0";function _n(){Object(c.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}c.device_util.isBrowser()&&Object(c.registerBackend)("webgl",(()=>new An),2);const Fn={forceHalfFloat:_n};class Dn{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=c.backend_util.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Ge(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class Mn{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=c.backend_util.assertAndGetBroadcastShape(t,n);const o=this.outputShape.length;this.enableShapeUniforms=Ge(o);let l="";if(r)if(0===o||1===c.util.sizeFromShape(this.outputShape))l="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(l=`\n          ${Le(o)} coords = getOutputCoords();\n        `,1===o)this.enableShapeUniforms?l+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":l+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=gn("coords",o);this.enableShapeUniforms?l+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:l+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${l}\n\n        setOutput(result);\n      }\n    `}}function Pn(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Ln={kernelName:c.Identity,backendName:"webgl",kernelFunc:Pn};function Bn(e){const{inputs:t,backend:n}=e,{real:r,imag:o}=t,c=n.makeTensorInfo(r.shape,"complex64"),l=n.texData.get(c.dataId),d=Pn({inputs:{x:r},backend:n}),h=Pn({inputs:{x:o},backend:n});return l.complexTensorInfos={real:d,imag:h},c}const zn={kernelName:c.Complex,backendName:"webgl",kernelFunc:Bn},Vn="return (a < 0.) ? b * a : a;",Wn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Un={kernelName:c.LeakyRelu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{alpha:l}=r,d=n.makeTensorInfo([],"float32",c.util.createScalarValue(l,"float32")),h=Object(c.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Mn(Wn,o.shape,d.shape):new Dn(Vn,o.shape,d.shape),f=n.runWebGLProgram(h,[o,d],"float32");return n.disposeIntermediateTensorInfo(d),f}},Gn="return (a < 0.) ? b * a : a;",Hn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const qn={kernelName:c.Prelu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:o}=t,l=Object(c.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Mn(Hn,r.shape,o.shape):new Dn(Gn,r.shape,o.shape);return n.runWebGLProgram(l,[r,o],"float32")}};function Kn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:o,backend:l})=>{const{x:d}=o,h=l,f=r||d.dtype;if(h.shouldExecuteOnCPU([d])&&null!=n){const e=h.texData.get(d.dataId),t=n(e.values,f);return h.makeTensorInfo(d.shape,f,t)}let m;return m=Object(c.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Tn(d.shape,t):new In(d.shape,e),h.runWebGLProgram(m,[d],f)}}function Xn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:l}){return({inputs:d,backend:h})=>{const{a:a,b:b}=d,f=h;if(r&&"complex64"===a.dtype){const t=f.texData.get(a.dataId),n=f.texData.get(b.dataId),[r,o]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,o={dataId:n.dataId,dtype:n.dtype,shape:a.shape},l={dataId:r.dataId,dtype:r.dtype,shape:b.shape},d=new Dn(e,a.shape,b.shape);return f.runWebGLProgram(d,[o,l],Object(c.upcastType)(n.dtype,r.dtype))})),l=Bn({inputs:{real:r,imag:o},backend:f});return f.disposeIntermediateTensorInfo(r),f.disposeIntermediateTensorInfo(o),l}const m=l||Object(c.upcastType)(a.dtype,b.dtype);if(("string"===a.dtype||"string"===b.dtype||f.shouldExecuteOnCPU([a,b]))&&null!=o){const e=f.texData.get(a.dataId).values,t=f.texData.get(b.dataId).values,n="string"===a.dtype?c.backend_util.fromUint8ToStringArray(e):e,r="string"===a.dtype?c.backend_util.fromUint8ToStringArray(t):t,[l,d]=o(a.shape,b.shape,n,r,m),h=f.makeTensorInfo(d,m);return f.texData.get(h.dataId).values=l,h}let y;return y=Object(c.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Mn(t,a.shape,b.shape,n):new Dn(e,a.shape,b.shape),f.runWebGLProgram(y,[a,b],m)}}function Yn(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?Hn:Gn;if("leakyrelu"===e)return t?Wn:Vn;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Zn{constructor(e,t,n,r=!1,o=!1,c=!1,l=null,d=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Ge(this.outputShape.length);const f=r?e[1]:e[2],m=Math.ceil(f/2),y=r?"i * 2, rc.y":"rc.y, i * 2",x=o?"rc.z, i * 2":"i * 2, rc.z",v=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],O=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let k="",w="";l&&(k=d?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${l}\n        }`:h?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${l}\n        }`:`vec4 activation(vec4 x) {\n          ${l}\n        }`,w="result = activation(result);");const I=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let S="rc.x",N="rc.x";e[0]<t[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(N=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${k}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${m}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${m}; i++) {\n          int batchA = ${S};\n          int batchB = ${N};\n          vec4 a = getMatrixA(batchA, ${y});\n          vec4 b = getMatrixB(batchB, ${x});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${v[0]} * ${O[0]});\n          result += (${v[1]} * ${O[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${I}\n\n        ${w}\n\n        setOutput(result);\n      }\n    `}}const Qn="return areal * breal - aimag * bimag;",Jn="return areal * bimag + aimag * breal;";class er{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=c.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const nr="return a * b;";function rr(e){const{inputs:t,backend:n}=e,{a:a,b:b}=t,r=c.backend_util.upcastType(a.dtype,b.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(b.dataId),r=new er(Qn,a.shape,b.shape),o=new er(Jn,a.shape,b.shape),c=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:b.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:b.shape}],l=n.runWebGLProgram(r,c,"float32"),d=n.runWebGLProgram(o,c,"float32"),h=Bn({inputs:{real:l,imag:d},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}if(n.shouldExecuteOnCPU([a,b])){const e=n.texData.get(a.dataId),t=n.texData.get(b.dataId),[o,c]=Gt(a.shape,b.shape,e.values,t.values,r),l=n.makeTensorInfo(c,r);return n.texData.get(l.dataId).values=o,l}let o;return o=Object(c.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Mn(nr,a.shape,b.shape):new Dn(nr,a.shape,b.shape),n.runWebGLProgram(o,[a,b],r)}const ar={kernelName:c.Multiply,backendName:"webgl",kernelFunc:rr};function sr(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{shape:l}=r,d=n,h=c.util.sizeFromShape(o.shape),f=c.util.inferFromImplicitShape(l,h),m=c.util.sizeFromShape(f);c.util.assert(h===m,(()=>`The new shape (${f}) has ${m} elements and the old shape (${o.shape}) has ${h} elements. The new shape and old shape must have the same number of elements.`));const y=d.texData.get(o.dataId);return!y.isPacked||oe(o.shape,f)||null!==y.texture&&oe(y.shape,f)?(d.incRef(o.dataId),{dataId:o.dataId,shape:f,dtype:o.dtype}):function(input,e,t){const n=[te(input.shape),...ne(input.shape)],r={dtype:input.dtype,shape:n,dataId:input.dataId},o=[te(e),...ne(e)],c=new xn(o,n),l=[n],output=t.runWebGLProgram(c,[r],input.dtype,l,!0);return{dataId:output.dataId,shape:e,dtype:output.dtype}}(o,f,d)}const or={kernelName:c.Reshape,backendName:"webgl",kernelFunc:sr};class ir{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:l}=e;this.outputShape=[r,l];const d=4*Math.floor(n/4),h=n%4;let f="sumValue += dot(values, ones);";if(null!=t){const e=1/t;f=`sumValue += dot(values * ${c.util.isInt(e)?e.toPrecision(2):e}, ones);`}let m="";o%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===h}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${f}\n        } else if (${2===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${f}\n        } else if (${3===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${f}\n        }\n        setOutput(sumValue);\n      }\n    `}}class ur{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:c}=e;this.outputShape=[r,c];let l="0.0",d="";"prod"===t?l="1.0":"min"===t?(l="1.0 / 1e-20",d="min"):"max"===t&&(l="-1.0 / 1e-20",d="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?h="sumValue":"prod"===t?h="prodValue":"all"===t?h="allValue":"any"===t&&(h="anyValue");const f=4*Math.floor(n/4),m=n%4;let y=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${d}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${d}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,x="vec4";"all"===t?(l="1.0",y="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",x="bvec4"):"any"===t&&(l="0.0",y="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",x="bvec4");let v="";o%n>0&&(v=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${l};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${v}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${l});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${f}; i += 4) {\n          int inIdx = inOffset + i;\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${y}\n        }\n\n        int inIdx = inOffset + ${f};\n        if (${1===m}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${2===m}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${y}\n        } else if (${3===m}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${y}\n        }\n        setOutput(${h});\n      }\n    `}}function cr(e,t,n,r){const o=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=c.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let l=e;for(let i=0;i<o.length;i++){const{inSize:c,windowSize:d,outSize:h}=o[i];let f,m;f="mean"===n?0===i?new ir({windowSize:d,inSize:c,batchSize:e.shape[0],outSize:h},c):new ir({windowSize:d,inSize:c,batchSize:e.shape[0],outSize:h}):new ur({windowSize:d,inSize:c,batchSize:e.shape[0],outSize:h},n),m=l,l=r.runWebGLProgram(f,[l],t),m.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(m)}return l}class lr{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;const r=Le(this.rank),o=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let i=0;i<e.length;i++)r[e[i]]=n[i];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class dr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Le(this.rank),o=bn("rc",this.rank),c=new Array(this.rank);for(let i=0;i<t.length;i++)c[t[i]]=o[i];const l=`vec2(${c.slice(-2).join()})`,d=`++${o[this.rank-1]} < ${n[this.rank-1]}`,h=`getChannel(getA(${c.join()}), ${l})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${h};\n      if(${d}) {\n        result[1] = ${h};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${h};\n        if(${d}) {\n          result[3] = ${h};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function pr(e,t,n){const r=Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dr(e.shape,t):new lr(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function fr(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l,keepDims:d}=r;return function(e,t,n,r){const o=t,l=e.shape.length,d=c.util.parseAxisParam(o,e.shape);let h=d;const f=c.backend_util.getAxesPermutation(h,l),m=null!=f;let y=e;m&&(y=pr(e,f,r),h=c.backend_util.getInnerMostAxes(h.length,l)),c.backend_util.assertAxesAreInnerMostDims("sum",h,l);const[x,v]=c.backend_util.computeOutAndReduceShapes(y.shape,h);let O=x;n&&(O=c.backend_util.expandShapeToKeepDim(x,d));const k=c.util.sizeFromShape(v),w=sr({inputs:{x:y},attrs:{shape:[c.util.sizeFromShape(e.shape)/k,k]},backend:r}),I=cr(w,Object(c.sumOutType)(e.dtype),"sum",r),S=sr({inputs:{x:I},attrs:{shape:O},backend:r});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(I),m&&r.disposeIntermediateTensorInfo(y),S}(o,l,d,n)}const mr={kernelName:c.Sum,backendName:"webgl",kernelFunc:fr};function gr(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{perm:c}=r,l=n,d=o.shape.length,h=new Array(d);for(let i=0;i<h.length;i++)h[i]=o.shape[c[i]];let f;if(l.shouldExecuteOnCPU([o])){const e=l.texData.get(o.dataId).values,t=fn(e,o.shape,o.dtype,c,h);f=l.makeTensorInfo(h,o.dtype);l.texData.get(f.dataId).values=t}else f=pr(o,c,l);return f}const yr={kernelName:c.Transpose,backendName:"webgl",kernelFunc:gr};function xr({a:a,b:b,transposeA:e,transposeB:t,backend:n,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:d=null}){const h=a.shape.length,f=b.shape.length,m=e?a.shape[h-2]:a.shape[h-1],y=t?b.shape[f-1]:b.shape[f-2],x=e?a.shape[h-1]:a.shape[h-2],v=t?b.shape[f-2]:b.shape[f-1],O=a.shape.slice(0,-2),k=b.shape.slice(0,-2),w=c.util.sizeFromShape(O),I=c.util.sizeFromShape(k),S=c.broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)).concat([x,v]);c.util.assert(m===y,(()=>`Error in matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${e} and transposeB=${t} must match.`));const N=e?[w,m,x]:[w,x,m],T=t?[I,v,y]:[I,y,v],j=sr({inputs:{x:a},backend:n,attrs:{shape:N}}),C=sr({inputs:{x:b},backend:n,attrs:{shape:T}}),$=[j,C],E=Math.max(w,I),A=e?j.shape[1]:j.shape[2],R=null!=r,_=null!=o,F="leakyrelu"===d,D=null!=d?Yn(d,!0):null;let M;if((1===x||1===v)&&A>1e3&&!1===(R||_||F||null!=D)){let r=j,o=C;e&&(r=gr({inputs:{x:j},backend:n,attrs:{perm:[0,2,1]}}),$.push(r)),t&&(o=gr({inputs:{x:C},backend:n,attrs:{perm:[0,2,1]}}),$.push(o));const c=1===v;let l=r;1!==v&&(l=sr({inputs:{x:r},backend:n,attrs:{shape:[E,A,1]}}),$.push(l));const d=1===v?2:1;let h=o;c&&(h=sr({inputs:{x:o},backend:n,attrs:{shape:[E,1,A]}}),$.push(h));const f=rr({inputs:{a:l,b:h},backend:n});M=fr({inputs:{x:f},backend:n,attrs:{axis:d,keepDims:!0}}),$.push(f)}else{const d=Object(c.upcastType)(a.dtype,b.dtype),h=new Zn(N,T,[E,x,v],e,t,R,D,_,F),f=[j,C];if(null!=r&&f.push(r),_&&f.push(o),F){const e=n.makeTensorInfo([],"float32",c.util.createScalarValue(l,"float32"));f.push(e),$.push(e)}M=n.runWebGLProgram(h,f,d)}const P=sr({inputs:{x:M},backend:n,attrs:{shape:S}});$.push(M);for(const i of $)n.disposeIntermediateTensorInfo(i);return P}const vr={kernelName:c._FusedMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:b,bias:o,preluActivationWeights:c}=t,{transposeA:l,transposeB:d,activation:h,leakyreluAlpha:f}=r;return xr({a:a,b:b,transposeA:l,transposeB:d,backend:n,bias:o,preluActivationWeights:c,leakyreluAlpha:f,activation:h})}},Or="return abs(x);";const kr={kernelName:c.Abs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=en(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let o;return o=Object(c.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Tn(r.shape,Or):new In(r.shape,Or),n.runWebGLProgram(o,[r],r.dtype)}},wr=Kn({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Ir={kernelName:c.Acos,backendName:"webgl",kernelFunc:wr},Sr=Kn({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Nr={kernelName:c.Acosh,backendName:"webgl",kernelFunc:Sr},Tr="return a + b;",jr=Xn({opSnippet:Tr,packedOpSnippet:Tr,supportsComplex:!0,cpuKernelImpl:It}),Cr={kernelName:c.Add,backendName:"webgl",kernelFunc:jr};class $r{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,i)=>`T${i}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class Er{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,i)=>`T${i}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const Ar={kernelName:c.AddN,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,o=n;if(1===o.length)return Pn({inputs:{x:o[0]},backend:r});if(o.length>Object(c.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(o.length/2),n=e({inputs:o.slice(0,t),backend:r}),c=e({inputs:o.slice(t),backend:r});return e({inputs:[n,c],backend:r})}const l=o.map((e=>e.dtype)).reduce(((e,t)=>Object(c.upcastType)(e,t))),d=o.map((e=>e.shape)),h=Object(c.env)().getBool("WEBGL_PACK")?new Er(o[0].shape,d):new $r(o[0].shape,d);return r.runWebGLProgram(h,o,l)}};const Rr={kernelName:c.All,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l,keepDims:d}=r,h=o.shape.length,f=c.util.parseAxisParam(l,o.shape);let m=f;const y=c.backend_util.getAxesPermutation(m,h);let x=o;null!=y&&(x=gr({inputs:{x:o},backend:n,attrs:{perm:y}}),m=c.backend_util.getInnerMostAxes(m.length,h)),c.backend_util.assertAxesAreInnerMostDims("all",m,h);const[v,O]=c.backend_util.computeOutAndReduceShapes(x.shape,m),k=sr({inputs:{x:x},backend:n,attrs:{shape:[-1,c.util.sizeFromShape(O)]}}),w=cr(k,k.dtype,"all",n);let I;if(d){I=sr({inputs:{x:w},backend:n,attrs:{shape:c.backend_util.expandShapeToKeepDim(v,f)}})}else I=sr({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(w),null!=y&&n.disposeIntermediateTensorInfo(x),I}};const _r={kernelName:c.Any,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l,keepDims:d}=r,h=o.shape.length,f=c.util.parseAxisParam(l,o.shape);let m=f;const y=c.backend_util.getAxesPermutation(m,h);let x=o;null!=y&&(x=gr({inputs:{x:o},backend:n,attrs:{perm:y}}),m=c.backend_util.getInnerMostAxes(m.length,h)),c.backend_util.assertAxesAreInnerMostDims("any",m,h);const[v,O]=c.backend_util.computeOutAndReduceShapes(x.shape,m),k=sr({inputs:{x:x},backend:n,attrs:{shape:[-1,c.util.sizeFromShape(O)]}}),w=cr(k,k.dtype,"any",n);let I;if(d){I=sr({inputs:{x:w},backend:n,attrs:{shape:c.backend_util.expandShapeToKeepDim(v,f)}})}else I=sr({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(w),null!=y&&n.disposeIntermediateTensorInfo(x),I}};class Fr{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:c}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,c];const l="max"===t?">":"<",d=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${d};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${l} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Dr{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,c.util.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const o=e[e.length-1],l=Math.ceil(o/t);this.outputShape=e.slice(0,-1),l>1&&this.outputShape.push(l),r||this.variableNames.push("bestIndicesA");const d=this.outputShape,h=d.length,f=Le(h),m=gn("coords",h);let y,x;if(1===l){x=h+1;const e=Le(x);y=`\n        ${e} sourceLocR = ${e}(${m.join()}, 0);\n        ++${m[h-1]};\n        ${e} sourceLocG = ${e}(${m.join()}, 0);\n        ++${m[h-2]};\n        ${e} sourceLocA = ${e}(${m.join()}, 0);\n        --${m[h-1]};\n        ${e} sourceLocB = ${e}(${m.join()}, 0);\n        --${m[h-2]};`}else x=h,y=`\n        ${f} sourceLocR = coords;\n        ++${m[h-1]};\n        ${f} sourceLocG = coords;\n        ++${m[h-2]};\n        ${f} sourceLocA = coords;\n        --${m[h-1]};\n        ${f} sourceLocB = coords;\n        --${m[h-2]};`;const v=["x","y","z","w","u","v"].slice(0,x),O="."+v[x-1],k=v.map((e=>"int "+e)),w=gn("sourceLocR",x-1).concat("inIdx.r"),I=gn("sourceLocG",x-1).concat("inIdx.g"),S=gn("sourceLocB",x-1).concat("inIdx.b"),N=gn("sourceLocA",x-1).concat("inIdx.a"),T="max"===n?"greaterThan":"lessThan",j=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${S.join()}),\n                             getBestIndicesAChannel(${N.join()})));`,C=`vec4(\n            getAChannel(${w.join()}),\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\n            hasNextRow ? getAChannel(${S.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,$=r?"":`\n      float getBestIndicesAChannel(${k.join()}) {\n        return getChannel(getBestIndicesA(${v.join()}),\n                                          vec2(${v.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${k.join()}) {\n        return getChannel(getA(${v.join()}),\n                               vec2(${v.slice(-2).join()}));\n      }\n      ${$}\n      void main() {\n        ${f} coords = getOutputCoords();\n        bool hasNextCol = ${m[h-1]} < ${d[h-1]-1};\n        bool hasNextRow = ${m[h-2]} < ${d[h-2]-1};\n        ${y}\n        ivec4 srcIdx = ivec4(sourceLocR${O}, sourceLocG${O},\n          sourceLocB${O}, sourceLocA${O}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${j}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${T}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Mr(e,t,n,r=null){let o=t.shape[0],l=t.shape[1];null!=r&&(o=r.shape[0],l=r.shape[1]);const d=c.backend_util.computeOptimalWindowSize(l),h={windowSize:d,inSize:l,batchSize:o,outSize:Math.ceil(l/d)},f=new Fr(h,n,null==r),m=[t];null!=r&&m.push(r);const output=e.runWebGLProgram(f,m,"int32");if(1===output.shape[1])return output;const y=Mr(e,t,n,output);return e.disposeIntermediateTensorInfo(output),y}function Pr(e,t,n,r=null){const o=null!=r?r.shape:t.shape,l=o[o.length-1],d=c.backend_util.computeOptimalWindowSize(l),h=new Dr(o,d,n,null==r),f=null==r?[t]:[t,r],output=e.runWebGLProgram(h,f,"int32");if(output.shape.length===t.shape.length){const r=Pr(e,t,n,output);return e.disposeIntermediateTensorInfo(output),r}return output}function Lr(e,t,n,r){const o=[n];if(c.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,t.shape.length),!Object(c.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],l=e.texData.get(t.dataId);let d=t;null!==l&&l.isPacked&&(d=e.unpackTensor(t),n.push(d));const[h,f]=c.backend_util.computeOutAndReduceShapes(d.shape,o),m=c.util.sizeFromShape(f),y=sr({inputs:{x:d},backend:e,attrs:{shape:[-1,m]}});n.push(y);const x=Mr(e,y,r);n.push(x);const v=sr({inputs:{x:x},backend:e,attrs:{shape:h}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),v}return Pr(e,t,r)}const Br={kernelName:c.ArgMax,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l}=r;let d=c.util.parseAxisParam(l,o.shape);const h=c.backend_util.getAxesPermutation(d,o.shape.length);let f=o;const m=[];null!=h&&(f=gr({inputs:{x:o},backend:n,attrs:{perm:h}}),m.push(f),d=c.backend_util.getInnerMostAxes(d.length,f.shape.length)),c.backend_util.assertAxesAreInnerMostDims("argMax",[d[0]],f.shape.length);const y=Lr(n,f,d[0],"max");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const zr={kernelName:c.ArgMin,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l}=r;let d=c.util.parseAxisParam(l,o.shape);const h=c.backend_util.getAxesPermutation(d,o.shape.length);let f=o;const m=[];null!=h&&(f=gr({inputs:{x:o},backend:n,attrs:{perm:h}}),m.push(f),d=c.backend_util.getInnerMostAxes(d.length,f.shape.length)),c.backend_util.assertAxesAreInnerMostDims("argMin",[d[0]],f.shape.length);const y=Lr(n,f,d[0],"min");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},Vr=Kn({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Wr={kernelName:c.Asin,backendName:"webgl",kernelFunc:Vr},Ur=Kn({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Gr={kernelName:c.Asinh,backendName:"webgl",kernelFunc:Ur},Hr=Kn({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),qr={kernelName:c.Atan,backendName:"webgl",kernelFunc:Hr},Kr=Xn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Xr={kernelName:c.Atan2,backendName:"webgl",kernelFunc:Kr},Yr=Kn({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Zr={kernelName:c.Atanh,backendName:"webgl",kernelFunc:Yr};class Qr{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const c=e.filterWidth,l=e.strideHeight,d=e.strideWidth,h=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,x=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const O="avg"===t,k=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let I="0.0";if(O||(I="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${l}, ${d});\n        const ivec2 pads = ivec2(${x}, ${v});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${h}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y};\n                wC += ${f}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?o?k:w:`wR * ${y} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(S="avgValue / count");const N=4*Math.floor(c/4),T=c%4,j=`\n      if (${O}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${x}, ${v});\n      const float initializationValue = ${I};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${I});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${h}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${N}; wC += 4) {\n            int xC = xCCorner + wC * ${f};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              getValue(batch, xR, xC + 3 * ${f}, d)\n            );\n\n            ${j}\n          }\n\n          int xC = xCCorner + ${N};\n          if (${1===T}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${j}\n          } else if (${2===T}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${j}\n          } else if (${3===T}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              initializationValue\n            );\n\n            ${j}\n          }\n        }\n        setOutput(${S});\n      }\n    `}}class Jr{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const c=e.filterWidth,l=e.strideDepth,d=e.strideHeight,h=e.strideWidth,f=e.dilationDepth,m=e.dilationHeight,y=e.dilationWidth,x=e.effectiveFilterDepth,v=e.effectiveFilterHeight,O=e.effectiveFilterWidth,k=e.padInfo.front,w=e.padInfo.top,I=e.padInfo.left;this.outputShape=e.outShape;const S="avg"===t;let N="0.0";if(S||(N="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${l}, ${d}, ${h});\n        const ivec3 pads = ivec3(${k}, ${w}, ${I});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${x};\n              wD += ${f}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${v};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${O};\n                  wC += ${y}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${v} * ${O} +\n                      wR * ${O} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(T="avgValue / count");const j=4*Math.floor(c/4),C=c%4,$=`\n      if (${S}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${l}, ${d}, ${h});\n      const ivec3 pads = ivec3(${k}, ${w}, ${I});\n      const float initializationValue = ${N};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${N});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${x};\n            wD += ${f}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${v};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${j}; wC += 4) {\n              int xC = xCCorner + wC * ${y};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${y}, ch)\n              );\n\n              ${$}\n            }\n\n            int xC = xCCorner + ${j};\n            if (${1===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${2===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${3===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${y}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${y}, ch),\n                initializationValue\n              );\n\n              ${$}\n            }\n          }\n          setOutput(${T});\n        }\n      }\n    `}}const ea={kernelName:c.AvgPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t;ve(o,"avgPool");const{filterSize:l,strides:d,pad:h,dimRoundingMode:f}=r;c.util.assert(c.backend_util.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=c.backend_util.computePool2DInfo(o.shape,l,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&c.util.arraysEqual(m.inShape,m.outShape))return Pn({inputs:{x:o},backend:n});const y=new Qr(m,"avg",!1);return n.runWebGLProgram(y,[o],"float32")}};const ta={kernelName:c.AvgPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{filterSize:l,strides:d,pad:h,dimRoundingMode:f,dataFormat:m}=r,y=c.backend_util.computePool3DInfo(o.shape,l,d,[1,1,1],h,f,m),x=new Jr(y,"avg",!1);return n.runWebGLProgram(x,[o],"float32")}};class na{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,y=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${f}, ${m});\n      const float avgMultiplier = float(${y});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${h};\n            wC+= ${l}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ra{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,v=m-1-e.padInfo.front,O=y-1-e.padInfo.top,k=x-1-e.padInfo.left,w=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${v}, ${O}, ${k});\n      const float avgMultiplier = float(${w});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${d}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${y};\n              wR += ${h}) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${x};\n                wC += ${f}) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const aa={kernelName:c.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,l=input,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,y=c.backend_util.computePool3DInfo(l.shape,d,h,[1,1,1],f,m),x=new ra(y);return n.runWebGLProgram(x,[o],l.dtype)}};const sa={kernelName:c.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,l=input;ve([o,input],"avgPoolGrad");const{filterSize:d,strides:h,pad:f}=r,m=c.backend_util.computePool2DInfo(l.shape,d,h,1,f),y=new na(m);return n.runWebGLProgram(y,[o],l.dtype)}};const oa={kernelName:c.BatchMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:b}=t,{transposeA:o,transposeB:c}=r;return xr({a:a,b:b,transposeA:o,transposeB:c,backend:n})}};class ia{constructor(e,t,n,r,o,l){this.outputShape=[],this.variableNames=["x","mean","variance"],c.backend_util.assertAndGetBroadcastShape(e,t),c.backend_util.assertAndGetBroadcastShape(e,n);let d="0.0";null!=r&&(c.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="1.0";null!=o&&(c.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${d};\n        float scale = ${h};\n        float inv = scale * inversesqrt(variance + float(${l}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class ua{constructor(e,t,n,r,o,l){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],c.backend_util.assertAndGetBroadcastShape(e,t),c.backend_util.assertAndGetBroadcastShape(e,n);let d="vec4(0.0)";null!=r&&(c.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="vec4(1.0)";null!=o&&(c.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${d};\n        vec4 scale = ${h};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${l}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const ca={kernelName:c.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:o,variance:l,offset:d,scale:h}=e;c.util.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),c.util.assert(null==d||o.shape.length===d.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),c.util.assert(null==h||o.shape.length===h.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:f}=n;null==f&&(f=.001);const m=[r,o,l];let y=null;null!=d&&(y=d.shape,m.push(d));let x=null;null!=h&&(x=h.shape,m.push(h));const v=Object(c.env)().getBool("WEBGL_PACK_NORMALIZATION")?new ua(r.shape,o.shape,l.shape,y,x,f):new ia(r.shape,o.shape,l.shape,y,x,f);return t.runWebGLProgram(v,m,m[0].dtype)}};class la{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Le(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return da.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let body;body=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,i)=>`sourceLoc.${da[i]} = start[${i}] + coords.${da[i]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${body}\n        setOutput(getSource(${n}));\n      }\n    `}}const da=["x","y","z","w","u","v"];class pa{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Le(this.rank),n=gn("coords",this.rank),r=gn("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,c=`getChannel(getSource(${r.join()}), ${o})`,l=`\n      result.x = ${c};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${c};\n        --${r[this.rank-1]};\n      }\n    `,d=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${c};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${c};\n        }\n      }\n    `,h=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,i)=>`start[${i}]`)).join()});`:e.map(((e,i)=>`${r[i]} = ${n[i]} + start[${i}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${h}\n        vec4 result = vec4(0.);\n        ${l}\n        ${d}\n        setOutput(result);\n      }\n    `}}function ha(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{begin:l,size:d}=r,[h,f]=c.slice_util.parseSliceParams(o,l,d);if(c.slice_util.assertParamsValid(o,h,f),0===c.util.sizeFromShape(f))return n.makeTensorInfo(f,o.dtype,[]);if(n.shouldExecuteOnCPU([o])||"string"===o.dtype){const e=n.texData.get(o.dataId),t=tn(e.values,h,f,o.shape,o.dtype);return n.makeTensorInfo(f,o.dtype,t)}const{isPacked:m}=n.texData.get(o.dataId),y=c.slice_util.isSliceContinous(o.shape,h,f);if(m||!y){const e=Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pa(f):new la(f),t=[h];return n.runWebGLProgram(e,[o],o.dtype,t)}return n.uploadToGPU(o.dataId),function(e,t,n,r){const o=r.texData.get(e.dataId),l=r.makeTensorInfo(n,e.dtype),d=r.texData.get(l.dataId);Object.assign(d,o),d.refCount=1,d.shape=n,d.dtype=e.dtype;let h=c.slice_util.computeFlatOffset(t,c.util.computeStrides(e.shape));o.slice&&(h+=o.slice.flatOffset),d.slice={flatOffset:h,origDataId:o.slice&&o.slice.origDataId||e.dataId};const f=r.dataRefCount.get(d.slice.origDataId)||1;return r.dataRefCount.set(d.slice.origDataId,f+1),l}(o,h,f,n)}const fa={kernelName:c.Slice,backendName:"webgl",kernelFunc:ha},ma={kernelName:c.BatchToSpaceND,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockShape:l,crops:d}=r;c.util.assert(o.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const h=l.reduce(((a,b)=>a*b)),f=c.backend_util.getReshaped(o.shape,l,h),m=c.backend_util.getPermuted(f.length,l.length),y=c.backend_util.getReshapedPermuted(o.shape,l,h),x=c.backend_util.getSliceBeginCoords(d,l.length),v=c.backend_util.getSliceSize(y,d,l.length),O=[],k=sr({inputs:{x:o},backend:n,attrs:{shape:f}}),w=gr({inputs:{x:k},backend:n,attrs:{perm:m}}),I=sr({inputs:{x:w},backend:n,attrs:{shape:y}}),S=ha({inputs:{x:I},backend:n,attrs:{begin:x,size:v}});return O.push(k),O.push(w),O.push(I),O.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const ba={kernelName:c.Bincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l}=r,d=n.readSync(o.dataId),h=n.readSync(c.dataId),f=St(d,h,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,f)}};const ga={kernelName:c.BroadcastArgs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:o}=t,l=n.readSync(r.dataId),d=n.readSync(o.dataId),h=c.backend_util.assertAndGetBroadcastShape(Array.from(l),Array.from(d));return n.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},ya=Xn({opSnippet:"return float(a != b);",cpuKernelImpl:qt,dtype:"bool"}),xa={kernelName:c.NotEqual,backendName:"webgl",kernelFunc:ya};function va(e){const{inputs:t,backend:n}=e,{input:input}=t;return Pn({inputs:{x:n.texData.get(input.dataId).complexTensorInfos.real},backend:n})}const Oa={kernelName:c.Real,backendName:"webgl",kernelFunc:va};const ka={kernelName:c.Cast,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:o}=t,{x:l}=n,{dtype:d}=o;if("complex64"===d){if("complex64"===l.dtype)return Pn({inputs:{x:l},backend:r});const t=c.zeros(l.shape),n=e({inputs:{x:l},backend:r,attrs:{dtype:"float32"}}),o=Bn({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),o}if("complex64"===l.dtype){const t=va({inputs:{input:l},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:d}});return r.disposeIntermediateTensorInfo(t),n}if(!c.util.hasEncodingLoss(l.dtype,d)){const e=Pn({inputs:{x:l},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:d}}if(r.shouldExecuteOnCPU([l])){const e=r.texData.get(l.dataId).values,[t,n,o]=Tt(e,l.shape,l.dtype,d);return r.makeTensorInfo(t,n,o)}if("int32"===d)return function(input,e){const t=new In(input.shape,"return float(int(x));"),output=e.runWebGLProgram(t,[input],"int32");return{dataId:output.dataId,shape:output.shape,dtype:output.dtype}}(l,r);if("bool"===d){const e=r.makeTensorInfo([],"bool",c.util.getTypedArrayFromDType("bool",1)),t=ya({inputs:{a:l,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${l.dtype} to ${d}`)}},wa="return ceil(x);",Ia=Kn({opSnippet:wa,packedOpSnippet:wa,cpuKernelImpl:jt}),Sa={kernelName:c.Ceil,backendName:"webgl",kernelFunc:Ia};class Na{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Ta{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const ja={kernelName:c.ClipByValue,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{clipValueMin:l,clipValueMax:d}=r;let h;h=Object(c.env)().getBool("WEBGL_PACK_CLIP")?new Ta(o.shape):new Na(o.shape);const f=[[l],[d]];return n.runWebGLProgram(h,[o],o.dtype,f)}};class Ca{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function $a(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Ea={kernelName:c.ComplexAbs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,o=n.texData.get(r.dataId),c=new Ca(r.shape),l=[$a(r,o.complexTensorInfos.real),$a(r,o.complexTensorInfos.imag)];return n.runWebGLProgram(c,l,l[0].dtype)}};class Aa{constructor(e){this.outputShape=[],this.outputShape=c.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,i)=>`T${i}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const e=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${e}));`)}const r=t.length,o=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Ra{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=c.backend_util.computeOutShape(e,t);const n=this.outputShape,r=n.length,o=Le(r),l=gn("coords",r),d=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,i)=>`T${i}`));const h=new Array(e.length-1);h[0]=e[0][t];for(let i=1;i<h.length;i++)h[i]=h[i-1]+e[i][t];const f=d[t],m=d.slice(-2),y=d.join();let x=`if (${f} < ${h[0]}) {\n        return getChannel(\n            getT0(${y}), vec2(${m.join()}));\n        }`;for(let i=1;i<h.length;i++){const e=h[i-1];x+=`\n        if (${f} < ${h[i]}  && ${f} >= ${h[i-1]}) {\n          return getChannel(\n            getT${i}(${_a(d,f,e)}),\n            vec2(${_a(m,f,e)}));\n        }`}const v=h.length,O=h[h.length-1];x+=`\n        return getChannel(\n          getT${v}(${_a(d,f,O)}),\n          vec2(${_a(m,f,O)}));`,this.userCode=`\n      float getValue(${d.map((e=>"int "+e))}) {\n        ${x}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[r-1]} = ${l[r-1]} + 1;\n        if (${l[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[r-2]} = ${l[r-2]} + 1;\n        if (${l[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[r-1]} = ${l[r-1]} - 1;\n        if (${l[r-2]} < ${n[r-2]} &&\n            ${l[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `}}function _a(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function Fa(e){const{inputs:t,backend:n}=e,{input:input}=t;return Pn({inputs:{x:n.texData.get(input.dataId).complexTensorInfos.imag},backend:n})}const Da={kernelName:c.Imag,backendName:"webgl",kernelFunc:Fa};function Ma(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>va({inputs:{input:e},backend:n}))),o=e.map((e=>Fa({inputs:{input:e},backend:n}))),c=Ma(r,t,n),l=Ma(o,t,n),d=Bn({inputs:{real:c,imag:l},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),o.forEach((i=>n.disposeIntermediateTensorInfo(i))),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),d}let o=n.shouldExecuteOnCPU(e);if("string"===r&&(o=!0),o){const o=e.map((e=>{const r=c.util.sizeFromShape(e.shape.slice(t));return sr({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),l=o.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),d=c.backend_util.computeOutShape(o.map((e=>e.shape)),1),h=1===o[0].shape[0],f=Ct(l,d,r,h),m=c.backend_util.computeOutShape(e.map((e=>e.shape)),t),y=n.makeTensorInfo(m,r,f);return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const l=Object(c.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>l){const r=[];for(let i=0;i<e.length;i+=l){const o=e.slice(i,i+l);r.push(Ma(o,t,n))}const o=Ma(r,t,n);for(const i of r)n.disposeIntermediateTensorInfo(i);return o}if(Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const o=new Ra(e.map((e=>e.shape)),t);return n.runWebGLProgram(o,e,r)}const{tensors2D:d,outShape:h}=function(e,t,n){const r=c.backend_util.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>sr({inputs:{x:e},attrs:{shape:[-1,c.util.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(e,t,n),f=new Aa(d.map((e=>e.shape))),m=n.runWebGLProgram(f,d,r);d.forEach((e=>n.disposeIntermediateTensorInfo(e)));const y=sr({inputs:{x:m},attrs:{shape:h},backend:n});return n.disposeIntermediateTensorInfo(m),y}function Pa(e){const{inputs:t,backend:n,attrs:r}=e,{axis:o}=r,l=c.util.parseAxisParam(o,t[0].shape)[0],d=c.backend_util.computeOutShape(t.map((e=>e.shape)),l);if(0===c.util.sizeFromShape(d))return n.makeTensorInfo(d,t[0].dtype,[]);const h=t.filter((e=>c.util.sizeFromShape(e.shape)>0));if(1===h.length)return Pn({inputs:{x:h[0]},backend:n});const f=h.map((e=>e.shape));return c.backend_util.assertParamsConsistent(f,l),Ma(h,l,n)}const La={kernelName:c.Concat,backendName:"webgl",kernelFunc:Pa};class Ba{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const c=e.padInfo.top,l=e.padInfo.left,d=e.strideHeight,h=e.strideWidth,f=e.dilationHeight,m=e.dilationWidth,y=e.filterHeight,x=e.filterWidth,v=4*Math.floor(e.inChannels/4),O=e.inChannels%4,k="channelsLast"===e.dataFormat,w=k?1:2,I=k?2:3,S=k?3:1;let N="",T="";n&&(N=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,T="result = activation(result);");const j=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${N}\n\n      const ivec2 strides = ivec2(${d}, ${h});\n      const ivec2 pads = ivec2(${c}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${S}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${w}], coords[${I}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${y}; wR++) {\n          int xR = xRCorner + wR * ${f};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC++) {\n            int xC = xCCorner + wC * ${m};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${v}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${k}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===O}) {\n\n              if (${k}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${v}) *\n                    getW(wR, wC, ${v}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${v}, xR, xC) *\n                    getW(wR, wC, ${v}, d2);\n              }\n\n            } else if (${2===O}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${v}, d2),\n                getW(wR, wC, ${v} + 1, d2)\n              );\n\n              if (${k}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${v}),\n                  getX(batch, xR, xC, ${v} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${v}, xR, xC),\n                  getX(batch, ${v} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===O}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${v}, d2),\n                getW(wR, wC, ${v} + 1, d2),\n                getW(wR, wC, ${v} + 2, d2)\n              );\n\n              if (${k}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${v}),\n                  getX(batch, xR, xC, ${v} + 1),\n                  getX(batch, xR, xC, ${v} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${v}, xR, xC),\n                  getX(batch, ${v} + 1, xR, xC),\n                  getX(batch, ${v} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${j}\n        ${T}\n        setOutput(result);\n      }\n    `}}class za{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,m=e.filterDepth,y=e.filterHeight,x=e.filterWidth,v=4*Math.floor(e.inChannels/4),O=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${c}, ${l});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${d};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y}; wR++) {\n            int xR = xRCorner + wR * ${h};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC++) {\n              int xC = xCCorner + wC * ${f};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${v}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===O}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${v}) *\n                  getW(wF, wR, wC, ${v}, d2);\n              } else if (${2===O}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${v}),\n                  getX(batch, xF, xR, xC, ${v} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${v}, d2),\n                  getW(wF, wR, wC, ${v} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===O}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${v}),\n                  getX(batch, xF, xR, xC, ${v} + 1),\n                  getX(batch, xF, xR, xC, ${v} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${v}, d2),\n                  getW(wF, wR, wC, ${v} + 1, d2),\n                  getW(wF, wR, wC, ${v} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Va{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ge(this.outputShape.length);const l=e.padInfo.left,d=e.strideWidth,h=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,y=m;let x="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<m;e++)x+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;x+=`\n     for (int r = 0; r < ${f}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<m;e++)x+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;x+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(y+1)/2;t++){const n=2*t;if(x+=`\n           xC = xCCorner + ${n*h};\n           `,1===d){if(n<m&&(l%2==1?(x+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,x+=1===h&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):x+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<m)){const e=l%2==0?c.util.nearestLargerEven(h):h;h%2==0&&l%2==1||h%2!=0&&l%2!=1?(x+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,x+=h>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):x+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<m&&(l%2==1?(x+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<m&&(x+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(x+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<m&&(x+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<m&&(x+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<m&&(x+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}x+="\n     }\n   ",x+="\n     }\n   ",x+="\n     }\n   ";let v="",O="";n&&(v=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,O="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${v}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${x}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${k}\n         ${O}\n         setOutput(result);\n       }\n     `}}class Wa{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ge(this.outputShape.length);const{dataFormat:n}=t,r=ke(),o="channelsLast"===n,c=o?1:2,l=o?2:3,d=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let e=0;e<=1;e++)for(let col=0;col<=1;col++)h+=`\n          blockIndex = rc.z + ${col};\n          pos = rc.y + ${e};\n\n          ${d}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${c}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${l}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+col}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+col}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${h}\n\n        ${r.output} = result;\n      }\n    `}}function Ua(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Ga({x:e,filter:filter,convInfo:t,backend:n,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:d=null}){const h=e.shape,f=n.texData.get(e.dataId),m=t.inChannels,y=h[0]*h[1]*h[2],x=t.outChannels,v="channelsLast"===t.dataFormat;let O;const k=[];if(null!=o){const e=Ua(o.shape,v);null!=e&&(o=sr({inputs:{x:o},backend:n,attrs:{shape:e}}),k.push(o))}if(null!=r){const e=Ua(r.shape,v);null!=e&&(r=sr({inputs:{x:r},backend:n,attrs:{shape:e}}),k.push(r))}if(!((1===y||1===x)&&m>1e3)&&f.isPacked&&v&&null!=f.texture&&h[2]%2!=0&&c.util.arraysEqual(f.shape.slice(-3),h.slice(-3))){const m=h[0]*h[1]*(h[2]+1),y={dataId:e.dataId,shape:[1,m,t.inChannels],dtype:e.dtype},x=f.shape;f.shape=f.shape.slice(),f.shape[f.shape.length-2]++,c.util.assert(oe(f.shape,y.shape),(()=>`packed reshape ${f.shape} to ${y.shape} isn't free`));const v=sr({inputs:{x:filter},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});k.push(v);const w=xr({a:y,b:v,backend:n,transposeA:false,transposeB:false,bias:r,activation:d,preluActivationWeights:o,leakyreluAlpha:l}),I=n.texData.get(w.dataId);c.util.assert(I.isPacked,(()=>"batchMatMul result is expected to be packed")),f.shape=x,I.shape=t.outShape,O=Pn({inputs:{x:w},backend:n}),O.shape=t.outShape,k.push(w)}else{const c=t.outHeight*t.outWidth,h=sr({inputs:{x:e},backend:n,attrs:{shape:v?[t.batchSize,c,t.inChannels]:[t.batchSize,t.inChannels,c]}}),f=sr({inputs:{x:filter},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),m=xr({a:v?h:f,b:v?f:h,transposeA:!v,transposeB:false,backend:n,bias:r,activation:d,preluActivationWeights:o,leakyreluAlpha:l});O=sr({inputs:{x:m},backend:n,attrs:{shape:t.outShape}}),k.push(h),k.push(f),k.push(m)}for(const i of k)n.disposeIntermediateTensorInfo(i);return O}function Ha({x:e,filter:filter,convInfo:t,backend:n,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:d=null}){const{filterWidth:h,filterHeight:f,inChannels:m,outWidth:y,outHeight:x,dataFormat:v}=t,O="channelsLast"===v,k=h*f*m,w=x*y,I=[t.batchSize,k,w],S=[];if(null!=o){const e=Ua(o.shape,O);null!=e&&(o=sr({inputs:{x:o},backend:n,attrs:{shape:e}}),S.push(o))}if(null!=r){const e=Ua(r.shape,O);null!=e&&(r=sr({inputs:{x:r},backend:n,attrs:{shape:e}}),S.push(r))}const N=sr({inputs:{x:filter},backend:n,attrs:{shape:[1,k,c.util.sizeFromShape(filter.shape)/k]}});S.push(N);const T=new Wa(I,t),j=[e.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],C=n.runWebGLProgram(T,[e],"float32",j),$=sr({inputs:{x:C},backend:n,attrs:{shape:I}});S.push(C),S.push($);const E=null!=r,A=null!=o,R="leakyrelu"===d,_=d?Yn(d,!0):null,F=new Zn(O?$.shape:N.shape,O?N.shape:$.shape,O?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],!0,!1,E,_,A,R),D=O?[$,N]:[N,$];if(r&&D.push(r),A&&D.push(o),R){const e=n.makeTensorInfo([],"float32",c.util.createScalarValue(l,"float32"));D.push(e),S.push(e)}const M=n.runWebGLProgram(F,D,"float32"),P=sr({inputs:{x:M},backend:n,attrs:{shape:t.outShape}});S.push(M);for(const i of S)n.disposeIntermediateTensorInfo(i);return P}const qa={kernelName:c.Conv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:l,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m}=r,y=c.backend_util.convertConv2DDataFormat(h),x=c.backend_util.computeConv2DInfo(o.shape,filter.shape,l,f,d,m,!1,y);let v;if(1!==x.filterHeight||1!==x.filterWidth||1!==x.dilationHeight||1!==x.dilationWidth||1!==x.strideHeight||1!==x.strideWidth||"SAME"!==x.padInfo.type&&"VALID"!==x.padInfo.type)if(x.strideWidth<=2&&"channelsLast"===y&&Object(c.env)().getBool("WEBGL_EXP_CONV")){const e=new Va(x),t=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]];v=n.runWebGLProgram(e,[o,filter],"float32",t)}else if(Object(c.env)().getBool("WEBGL_CONV_IM2COL"))v=Ha({x:o,filter:filter,convInfo:x,backend:n});else{const e=new Ba(x);v=n.runWebGLProgram(e,[o,filter],"float32")}else v=Ga({x:o,filter:filter,convInfo:x,backend:n});const O=sr({inputs:{x:v},backend:n,attrs:{shape:x.outShape}});return n.disposeIntermediateTensorInfo(v),O}};class Ka{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,c="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${c}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xa{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c="channelsLast"===e.dataFormat,l=t-1-e.padInfo.top,d=n-1-e.padInfo.left,h=c?1:2,f=c?2:3,m=c?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${m}];\n\n        ivec2 dyCorner = ivec2(coords[${h}], coords[${f}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${c}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ya{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,c=e.padInfo.top,l=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${o};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${c};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${l};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Za{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=t-1-e.padInfo.front,h=n-1-e.padInfo.top,f=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${h}, ${f});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Qa={kernelName:c.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:l}=t,{strides:d,pad:h,dataFormat:f,dimRoundingMode:m,filterShape:y}=r,x=c.backend_util.convertConv2DDataFormat(f),v=c.backend_util.computeConv2DInfo(o.shape,y,d,1,h,m,!1,x),O=new Ka(v);return n.runWebGLProgram(O,[o,l],"float32")}};const Ja={kernelName:c.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{inputShape:l,strides:d,pad:h,dataFormat:f,dimRoundingMode:m}=r,y=c.backend_util.convertConv2DDataFormat(f),x=c.backend_util.computeConv2DInfo(l,filter.shape,d,1,h,m,!1,y),v=new Xa(x);return n.runWebGLProgram(v,[o,filter],"float32")}};const es={kernelName:c.Conv3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:l,pad:d,dilations:h}=r,f=c.backend_util.computeConv3DInfo(o.shape,filter.shape,l,h,d),m=new za(f);return n.runWebGLProgram(m,[o,filter],"float32")}};const ts={kernelName:c.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:l}=t,{strides:d,pad:h,filterShape:f}=r,m=c.backend_util.computeConv3DInfo(o.shape,f,d,1,h),y=new Ya(m);return n.runWebGLProgram(y,[o,l],"float32")}};const ns={kernelName:c.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{pad:l,strides:d,inputShape:h}=r,f=c.backend_util.computeConv3DInfo(h,filter.shape,d,1,l),m=new Za(f);return n.runWebGLProgram(m,[o,filter],"float32")}},rs=Kn({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),as={kernelName:c.Cos,backendName:"webgl",kernelFunc:rs},ss=Kn({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),os={kernelName:c.Cosh,backendName:"webgl",kernelFunc:ss};class is{constructor(e,t,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[c,l,d,h]=e,[f]=t,[m,y]=n;this.outputShape=[f,m,y,h];const x="bilinear"===r?1:0,[v,O]=[l-1+".0",d-1+".0"],[k,w,I]=m>1?[""+(l-1)/(m-1),"(y2-y1) * height_ratio",`y1*${v} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${v}`],[S,N,T]=y>1?[""+(d-1)/(y-1),"(x2-x1) * width_ratio",`x1*${O} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${O}`];this.userCode=`\n      const float height_ratio = float(${k});\n      const float width_ratio = float(${S});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${c}) {\n          return;\n        }\n\n        float height_scale = ${w};\n        float width_scale = ${N};\n\n        float in_y = ${I};\n        if( in_y < 0.0 || in_y > ${v} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${T};\n        if( in_x < 0.0 || in_x > ${O} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${x} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const us={kernelName:c.CropAndResize,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:image,boxes:o,boxInd:c}=t,{cropSize:l,method:d,extrapolationValue:h}=r,f=new is(image.shape,o.shape,l,d,h);return n.runWebGLProgram(f,[image,o,c],"float32")}};var cs;!function(e){e.Prod="*",e.Sum="+"}(cs||(cs={}));class ls{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,c=this.op===cs.Prod?"1.0":"0.0",l=n?c:`getX(${ds(o,"coords",this.op)})`,d=this.outputShape[this.outputShape.length-1];let h="",f="";n?(h=r?"end != "+(d-1):"end != 0",f=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${d}`:"end >= pow2",f=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Le(o)} coords = getOutputCoords();\n        int end = ${ps(o,"coords",this.op)};\n        float val = ${l};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${f};\n          ${ps(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${ds(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function ds(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function ps(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function hs(e,t,n,r,o,l){const d=t.shape.length,h=c.backend_util.getAxesPermutation([r],d);let f=t;null!=h&&(f=gr({inputs:{x:t},backend:n,attrs:{perm:h}}));const m=c.backend_util.getInnerMostAxes(1,d)[0];if(m!==d-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const y=f.shape[m];let x=Pn({inputs:{x:f},backend:n});for(let i=0;i<=Math.ceil(Math.log2(y))-1;i++){const t=new ls(e,f.shape,!1,l),r=[[i]],o=x;x=n.runWebGLProgram(t,[x],x.dtype,r),n.disposeIntermediateTensorInfo(o)}if(o){const t=new ls(e,f.shape,o,l),r=x;x=n.runWebGLProgram(t,[x],x.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=h){const e=gr({inputs:{x:x},backend:n,attrs:{perm:c.backend_util.getUndoAxesPermutation(h)}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(f),e}return x}const fs={kernelName:c.Cumprod,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,exclusive:l,reverse:d}=r;return hs(cs.Prod,o,n,c,l,d)}};const ms={kernelName:c.Cumsum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,exclusive:l,reverse:d}=r;return hs(cs.Sum,o,n,c,l,d)}};const bs={kernelName:c.DenseBincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l,binaryOutput:d}=r;if(1===o.shape.length){const e=n.readSync(o.dataId),t=n.readSync(c.dataId),r=St(e,t,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,r)}if(2===o.shape.length){const e=n.bufferSync(o),t=n.bufferSync(c),r=Nt(e,t,l,d);return n.makeTensorInfo(r.shape,c.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}};class gs{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ys={kernelName:c.DepthToSpace,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockSize:c,dataFormat:l}=r,d=o.shape[0],h=("NHWC"===l?o.shape[1]:o.shape[2])*c,f=("NHWC"===l?o.shape[2]:o.shape[3])*c,m=("NHWC"===l?o.shape[3]:o.shape[1])/(c*c),y=new gs("NHWC"===l?[d,h,f,m]:[d,m,h,f],c,l);return n.runWebGLProgram(y,[o],o.dtype)}};class xs{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ge(this.outputShape.length);const c=e.filterHeight,l=e.filterWidth,d=e.outChannels/e.inChannels;let h="",f="";n&&(h=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${d};\n        int q = d2 - d1 * ${d};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${l}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}class vs{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ge(this.outputShape.length);const l=e.outChannels/e.inChannels,d=e.padInfo.left,h=e.strideWidth,f=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,x=y;let v="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<y;e++)v+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;v+=`\n    for (int r = 0; r < ${m}; r++) {\n      `;for(let e=0;e<y;e++)v+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;v+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(x+1)/2;e++){const t=2*e;if(v+=`\n          xC = xCCorner + ${t*f};\n          `,1===h){if(t<y&&(d%2==1?(v+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,v+=1===f&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):v+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<y)){const e=d%2==0?c.util.nearestLargerEven(f):f;f%2==0&&d%2==1||f%2!=0&&d%2!=1?(v+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,v+=f>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):v+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<y&&(d%2==1?(v+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<y&&(v+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(v+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<y&&(v+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<y&&(v+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<y&&(v+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}v+="\n    }\n  ",v+="\n      }\n    ";let O="",k="";n&&(O=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,k="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${O}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${v}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${w}\n        ${k}\n        setOutput(result);\n      }\n    `}}const Os={kernelName:c.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:l,pad:d,dilations:h,dimRoundingMode:f}=r;let m=h;null==m&&(m=[1,1]),c.util.assert(c.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const y=c.backend_util.computeConv2DInfo(o.shape,filter.shape,l,m,d,f,!0);let x;x=Object(c.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1?new vs(y):new xs(y);const v=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]];return n.runWebGLProgram(x,[o,filter],"float32",v)}};class ks{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${c} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ws{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c=t-1-e.padInfo.top,l=n-1-e.padInfo.left,d=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${d}; dm++) {\n              int d2 = d1 * ${d} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Is={kernelName:c.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:l}=t,{strides:d,dilations:h,pad:f,dimRoundingMode:m,filterShape:y}=r,x=c.backend_util.computeConv2DInfo(o.shape,y,d,h,f,m,!0),v=new ks(x);return n.runWebGLProgram(v,[o,l],"float32")}};const Ss={kernelName:c.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{strides:l,dilations:d,pad:h,dimRoundingMode:f,inputShape:m}=r,y=c.backend_util.computeConv2DInfo(m,filter.shape,l,d,h,f,!0),x=new ws(y);return n.runWebGLProgram(x,[o,filter],"float32")}};class Ns{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ts={kernelName:c.Diag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,o=[...r.shape,...r.shape],l=c.util.sizeFromShape(r.shape),d=sr({inputs:{x:r},backend:n,attrs:{shape:[l]}}),h=new Ns(l),f=n.runWebGLProgram(h,[d],d.dtype),m=sr({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}};class js{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:o,strideWidth:c,filterHeight:l,filterWidth:d,dilationHeight:h,dilationWidth:f}=e,{top:m,left:y}=r;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${c});\n      const ivec2 pads = ivec2(${m}, ${y});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${l}; h++) {\n          int hIn = hBeg + h * ${h};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${d}; w++) {\n              int wIn = wBeg + w * ${f};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Cs={kernelName:c.Dilation2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:l,pad:d,dilations:h}=r,f=c.backend_util.computeDilation2DInfo(o.shape,filter.shape,l,d,"NHWC",h);let m;const y=new js(f);m=n.runWebGLProgram(y,[o,filter],"float32");const x=sr({inputs:{x:m},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(m),x}};const $s={kernelName:c.Einsum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:o}=r,l=t,{allDims:d,summedDims:h,idDims:f}=c.backend_util.decodeEinsumEquation(o,l.length);c.backend_util.checkEinsumDimSizes(d.length,f,l);const{path:path,steps:m}=c.backend_util.getEinsumComputePath(h,f),y=m.length;let x=null,v=d.length;const O=[];for(let i=0;i<y;++i){for(const e of m[i]){const{permutationIndices:t,expandDims:r}=c.backend_util.getEinsumPermutation(v,f[e]);let o;c.backend_util.isIdentityPermutation(t)?o=l[e]:(o=gr({inputs:{x:l[e]},backend:n,attrs:{perm:t}}),O.push(o));const d=o.shape.slice();for(let e=0;e<r.length;++e)d.splice(r[e],0,1);c.util.arraysEqual(o.shape,d)||(o=sr({inputs:{x:o},backend:n,attrs:{shape:d}}),O.push(o)),null===x?x=o:(x=rr({inputs:{a:o,b:x},backend:n}),O.push(x))}i<y-1&&(path[i]>=0&&(x=fr({inputs:{x:x},backend:n,attrs:{axis:path[i]-(d.length-v),keepDims:!1}}),O.push(x)),v--)}for(const e of O)e!==x&&n.disposeIntermediateTensorInfo(e);return x}},Es=Kn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),As={kernelName:c.Elu,backendName:"webgl",kernelFunc:Es},Rs={kernelName:c.EluGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:o}=t,l=Object(c.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Mn("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,o.shape):new Dn("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,o.shape);return n.runWebGLProgram(l,[r,o],r.dtype)}},_s=Xn({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:$t}),Fs={kernelName:c.Equal,backendName:"webgl",kernelFunc:_s},Ds=Kn({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${c.backend_util.ERF_P};\n  float a1 = ${c.backend_util.ERF_A1};\n  float a2 = ${c.backend_util.ERF_A2};\n  float a3 = ${c.backend_util.ERF_A3};\n  float a4 = ${c.backend_util.ERF_A4};\n  float a5 = ${c.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Ms={kernelName:c.Erf,backendName:"webgl",kernelFunc:Ds},Ps=Kn({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Et,dtype:"float32"}),Ls={kernelName:c.Exp,backendName:"webgl",kernelFunc:Ps};function Bs(e){const{inputs:t,attrs:n,backend:r}=e,{dim:o}=n,{input:input}=t,l=input.shape.length,d=input.shape.slice();let h=o;return o<0&&(c.util.assert(-(l+1)<=o,(()=>`Axis must be in the interval [${-(l+1)}, ${l}]`)),h=l+o+1),d.splice(h,0,1),sr({inputs:{x:input},backend:r,attrs:{shape:d}})}const zs={kernelName:c.ExpandDims,backendName:"webgl",kernelFunc:Bs},Vs="return exp(x) - 1.0;",Ws=Kn({opSnippet:Vs,packedOpSnippet:Vs,cpuKernelImpl:At}),Us={kernelName:c.Expm1,backendName:"webgl",kernelFunc:Ws};class Gs{constructor(component,e,t){this.variableNames=["real","imag"];const n=e[1];this.outputShape=e;const r=t?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=t?`${n}.0`:"1.0";let c;if("real"===component)c="return real * expR - imag * expI;";else{if("imag"!==component)throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);c="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${c}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${n});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${n}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Hs(e,t,n){const r=n.texData.get(e.dataId),o=c.util.sizeFromShape(e.shape),l=e.shape[e.shape.length-1],d=sr({inputs:{x:e},backend:n,attrs:{shape:[o/l,l]}}),h=d.shape,f=new Gs("real",h,t),m=new Gs("imag",h,t),y=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:h},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:h}],x=n.runWebGLProgram(f,y,"float32"),v=n.runWebGLProgram(m,y,"float32"),O=Bn({inputs:{real:x,imag:v},backend:n});n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v);const k=sr({inputs:{x:O},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(O),k}const qs={kernelName:c.FFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t;return Hs(input,!1,n)}};class Ks{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Xs(e){const{backend:t,attrs:n}=e,{shape:r,value:o}=n;let{dtype:l}=n;if(l=l||c.util.inferDtype(o),"string"===l){const e=c.util.getArrayFromDType(l,c.util.sizeFromShape(r));return e.fill(o),t.makeTensorInfo(r,l,e)}{const e=new Ks(r,o),n=[[o]];return t.runWebGLProgram(e,[],l,n)}}const Ys={kernelName:c.Fill,backendName:"webgl",kernelFunc:Xs};class Zs{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Qs={kernelName:c.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:image}=e,n=t,r=new Zs(image.shape);return n.runWebGLProgram(r,[image],image.dtype)}},Js="return floor(x);",eo=Kn({opSnippet:Js,packedOpSnippet:Js,cpuKernelImpl:Rt}),to={kernelName:c.Floor,backendName:"webgl",kernelFunc:eo},no=Xn({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),ro={kernelName:c.FloorDiv,backendName:"webgl",kernelFunc:no};class ao{constructor(e){this.variableNames=["A"];const t=ke(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class so{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ke(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const oo={kernelName:c.FromPixels,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:o}=t;const{numChannels:l}=r,d="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,h="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,[f,m]=d?[o.videoWidth,o.videoHeight]:[o.width,o.height],x=[m,f],v=[m,f,l];if(h||d){const e=Object(c.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=io&&e===uo||(uo=e,io=document.createElement("canvas").getContext("2d",{willReadFrequently:uo})),io.canvas.width=f,io.canvas.height=m,io.drawImage(o,0,0,f,m),o=io.canvas}const O=n.makeTensorInfo(x,"int32");n.texData.get(O.dataId).usage=y.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(O.dataId),o);const k=Object(c.env)().getBool("WEBGL_PACK")?new so(v):new ao(v),w=n.runWebGLProgram(k,[O],"int32");return n.disposeData(O.dataId),w}};let io,uo=Object(c.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const co={kernelName:c.FusedConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:l,preluActivationWeights:d}=t,{strides:h,pad:f,dataFormat:m,dilations:y,dimRoundingMode:x,activation:v,leakyreluAlpha:O}=r,k=c.backend_util.convertConv2DDataFormat(m),w=c.backend_util.computeConv2DInfo(o.shape,filter.shape,h,y,f,x,!1,k);let I;const S=[],N=null!=l,T=null!=d,j="leakyrelu"===v,C=()=>{const e=[o,filter],t=(input,e)=>{if("NCHW"===e&&1===input.shape.length&&1!==input.shape[0]){const e=sr({inputs:{x:input},backend:n,attrs:{shape:[input.shape[0],1,1]}});return S.push(e),e}return input};if(N&&e.push(t(l,m)),T&&e.push(t(d,m)),j){const t=n.makeTensorInfo([],"float32",c.util.createScalarValue(O,"float32"));e.push(t),S.push(t)}return e};if(1!==w.filterHeight||1!==w.filterWidth||1!==w.dilationHeight||1!==w.dilationWidth||1!==w.strideHeight||1!==w.strideWidth||"SAME"!==w.padInfo.type&&"VALID"!==w.padInfo.type)if(w.strideWidth<=2&&"channelsLast"===k&&Object(c.env)().getBool("WEBGL_EXP_CONV")){const e=v?Yn(v,!0):null,t=new Va(w,N,e,T,j),r=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],o=C();I=n.runWebGLProgram(t,o,"float32",r)}else if(Object(c.env)().getBool("WEBGL_CONV_IM2COL"))I=Ha({x:o,filter:filter,convInfo:w,backend:n,bias:l,activation:v,preluActivationWeights:d,leakyreluAlpha:O});else{const e=v?Yn(v,!1):null,t=new Ba(w,N,e,T,j),r=C();I=n.runWebGLProgram(t,r,"float32")}else I=Ga({x:o,filter:filter,convInfo:w,backend:n,bias:l,activation:v,preluActivationWeights:d,leakyreluAlpha:O});const $=sr({inputs:{x:I},backend:n,attrs:{shape:w.outShape}});return S.push(I),S.forEach((e=>n.disposeIntermediateTensorInfo(e))),$}};const lo={kernelName:c.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:l,preluActivationWeights:d}=t,{strides:h,pad:f,dilations:m,dimRoundingMode:y,activation:x,leakyreluAlpha:v}=r,O=[];let k=m;null==k&&(k=[1,1]),c.util.assert(c.backend_util.eitherStridesOrDilationsAreOne(h,k),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${k}'`));const w=c.backend_util.computeConv2DInfo(o.shape,filter.shape,h,k,f,y,!0),I=Object(c.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels==1,S=x?Yn(x,I):null,N=[o,filter],T=null!=l,j=null!=d,C="leakyrelu"===x;if(T&&N.push(l),j&&N.push(d),C){const e=n.makeTensorInfo([],"float32",c.util.createScalarValue(v,"float32"));N.push(e),O.push(e)}let $;$=I?new vs(w,T,S,j,C):new xs(w,T,S,j,C);const E=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=n.runWebGLProgram($,N,"float32",E);return O.forEach((e=>n.disposeIntermediateTensorInfo(e))),A}};class po{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const o=Le(t.length),c=Le(n.length),l=this.sliceDim>1?"strides[j]":"strides",d=Le(r.length),h=r.length>1?"paramsShape[j]":"paramsShape";this.userCode=`\n        ${o} strides = ${o}(${this.strides});\n        ${d} paramsShape = ${d}(${this.paramsShape});\n         void main() {\n          ${c} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            out_of_bounds = out_of_bounds || index < 0;\n            out_of_bounds = out_of_bounds || index >= ${h};\n            flattenIndex += index * ${l};\n          }\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const ho={kernelName:c.GatherNd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:o}=t,l=o.shape,d=l[l.length-1],h=c.util.sizeFromShape(r.shape),[f,m,y,x]=c.backend_util.prepareAndValidate(r,o),v=sr({inputs:{x:o},backend:n,attrs:{shape:[m,d]}}),O=sr({inputs:{x:r},backend:n,attrs:{shape:[c.util.sizeFromShape(r.shape)/y,y]}});if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.readSync(o.dataId),t=n.bufferSync(r),c=_t(e,t,r.dtype,m,d,y,x,r.shape,h);return n.makeTensorInfo(f,r.dtype,c.values)}const k=new po(d,x,[m,y],r.shape),w=n.runWebGLProgram(k,[O,v],O.dtype),I=sr({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(O),n.disposeIntermediateTensorInfo(w),I}};class fo{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Le(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e.length;i++)2===i?r.push("index"):r.push(`${n[i]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function mo(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,indices:l}=t,{axis:d,batchDims:h}=r,f=c.util.parseAxisParam(d,o.shape)[0];if(Object(c.env)().get("DEBUG")){const e=n.readSync(l.dataId),t=o.shape[f];for(let i=0;i<e.length;++i){const n=e[i];c.util.assert(n<=t-1&&n>=0,(()=>`GatherV2: the index value ${n} is not in [0, ${t-1}]`))}}const m=c.backend_util.segment_util.collectGatherOpShapeInfo(o,l,f,h),y=c.util.sizeFromShape(l.shape),x=[],v=sr({inputs:{x:o},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),O=sr({inputs:{x:l},backend:n,attrs:{shape:[m.batchSize,y/m.batchSize]}});x.push(v),x.push(O);const k=[m.batchSize,m.outerSize,y/m.batchSize,m.sliceSize];if(n.shouldExecuteOnCPU([o,l])||"string"===o.dtype){const e=n.bufferSync(O),t=n.bufferSync(v),r=Ft(t,e,k);return x.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(m.outputShape,r.dtype,r.values)}const w=new fo(v.shape,k),I=n.runWebGLProgram(w,[v,O],v.dtype);x.push(I);const S=sr({inputs:{x:I},backend:n,attrs:{shape:m.outputShape}});return x.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}const bo={kernelName:c.GatherV2,backendName:"webgl",kernelFunc:mo},go=Xn({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Dt,dtype:"bool"}),yo={kernelName:c.Greater,backendName:"webgl",kernelFunc:go},xo=Xn({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Mt}),vo={kernelName:c.GreaterEqual,backendName:"webgl",kernelFunc:xo};const Oo={kernelName:c.IFFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t;return Hs(input,!0,n)}},ko=Kn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),wo={kernelName:c.IsFinite,backendName:"webgl",kernelFunc:ko},Io=Kn({opSnippet:"return float(isinf(x));",dtype:"bool"}),So={kernelName:c.IsInf,backendName:"webgl",kernelFunc:Io},No=Kn({opSnippet:"return float(isnan(x));",dtype:"bool"}),To={kernelName:c.IsNan,backendName:"webgl",kernelFunc:No},jo=Xn({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Pt,dtype:"bool"}),Co={kernelName:c.Less,backendName:"webgl",kernelFunc:jo},$o=Xn({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Lt,dtype:"bool"}),Eo={kernelName:c.LessEqual,backendName:"webgl",kernelFunc:$o};const Ao={kernelName:c.LinSpace,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:o,num:c}=n,l=Bt(r,o,c);return t.makeTensorInfo([l.length],"float32",l)}},Ro=Kn({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zt}),_o={kernelName:c.Log,backendName:"webgl",kernelFunc:Ro},Fo=Kn({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),Do={kernelName:c.Log1p,backendName:"webgl",kernelFunc:Fo},Mo=Xn({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Po={kernelName:c.LogicalAnd,backendName:"webgl",kernelFunc:Mo},Lo=Kn({opSnippet:"return float(!(x >= 1.0));"}),Bo={kernelName:c.LogicalNot,backendName:"webgl",kernelFunc:Lo},zo=Xn({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Vo={kernelName:c.LogicalOr,backendName:"webgl",kernelFunc:zo};class Wo{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[];const c=t,l=e[3]-1;let d;this.outputShape=e;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${c}; j <= ${c}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${l}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${d};\n        setOutput(val);\n      }\n    `}}class Uo{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const c=t,l=e[3]-1;let d;this.outputShape=e;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${c};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${c}; j <= ${c}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${d};\n        setOutput(result);\n      }\n    `}}const Go={kernelName:c.LRN,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{depthRadius:l,bias:d,alpha:h,beta:f}=r,m=Object(c.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Uo(o.shape,l,d,h,f):new Wo(o.shape,l,d,h,f);return n.runWebGLProgram(m,[o],o.dtype)}};class Ho{constructor(e,t,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const qo={kernelName:c.LRNGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o,y:c,dy:l}=t,{depthRadius:d,bias:h,alpha:f,beta:m}=r,y=new Ho(o.shape,d,h,f,m);return n.runWebGLProgram(y,[o,c,l],o.dtype)}};function Ko(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{reductionIndices:l,keepDims:d}=r,h=o.shape.length,f=c.util.parseAxisParam(l,o.shape);let m=f;const y=c.backend_util.getAxesPermutation(m,h),x=null!=y,v=n.shouldExecuteOnCPU([o]);let O=o;if(x){if(v){const e=n.texData.get(O.dataId).values,t=new Array(h);for(let i=0;i<t.length;i++)t[i]=o.shape[y[i]];const r=fn(e,o.shape,o.dtype,y,t);O=n.makeTensorInfo(t,o.dtype);n.texData.get(O.dataId).values=r}else O=pr(o,y,n);m=c.backend_util.getInnerMostAxes(m.length,h)}c.backend_util.assertAxesAreInnerMostDims("max",m,h);const[k,w]=c.backend_util.computeOutAndReduceShapes(O.shape,m);let I,S=k;if(d&&(S=c.backend_util.expandShapeToKeepDim(k,f)),v){const e=n.texData.get(O.dataId).values,t=Vt(e,c.util.sizeFromShape(w),S,o.dtype);I=n.makeTensorInfo(S,o.dtype);n.texData.get(I.dataId).values=t}else I=function(e,t,n,r){const o=c.util.sizeFromShape(t),l=sr({inputs:{x:e},attrs:{shape:[c.util.sizeFromShape(e.shape)/o,o]},backend:r}),d=cr(l,e.dtype,"max",r),h=sr({inputs:{x:d},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(d),h}(O,w,S,n);return x&&n.disposeIntermediateTensorInfo(O),I}const Xo={kernelName:c.Max,backendName:"webgl",kernelFunc:Ko},Yo=Xn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Wt}),Zo={kernelName:c.Maximum,backendName:"webgl",kernelFunc:Yo};const Qo={kernelName:c.MaxPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t;ve(o,"maxPool");const{filterSize:l,strides:d,pad:h,dimRoundingMode:f}=r;c.util.assert(c.backend_util.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=c.backend_util.computePool2DInfo(o.shape,l,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&c.util.arraysEqual(m.inShape,m.outShape))return Pn({inputs:{x:o},backend:n});const y=new Qr(m,"max",!1);return n.runWebGLProgram(y,[o],o.dtype)}};const Jo={kernelName:c.MaxPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{filterSize:l,strides:d,pad:h,dataFormat:f,dimRoundingMode:m}=r,y=c.backend_util.computePool3DInfo(o.shape,l,d,[1,1,1],h,m,f),x=new Jr(y,"max",!1);return n.runWebGLProgram(x,[o],o.dtype)}};class ei{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,d=c-1-e.padInfo.left,h=o*c-1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${c} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ti{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=d-1-e.padInfo.front,y=h-1-e.padInfo.top,x=f-1-e.padInfo.left,v=d*h*f-1;this.userCode=`\n      const ivec3 pads = ivec3(${m}, ${y}, ${x});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${c}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${v} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${h} * ${f} +\n                  wR * ${f} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ni={kernelName:c.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,l=input,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,y=c.backend_util.computePool3DInfo(l.shape,d,h,[1,1,1],f,m),x=new Jr(y,"max",!0),v=n.runWebGLProgram(x,[l],l.dtype),O=new ti(y),k=n.runWebGLProgram(O,[o,v],l.dtype);return n.disposeIntermediateTensorInfo(v),k}};const ri={kernelName:c.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input,output:output}=t,l=input;ve([input,output],"maxPoolGrad");const{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,y=c.backend_util.computePool2DInfo(l.shape,d,h,1,f,m),x=new Qr(y,"max",!0),v=n.runWebGLProgram(x,[l],l.dtype),O=new ei(y),k=n.runWebGLProgram(O,[o,v],l.dtype);return n.disposeIntermediateTensorInfo(v),k}};const ai={kernelName:c.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:o,strides:l,pad:d,includeBatchInIndex:h}=t,f=n;c.util.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const m=[1,1];c.util.assert(c.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const y=c.backend_util.computePool2DInfo(r.shape,o,l,m,d),[x,v]=function(e,t,n,r){let o=new Qr(n,"max",!1);const c=r.runWebGLProgram(o,[e],"float32");return o=new Qr(n,"max",!0,!0,t),[c,r.runWebGLProgram(o,[e],"float32")]}(r,h,y,f);return[x,v]}};const si={kernelName:c.Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:o,axis:l}=t,d=n,h=r.shape.length,f=c.util.parseAxisParam(l,r.shape);let m=f;const y=c.backend_util.getAxesPermutation(m,h),x=null!=y,v=d.shouldExecuteOnCPU([r]),O=[];let k=r;if(x){if(v){const e=d.texData.get(k.dataId).values,t=new Array(h);for(let i=0;i<t.length;i++)t[i]=r.shape[y[i]];const n=fn(e,r.shape,r.dtype,y,t);k=d.makeTensorInfo(t,r.dtype);d.texData.get(k.dataId).values=n}else k=pr(r,y,d);O.push(k),m=c.backend_util.getInnerMostAxes(m.length,h)}c.backend_util.assertAxesAreInnerMostDims("sum",m,h);const[w,I]=c.backend_util.computeOutAndReduceShapes(k.shape,m);let S=w;o&&(S=c.backend_util.expandShapeToKeepDim(w,f));const N=function(e,t,n,r){const o=c.util.sizeFromShape(t),l=sr({inputs:{x:e},attrs:{shape:[c.util.sizeFromShape(e.shape)/o,o]},backend:r}),d=cr(l,"float32","mean",r),h=sr({inputs:{x:d},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(d),h}(k,I,S,d);for(const i of O)d.disposeIntermediateTensorInfo(i);return N}};const oi={kernelName:c.Min,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l,keepDims:d}=r,h=o.shape.length,f=c.util.parseAxisParam(l,o.shape);let m=f;const y=c.backend_util.getAxesPermutation(m,h);let x=o;null!=y&&(x=gr({inputs:{x:o},backend:n,attrs:{perm:y}}),m=c.backend_util.getInnerMostAxes(m.length,o.shape.length)),c.backend_util.assertAxesAreInnerMostDims("min",m,h);const[v,O]=c.backend_util.computeOutAndReduceShapes(x.shape,m),k=sr({inputs:{x:x},backend:n,attrs:{shape:[-1,c.util.sizeFromShape(O)]}}),w=cr(k,k.dtype,"min",n);let I;if(d){I=sr({inputs:{x:w},backend:n,attrs:{shape:c.backend_util.expandShapeToKeepDim(v,f)}})}else I=sr({inputs:{x:w},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(w),null!=y&&n.disposeIntermediateTensorInfo(x),I}},ii=Xn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Ut}),ui={kernelName:c.Minimum,backendName:"webgl",kernelFunc:ii};class ci{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=Le(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h="reflect"===n?0:1;this.userCode=1!==r?`\n      ${o} start = ${o}(${c});\n      ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${h};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${d}));\n      }\n    `:`\n        int start = ${c};\n        int end = ${l};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${h};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${h};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class di{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=Le(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=gn("rc",r),source=gn("source",r),h=`${d[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${source.slice(-2).join()})`,m="reflect"===n?0:1;let y="";if(1===r){const e=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${m};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${m};\n        }\n        source -= start;\n      `;y=`\n        ${o} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${source.join()}), ${f});\n        ${d[r-1]} += 1;\n        if(${h}) {\n          ${e}\n          result[1] = getChannel(getX(${source.join()}), ${f});\n        }\n      `}else{const e=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${m}) +\n                gte * ((end - 1) * 2 - source + ${m});\n        source -= start;\n      `;y=`\n        ${o} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${source.join()}), ${f});\n        ${d[r-1]} += 1;\n        if(${h}) {\n          ${e}\n          result[1] = getChannel(getX(${source.join()}), ${f});\n        }\n        rc = outputLoc;\n        ${d[r-2]} += 1;\n        if(${d[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${source.join()}), ${f});\n          ${d[r-1]} += 1;\n          if(${h}) {\n            ${e}\n            result[3] = getChannel(getX(${source.join()}), ${f});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${c});\n      const ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${y}\n        setOutput(result);\n      }\n    `}}const pi={kernelName:c.MirrorPad,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:o,mode:l}=n,d=Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new di(r.shape,o,l):new ci(r.shape,o,l);return t.runWebGLProgram(d,[r],r.dtype)}},hi=Xn({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),fi={kernelName:c.Mod,backendName:"webgl",kernelFunc:hi};class mi{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const bi=Xn({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),gi={kernelName:c.RealDiv,backendName:"webgl",kernelFunc:bi},yi="return a - b;",sub=Xn({opSnippet:yi,packedOpSnippet:yi,supportsComplex:!0,cpuKernelImpl:dn}),xi={kernelName:c.Sub,backendName:"webgl",kernelFunc:sub};function vi(e){const{inputs:t,backend:n,attrs:r}=e,{logits:o}=t,{dim:l}=r,d=c.util.parseAxisParam([l],o.shape),h=Ko({inputs:{x:o},backend:n,attrs:{reductionIndices:d,keepDims:!1}}),f=c.backend_util.expandShapeToKeepDim(h.shape,d),m=sr({inputs:{x:h},backend:n,attrs:{shape:f}}),a=sub({inputs:{a:o,b:m},backend:n}),b=Ps({inputs:{x:a},backend:n}),y=fr({inputs:{x:b},backend:n,attrs:{axis:d,keepDims:!1}}),x=sr({inputs:{x:y},backend:n,attrs:{shape:f}}),v=bi({inputs:{a:b,b:x},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),v}const Oi={kernelName:c.Softmax,backendName:"webgl",kernelFunc:vi};const ki={kernelName:c.Multinomial,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:o}=t,{numSamples:c,seed:l,normalized:d}=r,h=d?o:vi({inputs:{logits:o},backend:n,attrs:{dim:o.shape.length-1}}),f=h.shape[0],m=h.shape[1],y=new mi(f,m,c),x=[[l]],v=n.runWebGLProgram(y,[h],"int32",x);return d||n.disposeIntermediateTensorInfo(h),v}};const wi={kernelName:c.Neg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,o]=Ht(e.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,t)}let o;return o=Object(c.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Tn(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new In(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(o,[r],r.dtype)}},Ii=c.kernel_impls.nonMaxSuppressionV3Impl;const Si={kernelName:c.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){c.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=r,m=n.readSync(o.dataId),y=n.readSync(l.dataId),{selectedIndices:x}=Ii(m,y,d,h,f);return n.makeTensorInfo([x.length],"int32",new Int32Array(x))}},Ni=c.kernel_impls.nonMaxSuppressionV4Impl;const Ti={kernelName:c.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){c.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:m}=r,y=n.readSync(o.dataId),x=n.readSync(l.dataId),{selectedIndices:v,validOutputs:O}=Ni(y,x,d,h,f,m);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([],"int32",new Int32Array([O]))]}},ji=c.kernel_impls.nonMaxSuppressionV5Impl;const Ci={kernelName:c.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){c.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,softNmsSigma:m}=r,y=n.readSync(o.dataId),x=n.readSync(l.dataId),v=d,O=h,k=f,w=m,{selectedIndices:I,selectedScores:S}=ji(y,x,v,O,k,w);return[n.makeTensorInfo([I.length],"int32",new Int32Array(I)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}};class $i{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const Ei={kernelName:c.OneHot,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:o}=t,{dtype:l,depth:d,onValue:h,offValue:f}=r,m=c.util.sizeFromShape(o.shape),y=new $i(m,d,h,f),x=sr({inputs:{x:o},backend:n,attrs:{shape:[m]}}),v=n.runWebGLProgram(y,[x],l);n.disposeIntermediateTensorInfo(x);const O=sr({inputs:{x:v},backend:n,attrs:{shape:[...o.shape,d]}});return n.disposeIntermediateTensorInfo(v),O}};function Ai(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=va({inputs:{input:r},backend:n}),t=Ai({inputs:{x:e},backend:n}),o=Fa({inputs:{input:r},backend:n}),i=Ai({inputs:{x:o},backend:n}),c=Bn({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}return Xs({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Ri={kernelName:c.ZerosLike,backendName:"webgl",kernelFunc:Ai};const _i={kernelName:c.OnesLike,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:o}=n;if("string"===o.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===o.dtype){const t=va({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r}),c=Fa({inputs:{input:o},backend:r}),i=Ai({inputs:{x:c},backend:r}),l=Bn({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(i),l}return Xs({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:r})}};const Fi={kernelName:c.Pack,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:o}=r;if(1===t.length)return Bs({inputs:{input:t[0]},backend:n,attrs:{dim:o}});const l=t[0].shape,d=t[0].dtype;t.forEach((e=>{c.util.assertShapesMatch(l,e.shape,"All tensors passed to stack must have matching shapes"),c.util.assert(d===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const h=[],f=Pa({inputs:t.map((e=>{const t=Bs({inputs:{input:e},backend:n,attrs:{dim:o}});return h.push(t),t})),backend:n,attrs:{axis:o}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Di{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=Le(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${o} start = ${o}(${c});\n      ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${d}));\n        }\n      }\n    `:`\n        int start = ${c};\n        int end = ${l};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Mi{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=Le(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=gn("rc",r),source=gn("source",r),h=`${d[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${source.slice(-2).join()})`,m=[`${o} rc = outputLoc;`,`${d[r-1]} += 1;\n       if(${h}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${d[r-2]} += 1;\n       if(${d[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${d[r-1]} += 1;\n         if(${h}) {`],y=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let x="";for(let i=0,e=1===r?2:4;i<e;i++)x+=`\n        ${m[i]}\n        if (${y}) {\n          result[${i}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${f});\n        }\n      `;x+=1===r?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${c});\n      const ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}const Pi=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{paddings:l,constantValue:d}=r;if(0===c.util.sizeFromShape(o.shape)){return Xs({backend:n,attrs:{shape:l.map(((p,i)=>p[0]+o.shape[i]+p[1])),value:d,dtype:o.dtype}})}const h=Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mi(o.shape,l,d):new Di(o.shape,l,d),f=[[d]];return n.runWebGLProgram(h,[o],o.dtype,f)},Li={kernelName:c.PadV2,backendName:"webgl",kernelFunc:Pi},Bi=Xn({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),zi={kernelName:c.Pow,backendName:"webgl",kernelFunc:Bi};const Vi={kernelName:c.Prod,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:l,keepDims:d}=r,h=o.shape.length,f=[],m=c.util.parseAxisParam(l,o.shape);let y=m;const x=c.backend_util.getAxesPermutation(y,h);let v,O=o;if(null!=x&&(O=gr({inputs:{x:o},backend:n,attrs:{perm:x}}),y=c.backend_util.getInnerMostAxes(y.length,h),f.push(O)),c.backend_util.assertAxesAreInnerMostDims("prod",y,h),n.shouldExecuteOnCPU([O])){const e=n.texData.get(O.dataId).values,{outVals:t,outShape:r,outDtype:o}=Kt(O.shape,O.dtype,e,y);v=n.makeTensorInfo(r,o,t)}else{const[e,t]=c.backend_util.computeOutAndReduceShapes(O.shape,y),r=c.util.sizeFromShape(t),l=sr({inputs:{x:O},backend:n,attrs:{shape:[-1,r]}}),d=cr(l,Object(c.sumOutType)(o.dtype),"prod",n);v=sr({inputs:{x:d},backend:n,attrs:{shape:e}}),f.push(l),f.push(d)}if(d){f.push(v);const e=c.backend_util.expandShapeToKeepDim(v.shape,m);v=sr({inputs:{x:v},backend:n,attrs:{shape:e}})}return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}};const Wi={kernelName:c.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:o,values:c,defaultValue:l,rowPartitionTensors:d}=t,{rowPartitionTypes:h}=r,f=n.readSync(o.dataId),m=n.readSync(c.dataId),y=n.readSync(l.dataId),x=d.map((e=>n.readSync(e.dataId))),v=d.map((e=>e.shape)),[O,output]=Xt(f,o.shape,m,c.shape,c.dtype,y,l.shape,x,v,h);return n.makeTensorInfo(O,c.dtype,output)}},Ui=e=>{const{backend:t,attrs:n}=e,{start:r,stop:o,step:c,dtype:l}=n,d=Yt(r,o,c,l);return t.makeTensorInfo([d.length],l,d)},Gi={kernelName:c.Range,backendName:"webgl",kernelFunc:Ui},Hi=Kn({opSnippet:"return 1.0 / x;"}),qi={kernelName:c.Reciprocal,backendName:"webgl",kernelFunc:Hi},Ki=Kn({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Xi={kernelName:c.Relu,backendName:"webgl",kernelFunc:Ki},Yi=Kn({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Zi={kernelName:c.Relu6,backendName:"webgl",kernelFunc:Yi};class Qi{constructor(e,t,n,r,o){this.variableNames=["A"],this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n];let y;y=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${l}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Ji{constructor(e,t,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n];let y;y=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]},\n          ${f[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${l}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${y};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const eu={kernelName:c.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o}=t,{alignCorners:l,halfPixelCenters:d,size:h}=r,[f,m]=h,y=Object(c.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ji(o.shape,f,m,l,d):new Qi(o.shape,f,m,l,d);return n.runWebGLProgram(y,[o],"float32")}};class tu{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,c,l]=e,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],y=1/f,x=1/m,v=2*Math.ceil(y)+2,O=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${v});\n        const int winWidth = int(${O});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const nu={kernelName:c.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o,dy:c}=t,{alignCorners:l}=r,d=new tu(c.shape,o.shape,l);return n.runWebGLProgram(d,[c],c.dtype)}};class ru{constructor(e,t,n,r,o){this.variableNames=["A"],this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n],y=r?"0.5":"0.0";let x;x=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${l}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${y})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class au{constructor(e,t,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n],y=r?"0.5":"0.0";let x;x=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]},\n          ${f[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${l}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${y})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const su={kernelName:c.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o}=t,{alignCorners:l,halfPixelCenters:d,size:h}=r,[f,m]=h,y=Object(c.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new au(o.shape,f,m,l,d):new ru(o.shape,f,m,l,d);return n.runWebGLProgram(y,[o],o.dtype)}};class ou{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,c,l]=e,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],y=1/f,x=1/m,v=2*Math.ceil(y)+2,O=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${y});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${v});\n        const int winWidth = int(${O});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${d[0]}) *\n                (float(dyR) / float(${h[0]}));\n\n            float sourceFracCol =\n                float(${d[1]}) *\n                  (float(dyC) / float(${h[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const iu={kernelName:c.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o,dy:c}=t,{alignCorners:l}=r,d=new ou(c.shape,o.shape,l);return n.runWebGLProgram(d,[c],c.dtype)}};class uu{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,i)=>(i=>-1!==t.indexOf(i)&&1!==e[i]?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`)(i))).join(","),o=Le(n);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class cu{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=gn("rc",n),o=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,c=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,l=Le(n);function d(n){const r=e.map(((r,i)=>function(i,n){return-1!==t.indexOf(i)&&1!==e[i]?`${e[i]} - ${n[i]} - 1`:`${n[i]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${l} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return d(e)}(r.slice())};\n          if(${o}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",d(e)}(r.slice())};\n          }\n          if(${c}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",d(e)}(r.slice())};\n            if(${o}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",d(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const lu={kernelName:c.Reverse,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{dims:l}=r,d=o.shape.length,h=c.util.parseAxisParam(l,o.shape);if(0===d)return Pn({inputs:{x:o},backend:n});const f=Object(c.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cu(o.shape,h):new uu(o.shape,h);return n.runWebGLProgram(f,[o],o.dtype)}};class du{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let o="";o="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const pu={kernelName:c.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:image}=e,{radians:r,fillValue:o,center:l}=t,d=n,h=new du(image.shape,o),[f,m]=c.backend_util.getImageCenter(l,image.shape[1],image.shape[2]),y=[[f,m,Math.sin(r),Math.cos(r)]];return d.runWebGLProgram(h,[image],image.dtype,y)}},hu=Kn({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),fu={kernelName:c.Round,backendName:"webgl",kernelFunc:hu},mu=Kn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Zt}),bu={kernelName:c.Rsqrt,backendName:"webgl",kernelFunc:mu};class gu{constructor(e,t,n,r,o,c,l=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=c;const d=Le(o.length),h=Le(c.length);let f="";1===n?f="i":2===n&&(f="i, j");const m=`getIndices(${f})`;let y="";1===r?y="i":2===r&&(y="i, coords[1]");const x=`getUpdates(${y})`,v=t>1?"strides[j]":"strides";this.userCode=`\n        ${d} strides = ${d}(${o});\n\n        void main() {\n          ${h} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${m});\n              flattenedIndex += index * ${v};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${x};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const yu={kernelName:c.ScatterNd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:o,updates:l}=t,{shape:d}=r,{sliceRank:h,numUpdates:f,sliceSize:m,strides:y,outputSize:x}=c.backend_util.calculateShapes(l,o,d),v=[x/m,m];if(0===x)return n.makeTensorInfo(d,o.dtype);const O=sr({inputs:{x:o},backend:n,attrs:{shape:[f,h]}}),k=sr({inputs:{x:l},backend:n,attrs:{shape:[f,m]}}),w=n.makeTensorInfo([],"float32",new Float32Array([0])),I=new gu(f,h,O.shape.length,k.shape.length,y,v),S=n.runWebGLProgram(I,[k,O,w],k.dtype),N=sr({inputs:{x:S},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(O),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(w),N}};class xu{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,l=2===Object(c.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":o,d="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${l}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${d} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const vu={kernelName:c.SearchSorted,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:o,values:c}=t,{side:l}=r,d=new xu(o.shape[0],o.shape[1],c.shape[1],l),h=[[o.shape[1]]];return n.runWebGLProgram(d,[o,c],"int32",h)}};class Ou{constructor(e,t,n){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)o="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let i=0;i<t.length;i++)l.push(`${n[i]}`),i<e&&c.push(`${n[i]}`);r=c.join(),o=l.join()}const c=Le(n);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const ku={kernelName:c.Select,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:o,e:l}=t,d=new Ou(r.shape.length,o.shape,o.shape.length);return n.runWebGLProgram(d,[r,o,l],Object(c.upcastType)(o.dtype,l.dtype))}},wu=Kn({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${c.backend_util.SELU_SCALEALPHA};\n  float scale = ${c.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Iu={kernelName:c.Selu,backendName:"webgl",kernelFunc:wu},Su=Kn({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Jt}),Nu={kernelName:c.Sigmoid,backendName:"webgl",kernelFunc:Su},Tu=Kn({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ju={kernelName:c.Sign,backendName:"webgl",kernelFunc:Tu},Cu=Kn({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),$u={kernelName:c.Sin,backendName:"webgl",kernelFunc:Cu},Eu=Kn({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Au={kernelName:c.Sinh,backendName:"webgl",kernelFunc:Eu},Ru=Kn({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),_u={kernelName:c.Softplus,backendName:"webgl",kernelFunc:Ru},Fu={kernelName:c.SpaceToBatchND,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockShape:l,paddings:d}=r;c.util.assert(o.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const h=l.reduce(((a,b)=>a*b)),f=[[0,0]];f.push(...d);for(let i=1+l.length;i<o.shape.length;++i)f.push([0,0]);const m=[],y=Pi({inputs:{x:o},backend:n,attrs:{paddings:f,constantValue:0}}),x=c.backend_util.getReshaped(y.shape,l,h,!1),v=c.backend_util.getPermuted(x.length,l.length,!1),O=c.backend_util.getReshapedPermuted(y.shape,l,h,!1),k=sr({inputs:{x:y},backend:n,attrs:{shape:x}}),w=gr({inputs:{x:k},backend:n,attrs:{perm:v}}),I=sr({inputs:{x:w},backend:n,attrs:{shape:O}});return m.push(y),m.push(k),m.push(w),m.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};const Du={kernelName:c.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:o,denseShape:c,defaultValue:l}=t;if(1!==c.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${c.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==o.shape.length)throw new Error(`Values must be a vector, saw:\n         ${o.shape}`);if(0!==l.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${l.shape}`);const d=n.readSync(r.dataId),h=n.readSync(o.dataId),f=n.readSync(c.dataId),m=n.readSync(l.dataId)[0],[y,x,v,O,k]=nn(d,r.shape,r.dtype,h,o.dtype,f,m);return[n.makeTensorInfo(x,r.dtype,y),n.makeTensorInfo([x[0]],o.dtype,v),n.makeTensorInfo([O.length],"bool",new Uint8Array(O.map((e=>Number(e))))),n.makeTensorInfo([k.length],r.dtype,new Int32Array(k))]}};const Mu={kernelName:c.SparseReshape,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:o,newShape:c}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==o.shape.length)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(1!==c.shape.length)throw new Error(`Target shape should be a vector but received shape ${c.shape}`);const l=Array.from(n.readSync(o.dataId)),d=n.readSync(r.dataId),h=Array.from(n.readSync(c.dataId)),[f,m,y]=rn(d,r.shape,r.dtype,l,h);return[n.makeTensorInfo(m,r.dtype,f),n.makeTensorInfo([y.length],c.dtype,new Int32Array(y))]}};const Pu={kernelName:c.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const c=n.readSync(data.dataId),l=n.readSync(r.dataId),d=n.readSync(o.dataId),[h,f]=an(c,data.shape,data.dtype,l,d,!0);return n.makeTensorInfo(f,data.dtype,h)}};const Lu={kernelName:c.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const c=n.readSync(data.dataId),l=n.readSync(r.dataId),d=n.readSync(o.dataId),[h,f]=an(c,data.shape,data.dtype,l,d);return n.makeTensorInfo(f,data.dtype,h)}};const Bu={kernelName:c.SparseToDense,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:o,sparseValues:l,defaultValue:d}=t,{outputShape:h}=r,{sliceRank:f,numUpdates:m,sliceSize:y,strides:x,outputSize:v}=c.backend_util.calculateShapes(l,o,h);if("string"===l.dtype){const e=n.bufferSync(o),t=n.bufferSync(l),r=c.util.decodeString(n.readSync(d.dataId)[0]),O=Qt(e,t,h,v,y,m,f,x,r,false);return n.makeTensorInfo(h,O.dtype,O.values)}const O=new gu(m,f,o.shape.length,l.shape.length,x,[v,1],false),k=n.runWebGLProgram(O,[l,o,d],l.dtype),w=sr({inputs:{x:k},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(k),w}};const zu={kernelName:c.SplitV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{numOrSizeSplits:l,axis:d}=r,h=c.util.parseAxisParam(d,o.shape)[0],f=c.backend_util.prepareSplitSize(o,l,h),m=o.shape.length,y=new Array(m).fill(0),x=o.shape.slice();return f.map((s=>{const e=[...x];e[h]=s;const t=ha({inputs:{x:o},backend:n,attrs:{begin:y,size:e}});return y[h]+=s,t}))}},Vu="return sqrt(x);",Wu=Kn({opSnippet:Vu,packedOpSnippet:Vu,cpuKernelImpl:sn}),Uu={kernelName:c.Sqrt,backendName:"webgl",kernelFunc:Wu},Gu=Kn({opSnippet:"return x * x;"}),Hu={kernelName:c.Square,backendName:"webgl",kernelFunc:Gu},qu="return (a - b) * (a - b);",Ku=Xn({opSnippet:qu,packedOpSnippet:qu}),Xu={kernelName:c.SquaredDifference,backendName:"webgl",kernelFunc:Ku};const Yu={kernelName:c.Step,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,o=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,c=new In(r.shape,o);return n.runWebGLProgram(c,[r],r.dtype)}};class Zu{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,o=Le(n.length),c=Le(n.length);let l="";if(1===r)l="coords * strides + begin";else{let e=0;l=n.map(((t,i)=>(e++,1===n.length?`coords * strides[${i}] + begin[${i}]`:`coords[${e-1}] * strides[${i}] + begin[${i}]`))).join(",")}this.userCode=`\n      ${o} begin = ${o}(${e});\n      ${o} strides = ${o}(${t});\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        setOutput(getX(${l}));\n      }\n    `}}const Qu={kernelName:c.StridedSlice,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{begin:l,end:d,strides:h,beginMask:f,endMask:m,ellipsisMask:y,newAxisMask:x,shrinkAxisMask:v}=r,{finalShapeSparse:O,finalShape:k,isIdentity:w,sliceDim0:I,isSimpleSlice:S,begin:N,end:T,strides:j}=c.slice_util.sliceInfo(o.shape,l,d,h,f,m,y,x,v);let C;if(w)C=sr({inputs:{x:o},backend:n,attrs:{shape:k}});else if(I||S){c.util.assert(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const e=c.slice_util.computeOutShape(N,T,j),t=ha({inputs:{x:o},backend:n,attrs:{begin:N,size:e}});C=sr({inputs:{x:t},backend:n,attrs:{shape:k}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([o])){const e=n.readSync(o.dataId),t=Object(c.buffer)(o.shape,o.dtype,e),r=on(O,t,j,N);C=n.makeTensorInfo(k,o.dtype,r.values)}else{const e=new Zu(N,j,O);C=n.runWebGLProgram(e,[o],o.dtype)}}const $=sr({inputs:{x:C},backend:n,attrs:{shape:k}});return n.disposeIntermediateTensorInfo(C),$}};const Ju={kernelName:c.StringNGrams,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:o,nGramWidths:c,leftPad:l,rightPad:d,padWidth:h,preserveShortSequences:f}=r,{data:data,dataSplits:m}=t,y=n.readSync(data.dataId),x=n.readSync(m.dataId),[v,O]=un(y,x,o,c,l,d,h,f);return[n.makeTensorInfo([v.length],"string",v),n.makeTensorInfo(m.shape,"int32",O)]}};const ec={kernelName:c.StringSplit,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:o}=r,{input:input,delimiter:c}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(1!==input.shape.length)throw new Error(`Input must be a vector, got shape: ${input.shape}`);if(0!==c.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${c.shape}`);const l=n.readSync(input.dataId),d=n.readSync(c.dataId)[0],[h,f,m]=cn(l,d,o),y=f.length;return[n.makeTensorInfo([y,2],"int32",h),n.makeTensorInfo([y],"string",f),n.makeTensorInfo([2],"int32",new Int32Array(m))]}};const tc={kernelName:c.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:o}=r,{input:input}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const c=n.readSync(input.dataId),output=ln(c,o);return n.makeTensorInfo(input.shape,"int32",output)}},nc=Kn({opSnippet:"return tan(x);"}),rc={kernelName:c.Tan,backendName:"webgl",kernelFunc:nc},ac=Kn({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),sc={kernelName:c.Tanh,backendName:"webgl",kernelFunc:ac};class oc{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;const r=Le(this.rank),o=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<e.length;i++)r.push(`imod(${n[i]}, ${e[i]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function ic(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{reps:l}=r;if("string"===o.dtype||o.shape.length>5){const data=n.readSync(o.dataId),e="string"===o.dtype?data.map((e=>c.util.decodeString(e))):data,t=Object(c.buffer)(o.shape,o.dtype,e),r=pn(t,l);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const d=new oc(o.shape,l);return n.runWebGLProgram(d,[o],o.dtype)}const uc={kernelName:c.Tile,backendName:"webgl",kernelFunc:ic};class cc{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class lc{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function dc(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function pc(e){let t=1;for(;t<e;)t*=2;return t}const hc={kernelName:c.TopK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{k:l,sorted:d}=r,h=Object(c.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),f=Object(c.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),m=o.shape,y=m[m.length-1];if(n.shouldExecuteOnCPU([o])||y<h||l>f){const e=n.readSync(o.dataId),[t,r]=hn(e,m,o.dtype,l,d);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===l)return m[m.length-1]=0,[n.makeTensorInfo(m,o.dtype,[]),n.makeTensorInfo(m,"int32",[])];if(1===y)return[o,Xs({attrs:{shape:m,dtype:"int32",value:0},backend:n})];const x=n.texData.get(o.dataId),v=null!==x&&x.isPacked,O=v?n.unpackTensor(o):o,k=c.util.sizeFromShape(m)/y,w=sr({inputs:{x:O},attrs:{shape:[k,y]},backend:n});v&&dc(n,O);const I=pc(l),S=pc(y);let N=null;const T=()=>null===N?[w,w]:[w,N],j=(e,t,r)=>{const o=T(),c=new cc(r),l=[[y],[null===N?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],d=N;N=n.runWebGLProgram(c,o,"int32",l),dc(n,d)};for(let e=1;e<I;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)j(t,n,[k,S])}for(let e=S;e>I;e/=2){const t=T(),r=new lc([k,e/2]),o=[[y],[null===N?1:0],[I]],c=N;N=n.runWebGLProgram(r,t,"int32",o),dc(n,c);const l=I/2,d=2*l;for(let e=l;e>=1;e/=2)j(d,e,N.shape)}let C=N;N=ha({inputs:{x:N},backend:n,attrs:{begin:0,size:[k,l]}}),dc(n,C);let $=mo({inputs:{x:w,indices:N},backend:n,attrs:{axis:1,batchDims:1}});dc(n,w);const E=m.slice(0,-1);E.push(l),C=N,N=sr({inputs:{x:N},attrs:{shape:E},backend:n}),dc(n,C);const A=$;return $=sr({inputs:{x:$},attrs:{shape:E},backend:n}),dc(n,A),[$,N]}};class fc{constructor(e,t,n,r,o,c){this.variableNames=["Image","Transforms"],this.outputShape=c;const l="nearest"===n?1:2;let d;switch(r){case"constant":default:d=1;break;case"reflect":d=2;break;case"wrap":d=3;break;case"nearest":d=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${d} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${l} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const mc={kernelName:c.Transform,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:image,transforms:o}=t,{interpolation:c,fillMode:l,fillValue:d,outputShape:h}=r,[f,m,y,x]=image.shape,[v,O]=null!=h?h:[m,y],k=new fc(m,y,c,l,d,[f,v,O,x]);return n.runWebGLProgram(k,[image,o],"float32")}};const bc={kernelName:c.Unique,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:o}=n,{x:c}=t;ve(c,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const l=r.readSync(c.dataId),{outputValues:d,outputShape:h,indices:f}=mn(l,o,c.shape,c.dtype);return[r.makeTensorInfo(h,c.dtype,d),r.makeTensorInfo([f.length],"int32",f)]}};const gc={kernelName:c.Unpack,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:o}=t;let{axis:c}=r;c<0&&(c+=o.shape.length);const l=o,d=l.shape.length,h=o.shape[c],f=new Array(d-1);let m=0;for(let i=0;i<d;i++)i!==c&&(f[m++]=l.shape[i]);const y=[],x=new Array(d).fill(0),v=l.shape.slice();v[c]=1;const O=new Array(h);for(let i=0;i<O.length;i++){x[c]=i;const e=ha({inputs:{x:l},backend:n,attrs:{begin:x,size:v}}),t=sr({inputs:{x:e},backend:n,attrs:{shape:f}});O[i]=t,y.push(e)}return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),O}};class yc{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,o=e.inSize,c=e.numSegments,l=c*Math.ceil(o/n);this.outputShape=[r,l];const d=4*Math.floor(n/4),h=n%4,f="\n        sumValue += dot(values, segFilter);\n    ";let m="";o%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let y="";o%n>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${y}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${c})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${c})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${2===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${3===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(sumValue);\n      }\n    `}}const xc=[vr,kr,Ir,Nr,Cr,Ar,Rr,_r,Br,zr,Wr,Gr,qr,Xr,Zr,ea,ta,aa,sa,oa,ca,ma,ba,ga,ka,Sa,ja,zn,Ea,La,qa,Qa,Ja,es,ts,ns,as,os,us,fs,ms,bs,ys,Os,Is,Ss,Ts,Cs,$s,As,Rs,Fs,Ms,Ls,zs,Us,qs,Ys,Qs,to,ro,oo,co,lo,ho,bo,yo,vo,Ln,Oo,Da,wo,So,To,Un,Co,Eo,Ao,_o,Do,Po,Bo,Vo,Go,qo,Xo,Zo,Qo,Jo,ni,ri,ai,si,oi,ui,pi,fi,ki,ar,wi,Si,Ti,Ci,xa,Ei,_i,Fi,Li,zi,qn,Vi,Wi,Gi,Oa,gi,qi,Xi,Zi,or,eu,nu,su,iu,lu,pu,fu,bu,yu,vu,ku,Iu,Nu,ju,$u,Au,fa,Oi,_u,Fu,Du,Mu,Pu,Lu,Bu,zu,Uu,Hu,Xu,Yu,Qu,Ju,ec,tc,xi,mr,rc,sc,uc,hc,mc,yr,bc,gc,{kernelName:c.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,segmentIds:l}=t,{numSegments:d}=r,h=o.shape.length,f=[];let m=0;const y=c.backend_util.getAxesPermutation([m],h);let x=o;null!=y&&(x=gr({inputs:{x:o},backend:n,attrs:{perm:y}}),f.push(x),m=c.backend_util.getInnerMostAxes(1,h)[0]);const v=c.backend_util.segment_util.computeOutShape(x.shape,m,d),O=c.util.sizeFromShape([x.shape[m]]),k=sr({inputs:{x:x},backend:n,attrs:{shape:[-1,O]}});f.push(k);const w=Object(c.sumOutType)(o.dtype),I=(e,t,r,o,l)=>{const d=e.shape[0],h=e.shape[1],m=c.backend_util.segment_util.segOpComputeOptimalWindowSize(h,l),y=new yc({windowSize:m,inSize:h,batchSize:d,numSegments:l},t),output=n.compileAndRun(y,[e,r],o);if(f.push(output),output.shape[1]===l)return output;const x=Ui({backend:n,attrs:{start:0,stop:l,step:1,dtype:"float32"}}),v=ic({inputs:{x:x},backend:n,attrs:{reps:[h/m]}});f.push(x),f.push(v);return I(output,t,v,o,l)},S=sr({inputs:{x:I(k,"unsortedSegmentSum",l,w,d)},backend:n,attrs:{shape:v}});let N=S;if(null!=y){f.push(S);const e=c.backend_util.getUndoAxesPermutation(y);N=gr({inputs:{x:N},backend:n,attrs:{perm:e}})}return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}},Ri];for(const e of xc)Object(c.registerKernel)(e)},function(e,t,n){"use strict";n.r(t),n.d(t,"MathBackendCPU",(function(){return l})),n.d(t,"version_cpu",(function(){return h})),n.d(t,"shared",(function(){return d}));var r=n(279),o=n(285);const c=r.kernel_impls.whereImpl;class l extends r.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new r.DataStorage(this,Object(r.engine)())}nextDataId(){return l.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,Object(r.env)().get("IS_NODE")&&r.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if("string"===t&&null!=n&&n.length>0&&r.util.isString(n[0])){const c=n.map((e=>r.util.encodeString(e)));o=this.write(c,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,o){this.data.set(e,{values:t,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return r.backend_util.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const data=this.readSync(e.dataId);if("string"===e.dtype)try{const t=data.map((e=>r.util.decodeString(e)));return Object(r.buffer)(e.shape,e.dtype,t)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(r.buffer)(e.shape,e.dtype,data)}makeOutput(e,t,n){return Object(r.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=r.util.now();e();return{kernelMs:r.util.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Object(o.a)([e],"where");const t=this.readSync(e.dataId);return c(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}l.nextDataId=0;var d=n(371);const h="3.20.0";Object(r.registerBackend)("cpu",(()=>new l),1);var f=n(287);const m=Object(f.a)(r.Elu,(e=>e>=0?e:Math.exp(e)-1)),y={kernelName:r.Elu,backendName:"cpu",kernelFunc:m};var x=n(313);function v(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{alpha:d}=c;Object(o.a)([l],"leakyRelu");const h=r.util.sizeFromShape(l.shape),f=n.data.get(l.dataId).values,m=r.util.getTypedArrayFromDType("float32",h);for(let i=0;i<f.length;i++)m[i]=f[i]<0?d*f[i]:f[i];return n.makeTensorInfo(l.shape,"float32",m)}const O={kernelName:r.LeakyRelu,backendName:"cpu",kernelFunc:v};var k=n(293);const w=Object(k.a)(((e,t)=>e<0?t*e:e));function I(e){const{inputs:t,backend:n}=e,{x:r,alpha:c}=t;Object(o.a)([r,c],"prelu");const l=n.data.get(r.dataId).values,d=n.data.get(c.dataId).values,[h,f]=w(r.shape,c.shape,l,d,"float32");return n.makeTensorInfo(f,"float32",h)}const S={kernelName:r.Prelu,backendName:"cpu",kernelFunc:I},N=Object(f.a)(r.Relu,(e=>Math.max(0,e))),T={kernelName:r.Relu,backendName:"cpu",kernelFunc:N},j=Object(f.a)(r.Relu6,(e=>Math.min(Math.max(0,e),6))),C={kernelName:r.Relu6,backendName:"cpu",kernelFunc:j};var $=n(355);function E(e,t,n,r,o){if("linear"===n)return Object(x.a)({inputs:{x:t},backend:e});if("relu"===n)return N({inputs:{x:t},backend:e});if("elu"===n)return m({inputs:{x:t},backend:e});if("relu6"===n)return j({inputs:{x:t},backend:e});if("prelu"===n)return I({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return v({inputs:{x:t},backend:e,attrs:{alpha:o}});if("sigmoid"===n)return Object($.a)({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}var A=n(324);function R(e){const{inputs:t,backend:n,attrs:o}=e,{x:c}=t,{shape:l}=o,d=r.util.sizeFromShape(c.shape),h=r.util.inferFromImplicitShape(l,d),f=r.util.sizeFromShape(h);r.util.assert(d===f,(()=>`The new shape (${h}) has ${f} elements and the old shape (${c.shape}) has ${d} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(c.dataId);const m=n.data.get(c.dataId);if(null!=m.complexTensorInfos){const e=m.complexTensorInfos.real,t=m.complexTensorInfos.imag;e.shape=h,t.shape=h}return{dataId:c.dataId,shape:h,dtype:c.dtype}}const _={kernelName:r.Reshape,backendName:"cpu",kernelFunc:R};function F(e){const{inputs:t,backend:n,attrs:c}=e,{a:a,b:b}=t,{transposeA:l,transposeB:d}=c;Object(o.a)([a,b],"matMul");const h=a.shape.length,f=b.shape.length,m=l?a.shape[h-2]:a.shape[h-1],y=d?b.shape[f-1]:b.shape[f-2],x=l?a.shape[h-1]:a.shape[h-2],v=d?b.shape[f-2]:b.shape[f-1],O=a.shape.slice(0,-2),k=b.shape.slice(0,-2),w=r.util.sizeFromShape(O),I=r.util.sizeFromShape(k),S=r.broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)).concat([x,v]);r.util.assert(m===y,(()=>`Error in matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${l} and transposeB=${d} must match.`));const N=d?[I,v,y]:[I,y,v],T=R({inputs:{x:a},backend:n,attrs:{shape:l?[w,m,x]:[w,x,m]}}),j=R({inputs:{x:b},backend:n,attrs:{shape:N}}),C=l?T.shape[1]:T.shape[2],$=l?T.shape[2]:T.shape[1],E=d?j.shape[1]:j.shape[2],A=Math.max(w,I),_=n.data.get(T.dataId).values,F=n.data.get(j.dataId).values,D=r.util.computeStrides(T.shape),M=r.util.computeStrides(j.shape),[P,L,B]=l?[D[0],1,D[1]]:[D[0],D[1],1],[z,V,W]=d?[1,M[1],M[0]]:[M[1],1,M[0]],U=$*E,G=Object(r.buffer)([A,$,E],T.dtype),H=G.values,K=n.blockSize;for(let e=0;e<A;e++)for(let t=0;t<$;t+=K)for(let n=0;n<E;n+=K)for(let r=0;r<C;r+=K){const o=Math.min(t+K,$),c=Math.min(n+K,E),l=Math.min(r+K,C);for(let i=t;i<o;i++)for(let t=n;t<c;t++){let n=0;for(let o=r;o<l;o++){const r=Math.min(e,w-1)*P,c=Math.min(e,I-1)*W;n+=_[r+i*L+o*B]*F[o*z+t*V+c]}H[e*U+(i*E+t)]+=n}}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(j),n.makeTensorInfo(S,G.dtype,G.values)}const D={kernelName:r.BatchMatMul,backendName:"cpu",kernelFunc:F};const M={kernelName:r._FusedMatMul,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:b,bias:o,preluActivationWeights:c}=t,{transposeA:l,transposeB:d,activation:h,leakyreluAlpha:f}=r;let m,y,x;const v=[];m=F({inputs:{a:a,b:b},attrs:{transposeA:l,transposeB:d},backend:n}),o&&(y=Object(A.a)({inputs:{a:m,b:o},backend:n}),v.push(m),m=y),h&&(x=E(n,m,h,c,f),v.push(m),m=x);for(const i of v)n.disposeIntermediateTensorInfo(i);return m}};var P=n(372);const L=Object(f.a)(r.Acos,(e=>Math.acos(e))),B={kernelName:r.Acos,backendName:"cpu",kernelFunc:L},z=Object(f.a)(r.Acosh,(e=>Math.acosh(e))),V={kernelName:r.Acosh,backendName:"cpu",kernelFunc:z};const W={kernelName:r.AddN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,c=t;Object(o.a)(t,"addN");const l=c.map((e=>n.data.get(e.dataId).values)),d=Object(r.buffer)(c[0].shape,c[0].dtype),h=d.values;for(let i=0;i<c.length;i++){const e=l[i];for(let t=0;t<h.length;t++)h[t]+=e[t]}return n.makeTensorInfo(d.shape,d.dtype,d.values)}};var U=n(303);const G={kernelName:r.All,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,keepDims:h}=c;Object(o.a)(l,"all");const f=r.util.parseAxisParam(d,l.shape);let m=f;const y=r.backend_util.getAxesPermutation(m,l.shape.length);let x=l;null!=y&&(x=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:y}}),m=r.backend_util.getInnerMostAxes(m.length,l.shape.length)),r.backend_util.assertAxesAreInnerMostDims("all",m,x.shape.length);const[v,O]=r.backend_util.computeOutAndReduceShapes(x.shape,m),k=r.util.sizeFromShape(O),w=r.util.makeZerosTypedArray(r.util.sizeFromShape(v),x.dtype),I=n.data.get(x.dataId).values;for(let i=0;i<w.length;++i){const e=i*k;let t=I[e];for(let n=0;n<k;++n){const r=I[e+n];t=t&&r}w[i]=t}null!=y&&n.disposeIntermediateTensorInfo(x);const S=n.makeTensorInfo(v,x.dtype,w);if(h){const e=R({inputs:{x:S},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(v,f)}});return n.disposeIntermediateTensorInfo(S),e}return S}};const H={kernelName:r.Any,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,keepDims:h}=c;Object(o.a)(l,"any");const f=r.util.parseAxisParam(d,l.shape);let m=f;const y=r.backend_util.getAxesPermutation(m,l.shape.length);let x=l;null!=y&&(x=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:y}}),m=r.backend_util.getInnerMostAxes(m.length,l.shape.length)),r.backend_util.assertAxesAreInnerMostDims("any",m,x.shape.length);const[v,O]=r.backend_util.computeOutAndReduceShapes(x.shape,m),k=r.util.sizeFromShape(O),w=r.util.makeZerosTypedArray(r.util.sizeFromShape(v),x.dtype),I=n.data.get(x.dataId).values;for(let i=0;i<w.length;++i){const e=i*k;let t=I[e];for(let n=0;n<k;++n){const r=I[e+n];t=t||r}w[i]=t}null!=y&&n.disposeIntermediateTensorInfo(x);const S=n.makeTensorInfo(v,x.dtype,w);if(h){const e=R({inputs:{x:S},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(v,f)}});return n.disposeIntermediateTensorInfo(S),e}return S}};const K={kernelName:r.ArgMax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d}=c;Object(o.a)(l,"argMax");let h=r.util.parseAxisParam(d,l.shape);const f=r.backend_util.getAxesPermutation(h,l.shape.length);let m=l;const y=[];null!=f&&(m=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:f}}),y.push(m),h=r.backend_util.getInnerMostAxes(h.length,m.shape.length)),h=[h[0]],r.backend_util.assertAxesAreInnerMostDims("argMax",h,m.shape.length);const[x,v]=r.backend_util.computeOutAndReduceShapes(m.shape,h),O=r.util.sizeFromShape(x),k=r.util.makeZerosTypedArray(O,"int32"),w=r.util.sizeFromShape(v),I=n.data.get(m.dataId).values;for(let i=0;i<k.length;++i){const e=i*w;let t=I[e],n=0;for(let r=0;r<w;++r){const o=I[e+r];o>t&&(t=o,n=r)}k[i]=n}return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(x,"int32",k)}};const X={kernelName:r.ArgMin,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d}=c;Object(o.a)(l,"argMin");let h=r.util.parseAxisParam(d,l.shape);const f=r.backend_util.getAxesPermutation(h,l.shape.length);let m=l;const y=[];null!=f&&(m=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:f}}),y.push(m),h=r.backend_util.getInnerMostAxes(h.length,m.shape.length)),h=[h[0]],r.backend_util.assertAxesAreInnerMostDims("argMin",h,m.shape.length);const[x,v]=r.backend_util.computeOutAndReduceShapes(m.shape,h),O=r.util.sizeFromShape(x),k=r.util.makeZerosTypedArray(O,"int32"),w=r.util.sizeFromShape(v),I=n.data.get(m.dataId).values;for(let i=0;i<k.length;++i){const e=i*w;let t=I[e],n=0;for(let r=0;r<w;++r){const o=I[e+r];o<t&&(t=o,n=r)}k[i]=n}return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(x,"int32",k)}},Y=Object(f.a)(r.Asin,(e=>Math.asin(e))),Z={kernelName:r.Asin,backendName:"cpu",kernelFunc:Y},Q=Object(f.a)(r.Asinh,(e=>Math.asinh(e))),J={kernelName:r.Asinh,backendName:"cpu",kernelFunc:Q},ee=Object(f.a)(r.Atan,(e=>Math.atan(e))),te={kernelName:r.Atan,backendName:"cpu",kernelFunc:ee};var ne=n(296);const re=Object(k.a)(((e,t)=>Math.atan2(e,t))),ae=Object(ne.a)(r.Atan2,re),se={kernelName:r.Atan2,backendName:"cpu",kernelFunc:ae},oe=Object(f.a)(r.Atanh,(e=>Math.atanh(e))),ie={kernelName:r.Atanh,backendName:"cpu",kernelFunc:oe};function ue(e,t,n,o,c,l){const d=c.strideHeight,h=c.strideWidth,f=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=c.padInfo.top,O=c.padInfo.left,k="max"===l?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,output=Object(r.buffer)(c.outShape,n),w=output.values,I=c.outShape[1]*c.outShape[2]*c.outShape[3],S=c.outShape[2]*c.outShape[3],N=c.outShape[3];for(let b=0;b<c.batchSize;++b){const t=b*I,n=b*o[0];for(let r=0;r<c.inChannels;++r)for(let I=0;I<c.outHeight;++I){const T=I*d-v,j=Math.max(0,T),C=Math.min(c.inHeight,y+T),$=t+I*S;for(let t=0;t<c.outWidth;++t){const d=t*h-O,y=Math.max(0,d),v=Math.min(c.inWidth,x+d);let I=k,S=0,T=0;for(let t=j;t<C;t+=f){const c=n+t*o[1];for(let t=y;t<v;t+=m){const n=e[c+t*o[2]+r];"max"===l&&n>I?I=n:"avg"===l&&(S+=n,T++)}if(isNaN(I))break}w[$+t*N+r]="avg"===l?S/T:I}}}return output}function ce(e,t,n,o,c=!1,l=!1){const d=Object(r.buffer)(o.outShape,"int32"),h=o.strideHeight,f=o.strideWidth,m=o.dilationHeight,y=o.dilationWidth,x=o.effectiveFilterHeight,v=o.effectiveFilterWidth,O=o.padInfo.top,k=o.padInfo.left,w=Object(r.buffer)(t,n,e);for(let b=0;b<o.batchSize;++b)for(let e=0;e<o.inChannels;++e)for(let t=0;t<o.outHeight;++t){const n=t*h-O;let r=n;for(;r<0;)r+=m;const I=Math.min(o.inHeight,x+n);for(let h=0;h<o.outWidth;++h){const x=h*f-k;let O=x;for(;O<0;)O+=y;const S=Math.min(o.inWidth,v+x);let N=Number.NEGATIVE_INFINITY,T=-1;for(let t=r;t<I;t+=m){const r=t-n;for(let n=O;n<S;n+=y){const d=n-x,h=w.get(b,t,n,e);h>N&&(N=h,T=c?l?((b*o.inHeight+t)*o.inWidth+n)*o.inChannels+e:(t*o.inWidth+n)*o.inChannels+e:r*v+d)}}d.set(T,b,t,h,e)}}return d}function le(e,t,n,o,c,l){const d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,O=c.effectiveFilterHeight,k=c.effectiveFilterWidth,w=c.padInfo.front,I=c.padInfo.top,S=c.padInfo.left,N="max"===l?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,output=Object(r.buffer)(c.outShape,n),T=output.values,j=c.outShape[1]*c.outShape[2]*c.outShape[3]*c.outShape[4],C=c.outShape[2]*c.outShape[3]*c.outShape[4],$=c.outShape[3]*c.outShape[4],E=c.outShape[4];for(let t=0;t<c.batchSize;++t){const n=t*j,r=t*o[0];for(let t=0;t<c.inChannels;++t)for(let j=0;j<c.outDepth;++j){const A=j*d-w;let R=A;for(;R<0;)R+=m;const _=Math.min(c.inDepth,v+A),F=n+j*C;for(let n=0;n<c.outHeight;++n){const d=n*h-I;let v=d;for(;v<0;)v+=y;const w=Math.min(c.inHeight,O+d),j=F+n*$;for(let n=0;n<c.outWidth;++n){const d=n*f-S;let h=d;for(;h<0;)h+=x;const O=Math.min(c.inWidth,k+d),I=j+n*E;let C=N,$=0,A=0;for(let n=R;n<_;n+=m){const c=r+n*o[1];for(let n=v;n<w;n+=y){const r=c+n*o[2];for(let n=h;n<O;n+=x){const c=e[r+n*o[3]+t];if("max"===l&&c>C?C=c:"avg"===l&&($+=c,A++),isNaN(C))break}if(isNaN(C))break}if(isNaN(C))break}T[I+t]="avg"===l?$/A:C}}}}return output}const de={kernelName:r.AvgPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t;Object(o.a)(l,"avgPool");const{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=c;r.util.assert(r.backend_util.eitherStridesOrDilationsAreOne(h,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${h} and dilations '1'`));const y=r.backend_util.computePool2DInfo(l.shape,d,h,1,f,m);let v;if(1===y.filterWidth&&1===y.filterHeight&&r.util.arraysEqual(y.inShape,y.outShape))v=Object(x.a)({inputs:{x:l},backend:n});else{const e=n.data.get(l.dataId).values,t=r.util.computeStrides(l.shape),o=ue(e,l.shape,l.dtype,t,y,"avg");v=n.makeTensorInfo(y.outShape,l.dtype,o.values)}return v}};const pe={kernelName:r.AvgPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{filterSize:d,strides:h,pad:f,dimRoundingMode:m,dataFormat:y}=c;Object(o.a)(l,"avgPool3d");const x=r.backend_util.computePool3DInfo(l.shape,d,h,1,f,m,y),v=le(n.data.get(l.dataId).values,l.shape,l.dtype,r.util.computeStrides(l.shape),x,"avg");return n.makeTensorInfo(v.shape,"float32",v.values)}};const he={kernelName:r.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,input:input}=t,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=c;Object(o.a)([l,input],"avgPool3DGrad");const y=r.backend_util.computePool3DInfo(input.shape,d,h,1,f,m),x=y.strideDepth,v=y.strideHeight,O=y.strideWidth,k=y.filterDepth,w=y.filterHeight,I=y.filterWidth,S=y.dilationDepth,N=y.dilationHeight,T=y.dilationWidth,j=y.effectiveFilterDepth,C=y.effectiveFilterHeight,$=y.effectiveFilterWidth,E=j-1-y.padInfo.front,A=$-1-y.padInfo.left,R=C-1-y.padInfo.top,_=Object(r.buffer)(input.shape,"float32"),F=1/(k*w*I),D=n.bufferSync(l);for(let e=0;e<y.batchSize;++e)for(let t=0;t<y.inChannels;++t)for(let n=0;n<y.inDepth;++n)for(let r=0;r<y.inHeight;++r)for(let o=0;o<y.inWidth;++o){const c=n-E,l=r-R,d=o-A;let h=0;for(let n=0;n<j;n+=S){const r=(c+n)/x;if(!(r<0||r>=y.outDepth||Math.floor(r)!==r))for(let n=0;n<C;n+=N){const o=(l+n)/v;if(!(o<0||o>=y.outHeight||Math.floor(o)!==o))for(let n=0;n<$;n+=T){const c=(d+n)/O;if(c<0||c>=y.outWidth||Math.floor(c)!==c)continue;h+=D.get(e,r,o,c,t)}}}_.set(h*F,e,n,r,o,t)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}};const fe={kernelName:r.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,input:input}=t,d=input;Object(o.a)([l,input],"avgPoolGrad");const{filterSize:h,strides:f,pad:m}=c,y=r.backend_util.computePool2DInfo(d.shape,h,f,1,m),x=y.strideHeight,v=y.strideWidth,O=y.filterHeight,k=y.filterWidth,w=y.dilationHeight,I=y.dilationWidth,S=y.effectiveFilterHeight,N=y.effectiveFilterWidth,T=N-1-y.padInfo.left,j=S-1-y.padInfo.top,C=Object(r.buffer)(d.shape,"float32"),$=1/(O*k),E=n.data.get(l.dataId).values,A=Object(r.buffer)(l.shape,"float32",E);for(let b=0;b<y.batchSize;++b)for(let e=0;e<y.inChannels;++e)for(let t=0;t<y.inHeight;++t)for(let n=0;n<y.inWidth;++n){const r=t-j,o=n-T;let c=0;for(let t=0;t<S;t+=w){const n=(r+t)/x;if(!(n<0||n>=y.outHeight||Math.floor(n)!==n))for(let t=0;t<N;t+=I){const r=(o+t)/v;if(r<0||r>=y.outWidth||Math.floor(r)!==r)continue;c+=A.get(b,n,r,e)}}C.set(c*$,b,t,n,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const me={kernelName:r.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,scale:d,offset:h,mean:f,variance:m}=t;r.util.assert(f.shape.length===m.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),r.util.assert(null==h||f.shape.length===h.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),r.util.assert(null==d||f.shape.length===d.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),Object(o.a)([l,f,m,d,h],"batchNorm");let{varianceEpsilon:y}=c;null==y&&(y=.001);const x=n.data.get(l.dataId).values,v=n.data.get(f.dataId).values,O=n.data.get(m.dataId).values,k=d?n.data.get(d.dataId).values:new Float32Array([1]),w=h?n.data.get(h.dataId).values:new Float32Array([0]),I=new Float32Array(x.length),S=w.length,N=k.length,T=O.length,j=v.length;let C=0,$=0,E=0,A=0;for(let i=0;i<x.length;++i)I[i]=w[C++]+(x[i]-v[$++])*k[E++]/Math.sqrt(O[A++]+y),C>=S&&(C=0),$>=j&&($=0),E>=N&&(E=0),A>=T&&(A=0);return n.makeTensorInfo(l.shape,l.dtype,I)}};var be=n(319);const ge={kernelName:r.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{blockShape:d,crops:h}=c;Object(o.a)([l],"batchToSpaceND");const f=d.reduce(((a,b)=>a*b)),m=r.backend_util.getReshaped(l.shape,d,f),y=r.backend_util.getPermuted(m.length,d.length),x=r.backend_util.getReshapedPermuted(l.shape,d,f),v=r.backend_util.getSliceBeginCoords(h,d.length),O=r.backend_util.getSliceSize(x,h,d.length),k=R({inputs:{x:l},backend:n,attrs:{shape:m}}),w=Object(U.a)({inputs:{x:k},backend:n,attrs:{perm:y}}),I=R({inputs:{x:w},backend:n,attrs:{shape:x}}),S=Object(be.a)({inputs:{x:I},backend:n,attrs:{begin:v,size:O}});return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),S}};var ye=n(345);const xe={kernelName:r.Bincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l}=r,d=n.data.get(o.dataId).values,h=n.data.get(c.dataId).values,f=Object(ye.a)(d,h,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,f)}};const ve={kernelName:r.BroadcastArgs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:o,s1:c}=t,l=n.data.get(o.dataId).values,d=n.data.get(c.dataId).values,h=r.backend_util.assertAndGetBroadcastShape(Array.from(l),Array.from(d));return n.makeTensorInfo([h.length],"int32",Int32Array.from(h))}};var Oe=n(325),ke=n(373);const we=Object(f.a)(r.ClipByValue,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),Ie={kernelName:r.ClipByValue,backendName:"cpu",kernelFunc:we};var Se=n(317);const Ne={kernelName:r.ComplexAbs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,o=new Float32Array(r.util.sizeFromShape(t.shape)),c=n.data.get(t.dataId),l=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,h=n.data.get(l.dataId).values,f=n.data.get(d.dataId).values;for(let i=0;i<h.length;i++){const e=h[i],t=f[i];o[i]=Math.hypot(e,t)}return n.makeOutput(o,t.shape,"float32")}};var Te=n(374);function je(e){const{inputs:t,backend:n}=e,{input:input}=t,r=n.data.get(input.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const Ce={kernelName:r.Imag,backendName:"cpu",kernelFunc:je};var $e=n(333);function Ee(e){const{inputs:t,backend:n,attrs:o}=e,{axis:c}=o,l=r.util.parseAxisParam(c,t[0].shape)[0];let d=r.backend_util.computeOutShape(t.map((e=>e.shape)),l);if(0===r.util.sizeFromShape(d))return n.makeTensorInfo(d,t[0].dtype,[]);const h=t.filter((e=>r.util.sizeFromShape(e.shape)>0));if(1===h.length)return Object(x.a)({inputs:{x:h[0]},backend:n});const f=h.map((e=>e.shape));if(r.backend_util.assertParamsConsistent(f,l),"complex64"===h[0].dtype){const e=h.map((e=>Object($e.a)({inputs:{input:e},backend:n}))),t=h.map((e=>je({inputs:{input:e},backend:n}))),r=Ee({inputs:e,backend:n,attrs:{axis:l}}),o=Ee({inputs:t,backend:n,attrs:{axis:l}}),c=Object(Se.a)({inputs:{real:r,imag:o},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((i=>n.disposeIntermediateTensorInfo(i))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),c}const m=h.map((e=>{const t=r.util.sizeFromShape(e.shape.slice(l));return R({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),y=m.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));d=r.backend_util.computeOutShape(m.map((e=>e.shape)),1);const v=1===m[0].shape[0],O=Object(Te.a)(y,d,t[0].dtype,v),k=r.backend_util.computeOutShape(h.map((e=>e.shape)),l),w=n.makeTensorInfo(k,t[0].dtype,O);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}const Ae={kernelName:r.Concat,backendName:"cpu",kernelFunc:Ee};function Re(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,filter:filter}=t,{strides:d,pad:h,dataFormat:f,dilations:m,dimRoundingMode:y}=c;Object(o.a)([l,filter],"conv2d");const x=r.backend_util.convertConv2DDataFormat(f),v=r.backend_util.computeConv2DInfo(l.shape,filter.shape,d,m,h,y,!1,x),O=v.filterHeight,k=v.filterWidth,w=v.dilationHeight,I=v.dilationWidth,S=v.padInfo.left,N=v.padInfo.top,T="channelsLast"===v.dataFormat,j=new r.TensorBuffer(v.outShape,l.dtype),C=r.util.computeStrides(l.shape),$=r.util.computeStrides(filter.shape),E=C[0],A=T?C[1]:C[2],R=T?C[2]:1,_=T?1:C[1],F=j.strides[0],D=T?j.strides[1]:j.strides[2],M=T?j.strides[2]:1,P=T?1:j.strides[1],L=n.data.get(l.dataId).values,B=n.data.get(filter.dataId).values,z=j.values;for(let b=0;b<v.batchSize;++b){const e=b*E,t=b*F;for(let n=0;n<v.outHeight;++n){const r=t+n*D,o=n*v.strideHeight-N;for(let t=0;t<O;++t){const n=o+t*w;if(n<0||n>=v.inHeight)continue;const c=t*$[0],l=e+n*A;for(let e=0;e<v.outWidth;++e){const t=r+e*M,n=e*v.strideWidth-S;for(let e=0;e<k;++e){const r=n+e*I;if(r<0||r>=v.inWidth)continue;const o=l+r*R;let d=c+e*$[1];for(let e=0;e<v.inChannels;++e){const n=L[o+e*_];for(let e=0;e<v.outChannels;++e)z[t+e*P]+=n*B[d+e];d+=v.outChannels}}}}}}return n.makeTensorInfo(j.shape,j.dtype,z)}const _e={kernelName:r.Conv2D,backendName:"cpu",kernelFunc:Re};const Fe={kernelName:r.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,dy:d}=t,{strides:h,pad:f,dataFormat:m,dimRoundingMode:y,filterShape:x}=c;Object(o.a)([l,d],"conv2dBackpropFilter");const v=r.backend_util.convertConv2DDataFormat(m),O=r.backend_util.computeConv2DInfo(l.shape,x,h,1,f,y,!1,v),{strideHeight:k,strideWidth:w,filterHeight:I,filterWidth:S}=O,N="channelsLast"===O.dataFormat,T=new r.TensorBuffer(O.filterShape,"float32"),j=O.padInfo.left,C=O.padInfo.top,$=n.data.get(l.dataId).values,E=n.data.get(d.dataId).values,A=new r.TensorBuffer(l.shape,l.dtype,$),R=new r.TensorBuffer(d.shape,d.dtype,E);for(let e=0;e<I;++e){const t=Math.max(0,Math.ceil((C-e)/k)),n=Math.min(O.outHeight,(O.inHeight+C-e)/k);for(let r=0;r<S;++r){const o=Math.max(0,Math.ceil((j-r)/w)),c=Math.min(O.outWidth,(O.inWidth+j-r)/w);for(let l=0;l<O.inChannels;++l)for(let d=0;d<O.outChannels;++d){let h=0;for(let b=0;b<O.batchSize;++b)for(let f=t;f<n;++f){const t=e+f*k-C;for(let e=o;e<c;++e){const n=r+e*w-j;h+=N?A.get(b,t,n,l)*R.get(b,f,e,d):A.get(b,l,t,n)*R.get(b,d,f,e)}}T.set(h,e,r,l,d)}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};const De={kernelName:r.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,filter:filter}=t,{inputShape:d,strides:h,pad:f,dataFormat:m,dimRoundingMode:y}=c;Object(o.a)([l,filter],"conv2dBackpropInput");const x=r.util.computeStrides(filter.shape),v=r.util.computeStrides(l.shape);let O=r.backend_util.convertConv2DDataFormat(m);const k=r.backend_util.computeConv2DInfo(d,filter.shape,h,1,f,y,!1,O),w=new r.TensorBuffer(k.inShape,"float32"),I=w.values,S=n.data.get(l.dataId).values,N=n.data.get(filter.dataId).values,[T,j,C]=x,{batchSize:$,filterHeight:E,filterWidth:A,inChannels:R,inHeight:_,inWidth:F,outChannels:D,outHeight:M,outWidth:P,strideHeight:L,strideWidth:B}=k;O=k.dataFormat;const z=E-1-k.padInfo.top,V=A-1-k.padInfo.left,W="channelsLast"===O,U=w.strides[0],G=W?w.strides[1]:w.strides[2],H=W?w.strides[2]:1,K=W?1:w.strides[1],X=v[0],Y=W?v[1]:v[2],Z=W?v[2]:1,Q=W?1:v[1];for(let b=0;b<$;++b)for(let e=0;e<R;++e)for(let t=0;t<_;++t){const n=t-z,r=Math.max(0,Math.ceil(n/L)),o=Math.min(M,(E+n)/L);for(let c=0;c<F;++c){const l=c-V,d=Math.max(0,Math.ceil(l/B)),h=Math.min(P,(A+l)/B);let f=0;for(let t=r;t<o;++t){const r=t*L-n;for(let n=d;n<h;++n){const o=X*b+Y*t+Z*n,c=T*(E-1-r)+j*(A-1-(n*B-l))+C*e;for(let e=0;e<D;++e){f+=S[o+Q*e]*N[c+e]}}}I[U*b+G*t+H*c+K*e]=f}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const Me={kernelName:r.Conv3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,filter:filter}=t,{strides:d,pad:h,dilations:f}=c;Object(o.a)([l,filter],"conv3d");const m=r.backend_util.computeConv3DInfo(l.shape,filter.shape,d,f,h),{filterDepth:y,filterHeight:x,filterWidth:v,dilationDepth:O,dilationHeight:k,dilationWidth:w,padInfo:I}=m,S=I.front,N=I.left,T=I.top,j=new r.TensorBuffer(m.outShape,l.dtype),C=n.data.get(l.dataId).values,$=n.data.get(filter.dataId).values,E=j.values,A=r.util.computeStrides(l.shape),R=r.util.computeStrides(filter.shape);for(let b=0;b<m.batchSize;++b){const e=b*A[0],t=b*j.strides[0];for(let n=0;n<m.outDepth;++n){const r=t+n*j.strides[1],o=n*m.strideDepth-S;for(let t=0;t<y;++t){const n=o+t*O;if(n<0||n>=m.inDepth)continue;const c=t*R[0],l=e+n*A[1];for(let e=0;e<m.outHeight;++e){const t=r+e*j.strides[2],n=e*m.strideHeight-T;for(let e=0;e<x;++e){const r=n+e*k;if(r<0||r>=m.inHeight)continue;const o=c+e*R[1],d=l+r*A[2];for(let e=0;e<m.outWidth;++e){const n=t+e*m.outChannels,r=e*m.strideWidth-N;for(let e=0;e<v;++e){const t=r+e*w;if(t<0||t>=m.inWidth)continue;const c=o+e*R[2],l=d+t*m.inChannels;let h=c;for(let e=0;e<m.inChannels;++e){const t=C[l+e];for(let e=0;e<m.outChannels;++e)E[n+e]+=t*$[h+e];h+=m.outChannels}}}}}}}}return n.makeTensorInfo(j.shape,j.dtype,j.values)}};const Pe={kernelName:r.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,dy:d}=t,{strides:h,pad:f,filterShape:m}=c;Object(o.a)([l,d],"conv3dBackpropFilterV2");const y=r.util.computeStrides(l.shape),x=r.util.computeStrides(d.shape),v=r.backend_util.computeConv3DInfo(l.shape,m,h,1,f),O=v.strideDepth,k=v.strideHeight,w=v.strideWidth,I=v.filterDepth,S=v.filterHeight,N=v.filterWidth,T=new r.TensorBuffer(v.filterShape,"float32"),j=T.values,[C,$,E,A]=T.strides,R=n.data.get(d.dataId).values,[_,F,D,M]=x,P=n.data.get(l.dataId).values,[L,B,z,V]=y,W=v.padInfo.front,U=v.padInfo.left,G=v.padInfo.top;for(let e=0;e<I;++e){const t=Math.max(0,Math.ceil((W-e)/O)),n=Math.min(v.outDepth,(v.inDepth+W-e)/O),r=e*C;for(let o=0;o<S;++o){const c=Math.max(0,Math.ceil((G-o)/k)),l=Math.min(v.outHeight,(v.inHeight+G-o)/k),d=o*$+r;for(let r=0;r<N;++r){const h=Math.max(0,Math.ceil((U-r)/w)),f=Math.min(v.outWidth,(v.inWidth+U-r)/w),m=r*E+d;for(let d=0;d<v.inChannels;++d){const y=d*A+m;for(let m=0;m<v.outChannels;++m){let x=0;for(let b=0;b<v.batchSize;++b){const y=b*L,v=b*_;for(let I=t;I<n;++I){const t=(e+I*O-W)*B+y,n=I*F+v;for(let e=c;e<l;++e){const c=(o+e*k-G)*z+t,l=e*D+n;for(let e=h;e<f;++e){const t=e*M+l;x+=P[(r+e*w-U)*V+c+d]*R[t+m]}}}}j[y+m]=x}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};const Le={kernelName:r.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,filter:filter}=t,{pad:d,strides:h,inputShape:f}=c;Object(o.a)([l],"conv3dBackpropInputV2");const m=r.util.computeStrides(l.shape),y=r.util.computeStrides(filter.shape),x=r.backend_util.computeConv3DInfo(f,filter.shape,h,1,d),v=new r.TensorBuffer(x.inShape,"float32"),O=v.values,[k,w,I,S]=v.strides,N=n.data.get(l.dataId).values,[T,j,C,$]=m,E=n.data.get(filter.dataId).values,[A,R,_,F]=y,{batchSize:D,filterDepth:M,filterHeight:P,filterWidth:L,inChannels:B,inDepth:z,inHeight:V,inWidth:W,outChannels:U,outDepth:G,outHeight:H,outWidth:K,strideDepth:X,strideHeight:Y,strideWidth:Z}=x,Q=M-1-x.padInfo.front,J=P-1-x.padInfo.top,ee=L-1-x.padInfo.left;for(let b=0;b<D;++b)for(let e=0;e<B;++e)for(let t=0;t<z;++t){const n=t-Q,r=Math.max(0,Math.ceil(n/X)),o=Math.min(G,(M+n)/X);for(let c=0;c<V;++c){const l=c-J,d=Math.max(0,Math.ceil(l/Y)),h=Math.min(H,(P+l)/Y);for(let f=0;f<W;++f){const m=f-ee,y=Math.max(0,Math.ceil(m/Z)),x=Math.min(K,(L+m)/Z);let v=0;for(let t=r;t<o;++t){const r=t*X-n;for(let n=d;n<h;++n){const o=n*Y-l;for(let c=y;c<x;++c){const l=T*b+j*t+C*n+$*c,d=A*(M-1-r)+R*(P-1-o)+_*(L-1-(c*Z-m))+F*e;for(let e=0;e<U;++e){v+=N[l+e]*E[d+e]}}}}O[k*b+w*t+I*c+S*f+e]=v}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Be=Object(f.a)(r.Cos,(e=>Math.cos(e))),ze={kernelName:r.Cos,backendName:"cpu",kernelFunc:Be},Ve=Object(f.a)(r.Cosh,(e=>Math.cosh(e))),We={kernelName:r.Cosh,backendName:"cpu",kernelFunc:Ve};const Ue={kernelName:r.CropAndResize,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{image:image,boxes:c,boxInd:l}=t,{cropSize:d,method:h,extrapolationValue:f}=o,[m,y,x,v]=image.shape,O=c.shape[0],[k,w]=d,output=Object(r.buffer)([O,k,w,v],"float32"),I=n.data.get(c.dataId).values,S=n.data.get(l.dataId).values,N=n.data.get(image.dataId).values,T=r.util.computeStrides(image.shape),j=r.util.computeStrides(output.shape);for(let b=0;b<O;b++){const e=4*b,t=I[e],n=I[e+1],r=I[e+2],o=I[e+3],c=S[b];if(c>=m)continue;const l=k>1?(r-t)*(y-1)/(k-1):0,d=w>1?(o-n)*(x-1)/(w-1):0;for(let e=0;e<k;e++){const m=k>1?t*(y-1)+e*l:.5*(t+r)*(y-1);if(m<0||m>y-1)for(let t=0;t<w;t++)for(let n=0;n<v;n++){const r=n+t*j[2]+e*j[1]+b*j[0];output.values[r]=f}else if("bilinear"===h){const t=Math.floor(m),r=Math.ceil(m),l=m-t;for(let h=0;h<w;h++){const m=w>1?n*(x-1)+h*d:.5*(n+o)*(x-1);if(m<0||m>x-1){for(let t=0;t<v;t++){const n=t+h*j[2]+e*j[1]+b*j[0];output.values[n]=f}continue}const y=Math.floor(m),O=Math.ceil(m),k=m-y;for(let n=0;n<v;n++){let o=n+y*T[2]+t*T[1]+c*T[0];const d=N[o];o=n+O*T[2]+t*T[1]+c*T[0];const f=N[o];o=n+y*T[2]+r*T[1]+c*T[0];const m=N[o];o=n+O*T[2]+r*T[1]+c*T[0];const x=d+(f-d)*k,v=m+(N[o]-m)*k;o=n+h*j[2]+e*j[1]+b*j[0],output.values[o]=x+(v-x)*l}}}else for(let t=0;t<w;++t){const r=w>1?n*(x-1)+t*d:.5*(n+o)*(x-1);if(r<0||r>x-1){for(let n=0;n<v;n++){const r=n+t*j[2]+e*j[1]+b*j[0];output.values[r]=f}continue}const l=Math.round(r),h=Math.round(m);for(let n=0;n<v;n++){const r=n+l*T[2]+h*T[1]+c*T[0],o=n+t*j[2]+e*j[1]+b*j[0];output.values[o]=N[r]}}}}return n.makeTensorInfo(output.shape,output.dtype,output.values)}};const Ge={kernelName:r.Cumprod,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,exclusive:h,reverse:f}=c;Object(o.a)(l,"cumprod");const m=r.backend_util.getAxesPermutation([d],l.shape.length);let y=l;null!=m&&(y=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:m}}));const x=r.backend_util.getInnerMostAxes(1,l.shape.length)[0];if(x!==y.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${y.shape.length-1} but got axis=${x}`);const v=Object(r.upcastType)(y.dtype,"int32"),O=r.util.makeOnesTypedArray(r.util.sizeFromShape(y.shape),v),k=n.data.get(y.dataId).values,w=y.shape[y.shape.length-1],I=f?(i,e)=>i+w-e-1:(i,e)=>i+e;for(let i=0;i<k.length;i+=w)for(let e=0;e<w;e++){const t=I(i,e);if(0===e)O[t]=h?1:k[t];else{const n=I(i,e-1);O[t]=h?k[n]*O[n]:k[t]*O[n]}}const S=n.makeTensorInfo(y.shape,v,O);if(null!=m){const e=r.backend_util.getUndoAxesPermutation(m),t=Object(U.a)({inputs:{x:S},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(y),t}return S}};const He={kernelName:r.Cumsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,exclusive:h,reverse:f}=c;Object(o.a)(l,"cumsum");const m=r.backend_util.getAxesPermutation([d],l.shape.length);let y=l;null!=m&&(y=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:m}}));const x=r.backend_util.getInnerMostAxes(1,l.shape.length)[0];if(x!==y.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${y.shape.length-1} but got axis=${x}`);const v=Object(r.upcastType)(y.dtype,"int32"),O=r.util.makeZerosTypedArray(r.util.sizeFromShape(y.shape),v),k=n.data.get(y.dataId).values,w=y.shape[y.shape.length-1],I=f?(i,e)=>i+w-e-1:(i,e)=>i+e;for(let i=0;i<k.length;i+=w)for(let e=0;e<w;e++){const t=I(i,e);if(0===e)O[t]=h?0:k[t];else{const n=I(i,e-1);O[t]=h?k[n]+O[n]:k[t]+O[n]}}const S=n.makeTensorInfo(y.shape,v,O);if(null!=m){const e=r.backend_util.getUndoAxesPermutation(m),t=Object(U.a)({inputs:{x:S},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(y),t}return S}};const qe={kernelName:r.DenseBincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l,binaryOutput:d}=r;if(1===o.shape.length){const e=n.data.get(o.dataId).values,t=n.data.get(c.dataId).values,r=Object(ye.a)(e,t,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,r)}if(2===o.shape.length){const e=n.bufferSync(o),t=n.bufferSync(c),r=Object(ye.b)(e,t,l,d);return n.makeTensorInfo(r.shape,c.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}};const Ke={kernelName:r.DepthToSpace,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:c}=t,{blockSize:l,dataFormat:d}=o;r.util.assert("NHWC"===d,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${d}`));const h=c.shape[0],f=c.shape[1],m=c.shape[2],y=c.shape[3],x=f*l,v=m*l,O=y/(l*l),k=n.data.get(c.dataId).values,w=new Float32Array(h*x*v*O);let I=0;for(let b=0;b<h;++b)for(let e=0;e<x;++e){const t=Math.floor(e/l),n=e%l;for(let e=0;e<v;++e){const r=Math.floor(e/l),o=(n*l+e%l)*O;for(let e=0;e<O;++e){const n=e+o+y*(r+m*(t+f*b));w[I++]=k[n]}}}return n.makeTensorInfo([h,x,v,O],c.dtype,w)}};function Xe(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,filter:filter}=t,{strides:d,pad:h,dilations:f,dimRoundingMode:m}=c;Object(o.a)([l,filter],"depthwiseConv2DNative");const y=r.util.computeStrides(l.shape),x=r.util.computeStrides(filter.shape);let v=f;null==v&&(v=[1,1]),r.util.assert(r.backend_util.eitherStridesOrDilationsAreOne(d,v),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${v}'`));const O=r.backend_util.computeConv2DInfo(l.shape,filter.shape,d,v,h,m,!0),{filterHeight:k,filterWidth:w,dilationHeight:I,dilationWidth:S,padInfo:N}=O,T=N.left,j=N.top,C=O.outChannels/O.inChannels,$=new r.TensorBuffer(O.outShape,l.dtype),E=n.data.get(l.dataId).values,A=n.data.get(filter.dataId).values,R=$.values;for(let b=0;b<O.batchSize;++b){const e=b*y[0],t=b*$.strides[0];for(let n=0;n<O.outHeight;++n){const r=t+n*$.strides[1],o=n*O.strideHeight-j;for(let t=0;t<k;++t){const n=o+t*I;if(n<0||n>=O.inHeight)continue;const c=t*x[0],l=e+n*y[1];for(let e=0;e<O.outWidth;++e){const t=r+e*$.strides[2],n=e*O.strideWidth-T;for(let e=0;e<w;++e){const r=n+e*S;if(r<0||r>=O.inWidth)continue;const o=c+e*x[1],d=l+r*O.inChannels;let h=t,f=o;for(let e=0;e<O.inChannels;++e){const t=E[d+e];for(let q=0;q<C;++q)R[h+q]+=t*A[f+q];h+=C,f+=C}}}}}}return n.makeTensorInfo($.shape,$.dtype,$.values)}const Ye={kernelName:r.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:Xe};const Ze={kernelName:r.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,dy:d}=t,{strides:h,dilations:f,pad:m,dimRoundingMode:y,filterShape:x}=c;Object(o.a)([l,d],"depthwiseConv2dNativeBackpropFilter");const v=r.backend_util.computeConv2DInfo(l.shape,x,h,f,m,y,!0),{strideHeight:O,strideWidth:k,filterHeight:w,filterWidth:I}=v,S=new r.TensorBuffer(v.filterShape,"float32"),N=v.padInfo.left,T=v.padInfo.top,j=v.outChannels/v.inChannels,C=n.data.get(l.dataId).values,$=new r.TensorBuffer(l.shape,l.dtype,C),E=n.data.get(d.dataId).values,A=new r.TensorBuffer(d.shape,d.dtype,E);for(let e=0;e<w;++e){const t=Math.max(0,Math.ceil((T-e)/O)),n=Math.min(v.outHeight,(v.inHeight+T-e)/O);for(let r=0;r<I;++r){const o=Math.max(0,Math.ceil((N-r)/k)),c=Math.min(v.outWidth,(v.inWidth+N-r)/k);for(let l=0;l<v.outChannels;++l){const d=Math.trunc(l/j),h=l%j;let f=0;for(let b=0;b<v.batchSize;++b)for(let h=t;h<n;++h){const t=e+h*O-T;for(let e=o;e<c;++e){const n=r+e*k-N;f+=$.get(b,t,n,d)*A.get(b,h,e,l)}}S.set(f,e,r,d,h)}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const Qe={kernelName:r.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,filter:filter}=t,{strides:d,dilations:h,pad:f,dimRoundingMode:m,inputShape:y}=c;Object(o.a)([l,filter],"depthwiseConv2DNativeBackpropInput");const x=r.util.computeStrides(l.shape),v=r.util.computeStrides(filter.shape),O=r.backend_util.computeConv2DInfo(y,filter.shape,d,h,f,m,!0),k=new r.TensorBuffer(O.inShape,"float32"),w=k.values,[I,S,N]=k.strides,T=n.data.get(l.dataId).values,[j,C,$]=x,E=n.data.get(filter.dataId).values,[A,R,_]=v,{batchSize:F,filterHeight:D,filterWidth:M,inChannels:P,inHeight:L,inWidth:B,outChannels:z,outHeight:V,outWidth:W,strideHeight:U,strideWidth:G}=O,H=D-1-O.padInfo.top,K=M-1-O.padInfo.left,X=z/P;for(let b=0;b<F;++b)for(let e=0;e<P;++e)for(let t=0;t<L;++t){const n=t-H,r=Math.max(0,Math.ceil(n/U)),o=Math.min(V,(D+n)/U);for(let c=0;c<B;++c){const l=c-K,d=Math.max(0,Math.ceil(l/G)),h=Math.min(W,(M+l)/G);let f=0;for(let t=r;t<o;++t){const r=t*U-n;for(let n=d;n<h;++n){const o=j*b+C*t+$*n,c=A*(D-1-r)+R*(M-1-(n*G-l))+_*e;for(let t=0;t<X;++t){f+=T[o+(e*X+t)]*E[c+t]}}}w[I*b+S*t+N*c+e]=f}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};const Je={kernelName:r.Diag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:o}=t,c=r.util.sizeFromShape(o.shape),l=n.data.get(o.dataId).values,d=Object(r.buffer)([c,c],o.dtype),h=d.values;for(let i=0;i<l.length;i++)h[i*c+i]=l[i];const f=[...o.shape,...o.shape];return n.makeTensorInfo(f,d.dtype,d.values)}},et={kernelName:r.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:filter}=e,{strides:c,pad:l,dilations:d}=n,h=t,f=h.data.get(o.dataId).values,m=o.shape.length,y=h.data.get(filter.dataId).values,x=filter.shape.length,{batchSize:v,inHeight:O,inWidth:k,inChannels:w,outHeight:I,outWidth:S,padInfo:N,strideHeight:T,strideWidth:j,filterHeight:C,filterWidth:$,dilationHeight:E,dilationWidth:A,outShape:R}=r.backend_util.computeDilation2DInfo(o.shape,filter.shape,c,l,"NHWC",d),_=r.util.sizeFromShape(R),F=R.length,D=r.util.getArrayFromDType(o.dtype,_);for(let b=0;b<v;++b)for(let e=0;e<I;++e){const t=e*T-N.top;for(let n=0;n<S;++n){const c=n*j-N.left;for(let l=0;l<w;++l){let d=Number.MIN_SAFE_INTEGER;for(let e=0;e<C;++e){const n=t+e*E;if(n>=0&&n<O)for(let t=0;t<$;++t){const h=c+t*A;if(h>=0&&h<k){const c=r.util.locToIndex([b,n,h,l],m,r.util.computeStrides(o.shape)),v=r.util.locToIndex([e,t,l],x,r.util.computeStrides(filter.shape)),O=f[c]+y[v];O>d&&(d=O)}}}D[r.util.locToIndex([b,e,n,l],F,r.util.computeStrides(R))]=d}}}return{dataId:h.write(r.util.toTypedArray(D,o.dtype),R,o.dtype),shape:R,dtype:o.dtype}}},tt={kernelName:r.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:filter,dy:c}=e,{strides:l,pad:d,dilations:h}=n,f=t,m=r.util.toNestedArray(o.shape,f.data.get(o.dataId).values),y=r.util.toNestedArray(filter.shape,f.data.get(filter.dataId).values),{batchSize:x,inHeight:v,inWidth:O,inChannels:k,outHeight:w,outWidth:I,padInfo:S,strideHeight:N,strideWidth:T,filterHeight:j,filterWidth:C,dilationHeight:$,dilationWidth:E,outShape:A}=r.backend_util.computeDilation2DInfo(o.shape,filter.shape,l,d,"NHWC",h);r.util.assert(c.rank===A.length,(()=>`Error in ${r.Dilation2DBackpropFilter}, dy must have the same rank as output ${A.length}, but got ${c.rank}`));const R=r.util.toNestedArray(A,f.data.get(c.dataId).values),_=r.util.makeZerosNestedTypedArray(filter.shape,filter.dtype);for(let b=0;b<x;++b)for(let e=0;e<w;++e){const t=e*N-S.top;for(let n=0;n<I;++n){const r=n*T-S.left;for(let o=0;o<k;++o){let c=Number.MIN_SAFE_INTEGER,l=0,d=0;for(let e=0;e<j;++e){const n=t+e*$;if(n>=0&&n<v)for(let t=0;t<C;++t){const h=r+t*E;if(h>=0&&h<O){const r=m[b][n][h][o]+y[e][t][o];r>c&&(c=r,l=e,d=t)}}}_[l][d][o]+=R[b][e][n][o]}}}return{dataId:f.write(r.util.toTypedArray(_,o.dtype),filter.shape,filter.dtype),shape:filter.shape,dtype:filter.dtype}}},nt={kernelName:r.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:o,filter:filter,dy:c}=e,{strides:l,pad:d,dilations:h}=n,f=t,m=r.util.toNestedArray(o.shape,f.data.get(o.dataId).values),y=r.util.toNestedArray(filter.shape,f.data.get(filter.dataId).values),{batchSize:x,inHeight:v,inWidth:O,inChannels:k,outHeight:w,outWidth:I,padInfo:S,strideHeight:N,strideWidth:T,filterHeight:j,filterWidth:C,dilationHeight:$,dilationWidth:E,outShape:A}=r.backend_util.computeDilation2DInfo(o.shape,filter.shape,l,d,"NHWC",h);r.util.assert(c.rank===A.length,(()=>`Error in ${r.Dilation2DBackpropInput}, dy must have the same rank as output ${A.length}, but got ${c.rank}`));const R=r.util.toNestedArray(A,f.data.get(c.dataId).values),_=r.util.makeZerosNestedTypedArray(o.shape,o.dtype);for(let b=0;b<x;++b)for(let e=0;e<w;++e){const t=e*N-S.top;for(let n=0;n<I;++n){const r=n*T-S.left;for(let o=0;o<k;++o){let c=Number.MIN_SAFE_INTEGER,l=t<0?0:t,d=r<0?0:r;for(let e=0;e<j;++e){const n=t+e*$;if(n>=0&&n<v)for(let t=0;t<C;++t){const h=r+t*E;if(h>=0&&h<O){const r=m[b][n][h][o]+y[e][t][o];r>c&&(c=r,l=n,d=h)}}}_[b][l][d][o]+=R[b][e][n][o]}}}return{dataId:f.write(r.util.toTypedArray(_,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var at=n(326),st=n(410);function ot(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,keepDims:h}=c;let f;Object(o.a)(l,"sum"),f="bool"===l.dtype?Object(Oe.a)({inputs:{x:l},backend:n,attrs:{dtype:"int32"}}):Object(x.a)({inputs:{x:l},backend:n});const m=f.shape.length,y=r.util.parseAxisParam(d,f.shape),v=r.backend_util.getAxesPermutation(y,m);let O=y,k=f;null!=v&&(k=Object(U.a)({inputs:{x:f},backend:n,attrs:{perm:v}}),O=r.backend_util.getInnerMostAxes(O.length,m)),r.backend_util.assertAxesAreInnerMostDims("sum",O,k.shape.length);const[w,I]=r.backend_util.computeOutAndReduceShapes(k.shape,O),S=r.backend_util.upcastType(k.dtype,"int32");let N=Object(st.a)(n,w,S);const T=r.util.sizeFromShape(I),j=n.data.get(N.dataId).values,C=n.data.get(k.dataId).values;for(let i=0;i<j.length;++i){const e=i*T;let t=0;for(let n=0;n<T;++n)t+=C[e+n];j[i]=t}if(h){const e=N;N=R({inputs:{x:N},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(N.shape,y)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(f),null!=v&&n.disposeIntermediateTensorInfo(k),N}const it={kernelName:r.Sum,backendName:"cpu",kernelFunc:ot};const ut={kernelName:r.Einsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{equation:c}=o,l=t,{allDims:d,summedDims:h,idDims:f}=r.backend_util.decodeEinsumEquation(c,l.length);r.backend_util.checkEinsumDimSizes(d.length,f,l);const{path:path,steps:m}=r.backend_util.getEinsumComputePath(h,f),y=m.length;let x=null,v=d.length;const O=[];for(let i=0;i<y;++i){for(const e of m[i]){const{permutationIndices:t,expandDims:o}=r.backend_util.getEinsumPermutation(v,f[e]);let c;r.backend_util.isIdentityPermutation(t)?c=l[e]:(c=Object(U.a)({inputs:{x:l[e]},backend:n,attrs:{perm:t}}),O.push(c));const d=c.shape.slice();for(let e=0;e<o.length;++e)d.splice(o[e],0,1);r.util.arraysEqual(c.shape,d)||(c=R({inputs:{x:c},backend:n,attrs:{shape:d}}),O.push(c)),null===x?x=c:(x=Object(at.a)({inputs:{a:c,b:x},backend:n}),O.push(x))}i<y-1&&(path[i]>=0&&(x=ot({inputs:{x:x},backend:n,attrs:{axis:path[i]-(d.length-v),keepDims:!1}}),O.push(x)),v--)}for(const e of O)e!==x&&n.disposeIntermediateTensorInfo(e);return x}};const ct={kernelName:r.EluGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:c,y:l}=t;Object(o.a)([c,l],"eluGrad");const d=new Float32Array(r.util.sizeFromShape(l.shape)),h=n.data.get(l.dataId).values,f=n.data.get(c.dataId).values;for(let i=0;i<h.length;++i){const e=h[i];d[i]=e>=1?f[i]:f[i]*(e+1)}return n.makeTensorInfo(l.shape,"float32",d)}};var lt=n(351);const p=r.backend_util.ERF_P,pt=r.backend_util.ERF_A1,ht=r.backend_util.ERF_A2,ft=r.backend_util.ERF_A3,mt=r.backend_util.ERF_A4,bt=r.backend_util.ERF_A5,gt=Object(f.a)(r.Erf,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+p*n);return t*(1-((((bt*r+mt)*r+ft)*r+ht)*r+pt)*r*Math.exp(-n*n))})),yt={kernelName:r.Erf,backendName:"cpu",kernelFunc:gt};var xt=n(352);function vt(e){const{inputs:t,backend:n,attrs:o}=e,{input:input}=t,{dim:c}=o,l=input.shape.length,d=input.shape.slice();let h=c;return c<0&&(r.util.assert(-(l+1)<=c,(()=>`Axis must be in the interval [${-(l+1)}, ${l}]`)),h=l+c+1),d.splice(h,0,1),R({inputs:{x:input},backend:n,attrs:{shape:d}})}const Ot={kernelName:r.ExpandDims,backendName:"cpu",kernelFunc:vt};var kt=n(375);const wt=Object(k.a)(((a,b)=>a/b)),div=Object(ne.a)(r.RealDiv,wt),It={kernelName:r.RealDiv,backendName:"cpu",kernelFunc:div};var St=n(346);function Nt(input,e,t){const n=input.shape,o=n[0],c=n[1],l=t.data.get(input.dataId),d=l.complexTensorInfos.real,h=l.complexTensorInfos.imag,f=[o,c],m=r.util.sizeFromShape(f),y=r.util.getTypedArrayFromDType("float32",m),x=r.util.getTypedArrayFromDType("float32",m);for(let b=0;b<o;b++){const n=Object(be.a)({inputs:{x:d},backend:t,attrs:{begin:[b,0],size:[1,c]}}),i=Object(be.a)({inputs:{x:h},backend:t,attrs:{begin:[b,0],size:[1,c]}}),input=Object(Se.a)({inputs:{real:n,imag:i},backend:t}),{real:o,imag:l}=Tt(input,e,t),f=r.backend_util.mergeRealAndImagArrays(o,l);for(let e=0;e<c;e++){const t=r.backend_util.getComplexWithIndex(f,e);y[b*c+e]=t.real,x[b*c+e]=t.imag}t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(input)}const v=t.makeTensorInfo(f,"float32",y),O=t.makeTensorInfo(f,"float32",x),k=Object(Se.a)({inputs:{real:v,imag:O},backend:t});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(O),k}function Tt(input,e,t){const n=r.util.sizeFromShape(input.shape),o=t.data.get(input.dataId),c=t.data.get(o.complexTensorInfos.real.dataId).values,l=t.data.get(o.complexTensorInfos.imag.dataId).values;if(0==((d=n)&d-1)){const o=jt(c,l,n,e,t),d=[input.shape[0],input.shape[1]];if(e){const e=t.makeTensorInfo(d,"float32",o.real),c=t.makeTensorInfo(d,"float32",o.imag),l=t.makeTensorInfo([],"float32",r.util.createScalarValue(n,"float32")),h=Object(x.a)({inputs:{x:l},backend:t}),f=It.kernelFunc({inputs:{a:e,b:l},backend:t}),m=It.kernelFunc({inputs:{a:c,b:h},backend:t}),y=t.data.get(f.dataId).values,v=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:y,imag:v}}return o}{const t=function(data,e,t){const n=new Float32Array(2*e);for(let o=0;o<e;o++){let c=0,l=0;for(let n=0;n<e;n++){const d=r.backend_util.exponent(o*n,e,t),h=r.backend_util.getComplexWithIndex(data,n);c+=h.real*d.real-h.imag*d.imag,l+=h.real*d.imag+h.imag*d.real}t&&(c/=e,l/=e),r.backend_util.assignToTypedArray(n,c,l,o)}return n}(r.backend_util.mergeRealAndImagArrays(c,l),n,e);return r.backend_util.splitRealAndImagArrays(t)}var d}function jt(e,t,n,o,c){if(1===n)return{real:e,imag:t};const data=r.backend_util.mergeRealAndImagArrays(e,t),l=n/2,d=r.backend_util.complexWithEvenIndex(data),h=d.real,f=d.imag,m=[h.length],y=c.makeTensorInfo(m,"float32",h),x=c.makeTensorInfo(m,"float32",f),v=Object(Se.a)({inputs:{real:y,imag:x},backend:c}),O=r.backend_util.complexWithOddIndex(data),k=O.real,w=O.imag,I=[k.length],S=c.makeTensorInfo(I,"float32",k),N=c.makeTensorInfo(I,"float32",w),T=Object(Se.a)({inputs:{real:S,imag:N},backend:c}),j=jt(h,f,l,o,c),C=j.real,$=j.imag,E=[C.length],R=c.makeTensorInfo(E,"float32",C),_=c.makeTensorInfo(E,"float32",$),F=Object(Se.a)({inputs:{real:R,imag:_},backend:c}),D=jt(k,w,l,o,c),M=D.real,P=D.imag,L=[M.length],B=c.makeTensorInfo(L,"float32",M),z=c.makeTensorInfo(L,"float32",P),V=Object(Se.a)({inputs:{real:B,imag:z},backend:c}),W=r.backend_util.exponents(n,o),U=[W.real.length],G=c.makeTensorInfo(U,"float32",W.real),H=c.makeTensorInfo(U,"float32",W.imag),K=Object(Se.a)({inputs:{real:G,imag:H},backend:c}),X=Object(at.a)({inputs:{a:K,b:V},backend:c}),Y=Object(A.a)({inputs:{a:F,b:X},backend:c}),Z=Object(St.a)({inputs:{a:F,b:X},backend:c}),Q=Object($e.a)({inputs:{input:Y},backend:c}),J=Object($e.a)({inputs:{input:Z},backend:c}),ee=je({inputs:{input:Y},backend:c}),te=je({inputs:{input:Z},backend:c}),ne=Ee({inputs:[Q,J],backend:c,attrs:{axis:0}}),re=Ee({inputs:[ee,te],backend:c,attrs:{axis:0}}),ae=c.data.get(ne.dataId).values,se=c.data.get(re.dataId).values;return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(S),c.disposeIntermediateTensorInfo(N),c.disposeIntermediateTensorInfo(T),c.disposeIntermediateTensorInfo(R),c.disposeIntermediateTensorInfo(_),c.disposeIntermediateTensorInfo(F),c.disposeIntermediateTensorInfo(B),c.disposeIntermediateTensorInfo(z),c.disposeIntermediateTensorInfo(V),c.disposeIntermediateTensorInfo(G),c.disposeIntermediateTensorInfo(H),c.disposeIntermediateTensorInfo(K),c.disposeIntermediateTensorInfo(X),c.disposeIntermediateTensorInfo(Y),c.disposeIntermediateTensorInfo(Z),c.disposeIntermediateTensorInfo(Q),c.disposeIntermediateTensorInfo(ee),c.disposeIntermediateTensorInfo(J),c.disposeIntermediateTensorInfo(te),c.disposeIntermediateTensorInfo(ne),c.disposeIntermediateTensorInfo(re),{real:ae,imag:se}}const Ct={kernelName:r.FFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t,o=r.util.sizeFromShape(input.shape),c=input.shape[input.shape.length-1],l=R({inputs:{x:input},backend:n,attrs:{shape:[o/c,c]}}),d=Nt(l,!1,n),h=R({inputs:{x:d},backend:n,attrs:{shape:input.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}};function $t(e){const{backend:t,attrs:n}=e,{shape:o,value:c,dtype:l}=n,d=l||r.util.inferDtype(c),h=r.util.getArrayFromDType(d,r.util.sizeFromShape(o));return function(e,t,n){e.fill(t)}(h,c),t.makeTensorInfo(o,d,h)}const Et={kernelName:r.Fill,backendName:"cpu",kernelFunc:$t};const At={kernelName:r.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:image}=e,o=n,output=r.util.getTypedArrayFromDType(image.dtype,r.util.sizeFromShape(image.shape)),[c,l,d,h]=image.shape,f=o.data.get(image.dataId).values;for(let e=0;e<c;e++){const t=e*d*l*h;for(let e=0;e<l;e++){const n=e*(d*h);for(let col=0;col<d;col++){const e=col*h;for(let r=0;r<h;r++){const o=Math.round(d-col-1),c=t+n+e+r;let l=f[c];if(o>=0&&o<d){l=f[t+n+o*h+r]}output[c]=l}}}}return{dataId:o.write(output,image.shape,image.dtype),shape:image.shape,dtype:image.dtype}}};var Rt=n(376);const _t=Object(k.a)(((a,b)=>Math.floor(a/b))),Ft=Object(ne.a)(r.FloorDiv,_t,null,"int32"),Dt={kernelName:r.FloorDiv,backendName:"cpu",kernelFunc:Ft};const Mt={kernelName:r.FusedConv2D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:c,preluActivationWeights:l}=t,{strides:d,pad:h,dataFormat:f,dilations:m,dimRoundingMode:y,activation:x,leakyreluAlpha:v}=r;let O=Re({inputs:{x:o,filter:filter},backend:n,attrs:{strides:d,pad:h,dataFormat:f,dilations:m,dimRoundingMode:y}});if(c){const e=O;if("NCHW"===f&&1===c.shape.length&&1!==c.shape[0]){const e=R({inputs:{x:c},backend:n,attrs:{shape:[c.shape[0],1,1]}});O=Object(A.a)({inputs:{a:O,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else O=Object(A.a)({inputs:{a:O,b:c},backend:n});n.disposeIntermediateTensorInfo(e)}if(x){const e=O;if("NCHW"===f&&"prelu"===x&&1===l.shape.length&&1!==l.shape[0]){const e=R({inputs:{x:l},backend:n,attrs:{shape:[l.shape[0],1,1]}});O=E(n,O,x,e,v),n.disposeIntermediateTensorInfo(e)}else O=E(n,O,x,l,v);n.disposeIntermediateTensorInfo(e)}return O}};const Pt={kernelName:r.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:c,preluActivationWeights:l}=t,{strides:d,pad:h,dataFormat:f,dilations:m,dimRoundingMode:y,activation:x,leakyreluAlpha:v}=r;let O=Xe({inputs:{x:o,filter:filter},backend:n,attrs:{strides:d,pad:h,dataFormat:f,dilations:m,dimRoundingMode:y}});if(c){const e=O;O=Object(A.a)({inputs:{a:O,b:c},backend:n}),n.disposeIntermediateTensorInfo(e)}if(x){const e=O;O=E(n,O,x,l,v),n.disposeIntermediateTensorInfo(e)}return O}};var Lt=n(377);const Bt={kernelName:r.GatherNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:o,indices:c}=t,l=r.util.sizeFromShape(o.shape),d=c.shape,h=d[d.length-1],[f,m,y,x]=r.backend_util.prepareAndValidate(o,c);if(0===m)return n.makeTensorInfo(f,o.dtype,[]);const v=n.data.get(c.dataId).values,O=n.bufferSync(o),k=Object(Lt.a)(v,O,o.dtype,m,h,y,x,o.shape,l);return n.makeTensorInfo(f,o.dtype,k.values)}};var zt=n(378);const Vt={kernelName:r.GatherV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,indices:d}=t,{axis:h,batchDims:f}=c;Object(o.a)([l,d],"gatherV2");const m=r.util.parseAxisParam(h,l.shape)[0],y=n.data.get(d.dataId).values,x=l.shape[m];for(let i=0;i<y.length;++i){const e=y[i];r.util.assert(e<=x-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${x-1}]`))}let v=f;null==f&&(v=0);const O=r.util.sizeFromShape(d.shape),k=r.backend_util.segment_util.collectGatherOpShapeInfo(l,d,m,v),w=R({inputs:{x:l},backend:n,attrs:{shape:[k.batchSize,k.outerSize,k.dimSize,k.sliceSize]}}),I=R({inputs:{x:d},backend:n,attrs:{shape:[k.batchSize,O/k.batchSize]}}),S=[k.batchSize,k.outerSize,O/k.batchSize,k.sliceSize],N=n.bufferSync(I),T=n.bufferSync(w),j=Object(zt.a)(T,N,S);return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(k.outputShape,j.dtype,j.values)}};var Wt=n(379),Ut=n(380);const Gt={kernelName:r.IFFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t,o=r.util.sizeFromShape(input.shape),c=input.shape[input.shape.length-1],l=R({inputs:{x:input},backend:n,attrs:{shape:[o/c,c]}}),d=Nt(l,!0,n),h=R({inputs:{x:d},backend:n,attrs:{shape:input.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}},Ht=Object(f.a)(r.IsFinite,(e=>Number.isFinite(e)?1:0),"bool"),qt={kernelName:r.IsFinite,backendName:"cpu",kernelFunc:Ht},Kt=Object(f.a)(r.IsInf,(e=>Math.abs(e)===1/0?1:0),"bool"),Xt={kernelName:r.IsInf,backendName:"cpu",kernelFunc:Kt},Yt=Object(f.a)(r.IsNan,(e=>Number.isNaN(e)?1:0),"bool"),Zt={kernelName:r.IsNan,backendName:"cpu",kernelFunc:Yt};var Qt=n(381),Jt=n(382),en=n(383);const tn={kernelName:r.LinSpace,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:o,num:c}=n,l=Object(en.a)(r,o,c);return t.makeTensorInfo([l.length],"float32",l)}};var nn=n(384);const rn=Object(f.a)(r.Log1p,(e=>Math.log1p(e))),an={kernelName:r.Log1p,backendName:"cpu",kernelFunc:rn},sn=Object(k.a)(((a,b)=>a&&b)),on=Object(ne.a)(r.LogicalAnd,sn,null,"bool"),un={kernelName:r.LogicalAnd,backendName:"cpu",kernelFunc:on},cn=Object(f.a)(r.LogicalNot,(e=>e?0:1),"bool"),ln={kernelName:r.LogicalNot,backendName:"cpu",kernelFunc:cn},dn=Object(k.a)(((a,b)=>a||b)),pn=Object(ne.a)(r.LogicalOr,dn,null,"bool"),hn={kernelName:r.LogicalOr,backendName:"cpu",kernelFunc:pn};const fn={kernelName:r.LRN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{depthRadius:d,bias:h,alpha:f,beta:m}=c;Object(o.a)(l,"LRN");const y=l.shape[3],x=y-1,v=n.data.get(l.dataId).values,O=r.util.sizeFromShape(l.shape),k=new Float32Array(O);function w(e){const t=e%y;let n=e-t+Math.max(0,t-d);const r=e-t+Math.min(t+d,x);let o=0;for(;n<=r;n++){const e=v[n];o+=e*e}return o}for(let e=0;e<O;e++){const t=w(e),n=v[e]*Math.pow(h+f*t,-m);k[e]=n}return n.makeTensorInfo(l.shape,l.dtype,k)}};const mn={kernelName:r.LRNGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,y:d,dy:h}=t,{depthRadius:f,bias:m,alpha:y,beta:x}=c;Object(o.a)(h,"LRNGrad");const v=r.util.sizeFromShape(h.shape),O=h.shape[3],k=n.data.get(h.dataId).values,w=n.data.get(l.dataId).values,I=n.data.get(d.dataId).values,S=new Float32Array(v),N=v;for(let e=0;e<N;e++){const t=e%O,n=e-t+Math.max(0,t-f),r=e-t+Math.min(O,t+f+1);let o=0;for(let e=n;e<r;e++)o+=Math.pow(w[e],2);o=y*o+m;for(let t=n;t<r;t++){let n=-2*y*x*w[t]*I[e]/o;e===t&&(n+=Math.pow(o,-x)),n*=k[e],S[t]+=n}}return n.makeTensorInfo(h.shape,l.dtype,S)}};var bn=n(385),gn=n(353);function yn(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{reductionIndices:d,keepDims:h}=c,f=n;let m=l.shape;const y=m.length,x=r.util.parseAxisParam(d,m);let v=x;const O=r.backend_util.getAxesPermutation(v,y);let k=f.data.get(l.dataId).values;if(null!=O){const e=new Array(y);for(let i=0;i<e.length;i++)e[i]=m[O[i]];k=Object(gn.a)(k,m,l.dtype,O,e),v=r.backend_util.getInnerMostAxes(v.length,y),m=e}Object(o.a)(l,"max"),r.backend_util.assertAxesAreInnerMostDims("max",v,y);const[w,I]=r.backend_util.computeOutAndReduceShapes(m,v),S=r.util.sizeFromShape(I),N=Object(bn.a)(k,S,w,l.dtype),T=f.write(N,w,l.dtype);let j=w;if(h){j=r.backend_util.expandShapeToKeepDim(w,x)}return{dataId:T,shape:j,dtype:l.dtype}}const xn={kernelName:r.Max,backendName:"cpu",kernelFunc:yn};var vn=n(386);const On={kernelName:r.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t;Object(o.a)(l,"maxPool");const{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=c;r.util.assert(r.backend_util.eitherStridesOrDilationsAreOne(h,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${h} and dilations '1'`));const y=r.backend_util.computePool2DInfo(l.shape,d,h,1,f,m);let v;if(1===y.filterWidth&&1===y.filterHeight&&r.util.arraysEqual(y.inShape,y.outShape))v=Object(x.a)({inputs:{x:l},backend:n});else{const e=n.data.get(l.dataId).values,t=r.util.computeStrides(l.shape),o=ue(e,l.shape,l.dtype,t,y,"max");v=n.makeTensorInfo(y.outShape,l.dtype,o.values)}return v}};const kn={kernelName:r.MaxPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{filterSize:d,strides:h,pad:f,dimRoundingMode:m,dataFormat:y}=c;Object(o.a)(l,"maxPool3d");const x=r.backend_util.computePool3DInfo(l.shape,d,h,1,f,m,y),v=le(n.data.get(l.dataId).values,l.shape,l.dtype,r.util.computeStrides(l.shape),x,"max");return n.makeTensorInfo(v.shape,"float32",v.values)}};const wn={kernelName:r.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,input:input}=t,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=c;Object(o.a)([l,input],"maxPool3DGrad");const y=r.backend_util.computePool3DInfo(input.shape,d,h,1,f,m),x=function(e,t){const n=Object(r.buffer)(t.outShape,"int32"),o=t.strideDepth,c=t.strideHeight,l=t.strideWidth,d=t.dilationDepth,h=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterDepth,y=t.effectiveFilterHeight,x=t.effectiveFilterWidth,v=t.padInfo.front,O=t.padInfo.top,k=t.padInfo.left;for(let r=0;r<t.batchSize;++r)for(let w=0;w<t.inChannels;++w)for(let I=0;I<t.outDepth;++I){const S=I*o-v;let N=S;for(;N<0;)N+=d;const T=Math.min(t.inDepth,m+S);for(let o=0;o<t.outHeight;++o){const m=o*c-O;let v=m;for(;v<0;)v+=h;const j=Math.min(t.inHeight,y+m);for(let c=0;c<t.outWidth;++c){const O=c*l-k;let C=O;for(;C<0;)C+=f;const $=Math.min(t.inWidth,x+O);let E=Number.NEGATIVE_INFINITY,A=-1;for(let t=N;t<T;t+=d){const n=t-S;for(let o=v;o<j;o+=h){const c=o-m;for(let l=C;l<$;l+=f){const d=l-O,h=e.get(r,t,o,l,w);h>=E&&(E=h,A=n*y*x+c*y+d)}}}n.set(A,r,I,o,c,w)}}}return n}(n.bufferSync(input),y),v=y.strideDepth,O=y.strideHeight,k=y.strideWidth,w=y.dilationDepth,I=y.dilationHeight,S=y.dilationWidth,N=y.effectiveFilterDepth,T=y.effectiveFilterHeight,j=y.effectiveFilterWidth,C=N-1-y.padInfo.front,$=j-1-y.padInfo.left,E=T-1-y.padInfo.top,A=Object(r.buffer)(input.shape,"float32"),R=n.bufferSync(l);for(let e=0;e<y.batchSize;++e)for(let t=0;t<y.inChannels;++t)for(let n=0;n<y.inDepth;++n)for(let r=0;r<y.inHeight;++r)for(let o=0;o<y.inWidth;++o){const c=n-C,l=r-E,d=o-$;let h=0;for(let n=0;n<N;n+=w){const r=(c+n)/v;if(!(r<0||r>=y.outDepth||Math.floor(r)!==r))for(let o=0;o<T;o+=I){const c=(l+o)/O;if(!(c<0||c>=y.outHeight||Math.floor(c)!==c))for(let l=0;l<j;l+=S){const f=(d+l)/k;if(f<0||f>=y.outWidth||Math.floor(f)!==f)continue;const mask=N*T*j-1-x.get(e,r,c,f,t)===n*T*j+o*j+l?1:0;if(0===mask)continue;h+=R.get(e,r,c,f,t)*mask}}}A.set(h,e,n,r,o,t)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}};const In={kernelName:r.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{dy:l,input:input,output:output}=t,d=input;Object(o.a)([input,output],"maxPoolGrad");const{filterSize:h,strides:f,pad:m,dimRoundingMode:y}=c,x=r.backend_util.computePool2DInfo(d.shape,h,f,1,m,y),v=n.data.get(d.dataId).values,O=Object(r.buffer)(x.outShape,d.dtype,ce(v,d.shape,d.dtype,x).values),k=x.strideHeight,w=x.strideWidth,I=x.dilationHeight,S=x.dilationWidth,N=x.effectiveFilterHeight,T=x.effectiveFilterWidth,j=T-1-x.padInfo.left,C=N-1-x.padInfo.top,$=Object(r.buffer)(d.shape,"float32"),E=n.data.get(l.dataId).values,A=Object(r.buffer)(l.shape,"float32",E);for(let b=0;b<x.batchSize;++b)for(let e=0;e<x.inChannels;++e)for(let t=0;t<x.inHeight;++t)for(let n=0;n<x.inWidth;++n){const r=t-C,o=n-j;let c=0;for(let t=0;t<N;t+=I){const n=(r+t)/k;if(!(n<0||n>=x.outHeight||Math.floor(n)!==n))for(let r=0;r<T;r+=S){const l=(o+r)/w;if(l<0||l>=x.outWidth||Math.floor(l)!==l)continue;const mask=N*T-1-O.get(b,n,l,e)===t*T+r?1:0;if(0===mask)continue;c+=A.get(b,n,l,e)*mask}}$.set(c,b,t,n,e)}return n.makeTensorInfo($.shape,$.dtype,$.values)}};const Sn={kernelName:r.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:c}=e,{filterSize:l,strides:d,pad:h,includeBatchInIndex:f}=t,m=n;Object(o.a)(c,"MaxPoolWithArgmax");const y=m.data.get(c.dataId).values,x=r.backend_util.computePool2DInfo(c.shape,l,d,[1,1],h),[v,O]=function(e,t,n,o,c){const l=ue(e,0,n,r.util.computeStrides(t),c,"max"),d=ce(e,t,n,c,!0,o);return[l.values,d.values]}(y,c.shape,c.dtype,f,x),k=m.write(v,x.outShape,c.dtype),w=m.write(O,x.outShape,c.dtype);return[{dataId:k,shape:x.outShape,dtype:c.dtype},{dataId:w,shape:x.outShape,dtype:"int32"}]}};const Nn={kernelName:r.Mean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:c}=t,{axis:l,keepDims:d}=o,h=r.util.parseAxisParam(l,c.shape),f=r.backend_util.computeOutAndReduceShapes(c.shape,h)[1],m=r.util.sizeFromShape(f),y=[],x=n.makeTensorInfo([],"float32",new Float32Array([m]));y.push(x);const v=Object(Oe.a)({inputs:{x:c},backend:n,attrs:{dtype:"float32"}});y.push(v);const O=div({inputs:{a:v,b:x},backend:n});y.push(O);const k=ot({inputs:{x:O},backend:n,attrs:{axis:l,keepDims:d}});return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),k}};const Tn={kernelName:r.Min,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{axis:d,keepDims:h}=c;Object(o.a)(l,"min");const f=r.util.parseAxisParam(d,l.shape);let m=f;const y=r.backend_util.getAxesPermutation(m,l.shape.length);let x=l;null!=y&&(x=Object(U.a)({inputs:{x:l},backend:n,attrs:{perm:y}}),m=r.backend_util.getInnerMostAxes(m.length,l.shape.length)),r.backend_util.assertAxesAreInnerMostDims("min",m,x.shape.length);const[v,O]=r.backend_util.computeOutAndReduceShapes(x.shape,m),k=r.util.sizeFromShape(O),w=r.util.makeZerosTypedArray(r.util.sizeFromShape(v),x.dtype),I=n.data.get(x.dataId).values;for(let i=0;i<w.length;++i){const e=i*k;let t=I[e];for(let n=0;n<k;++n){const r=I[e+n];(Number.isNaN(r)||r<t)&&(t=r)}w[i]=t}null!=y&&n.disposeIntermediateTensorInfo(x);const S=n.makeTensorInfo(v,x.dtype,w);if(h){const e=R({inputs:{x:S},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(v,f)}});return n.disposeIntermediateTensorInfo(S),e}return S}};var jn=n(387);const Cn={kernelName:r.MirrorPad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{paddings:d,mode:h}=c;Object(o.a)(l,"mirrorPad");const f=d.map(((p,i)=>p[0]+l.shape[i]+p[1])),m=d.map((p=>p[0])),y=d.map(((p,i)=>p[0]+l.shape[i])),x="reflect"===h?0:1,v=n.data.get(l.dataId).values,O=l.shape.length,k=r.util.computeStrides(l.shape),w=r.util.sizeFromShape(f),I=f.length,S=r.util.computeStrides(f),N=r.util.getTypedArrayFromDType(l.dtype,w);for(let i=0;i<w;i++){let e=r.util.indexToLoc(i,I,S);for(let i=0;i<I;i++)e[i]<m[i]?e[i]=2*m[i]-e[i]-x:e[i]>=y[i]&&(e[i]=2*(y[i]-1)-e[i]+x);e=e.map(((e,i)=>e-m[i]));const t=r.util.locToIndex(e,O,k);N[i]=v[t]}return{dataId:n.write(N,f,l.dtype),shape:f,dtype:l.dtype}}},$n=Object(k.a)(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),En=Object(ne.a)(r.Mod,$n),An={kernelName:r.Mod,backendName:"cpu",kernelFunc:En};var Rn=n(407);function _n(e){const{inputs:t,backend:n,attrs:o}=e,{logits:c}=t,{dim:l}=o,d=c.shape.length;let h=l;if(-1===h&&(h=d-1),h!==d-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${d} and dim was ${h}`);const f=r.util.parseAxisParam([h],c.shape),m=yn({inputs:{x:c},backend:n,attrs:{reductionIndices:f,keepDims:!1}}),y=r.backend_util.expandShapeToKeepDim(m.shape,f),x=R({inputs:{x:m},backend:n,attrs:{shape:y}}),a=Object(St.a)({inputs:{a:c,b:x},backend:n}),b=Object(xt.a)({inputs:{x:a},backend:n}),v=ot({inputs:{x:b},backend:n,attrs:{axis:f,keepDims:!1}}),O=R({inputs:{x:v},backend:n,attrs:{shape:y}}),k=div({inputs:{a:b,b:O},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(O),k}const Fn={kernelName:r.Softmax,backendName:"cpu",kernelFunc:_n};const Dn={kernelName:r.Multinomial,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{logits:l}=t,{numSamples:d,seed:h,normalized:f}=c;Object(o.a)(l,"multinomial");const m=f?l:_n({inputs:{logits:l},backend:n,attrs:{dim:-1}}),y=m.shape[0],x=m.shape[1],v=n.data.get(m.dataId).values,O=[y,d],k=r.util.makeZerosTypedArray(r.util.sizeFromShape(O),"int32");for(let b=0;b<y;++b){const e=b*x,t=new Float32Array(x-1);t[0]=v[e];for(let n=1;n<t.length;++n)t[n]=t[n-1]+v[e+n];const n=Rn.alea(h.toString()),r=b*d;for(let e=0;e<d;++e){const o=n();k[r+e]=t.length;for(let n=0;n<t.length;n++)if(o<t[n]){k[r+e]=n;break}}}return f||n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(O,"int32",k)}};var Mn=n(388);const Pn=r.kernel_impls.nonMaxSuppressionV3Impl;const Ln={kernelName:r.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:c,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=r;Object(o.a)(c,"NonMaxSuppression");const m=n.data.get(c.dataId).values,y=n.data.get(l.dataId).values,{selectedIndices:x}=Pn(m,y,d,h,f);return n.makeTensorInfo([x.length],"int32",new Int32Array(x))}},Bn=r.kernel_impls.nonMaxSuppressionV4Impl;const zn={kernelName:r.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:c,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:m}=r;Object(o.a)(c,"NonMaxSuppressionPadded");const y=n.data.get(c.dataId).values,x=n.data.get(l.dataId).values,{selectedIndices:v,validOutputs:O}=Bn(y,x,d,h,f,m);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([],"int32",new Int32Array([O]))]}},Vn=r.kernel_impls.nonMaxSuppressionV5Impl;const Wn={kernelName:r.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:c,scores:l}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,softNmsSigma:m}=r;Object(o.a)(c,"NonMaxSuppressionWithScore");const y=n.data.get(c.dataId).values,x=n.data.get(l.dataId).values,v=d,O=h,k=f,w=m,{selectedIndices:I,selectedScores:S}=Vn(y,x,v,O,k,w);return[n.makeTensorInfo([I.length],"int32",new Int32Array(I)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}};var Un=n(389);const Gn={kernelName:r.OneHot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{indices:l}=t,{dtype:d,depth:h,onValue:f,offValue:m}=c;Object(o.a)(l,"oneHot");const y=r.util.sizeFromShape(l.shape),x=new Float32Array(y*h);x.fill(m);const v=n.data.get(l.dataId).values;for(let e=0;e<y;++e)v[e]>=0&&v[e]<h&&(x[e*h+v[e]]=f);return n.makeTensorInfo([...l.shape,h],d,x)}};function Hn(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=Object($e.a)({inputs:{input:r},backend:n}),t=Hn({inputs:{x:e},backend:n}),o=je({inputs:{input:r},backend:n}),i=Hn({inputs:{x:o},backend:n}),c=Object(Se.a)({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}return $t({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const qn={kernelName:r.ZerosLike,backendName:"cpu",kernelFunc:Hn};const Kn={kernelName:r.OnesLike,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:o}=n;if("string"===o.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===o.dtype){const t=Object($e.a)({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r}),c=je({inputs:{input:o},backend:r}),i=Hn({inputs:{x:c},backend:r}),l=Object(Se.a)({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(i),l}return $t({backend:r,attrs:{shape:o.shape,value:1,dtype:o.dtype}})}};function Xn(e){const{inputs:t,backend:n,attrs:o}=e,{axis:c}=o;if(1===t.length)return vt({inputs:{input:t[0]},backend:n,attrs:{dim:c}});const l=t[0].shape,d=t[0].dtype;t.forEach((e=>{r.util.assertShapesMatch(l,e.shape,"All tensors passed to stack must have matching shapes"),r.util.assert(d===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const h=[],f=Ee({inputs:t.map((e=>{const t=vt({inputs:{input:e},backend:n,attrs:{dim:c}});return h.push(t),t})),backend:n,attrs:{axis:c}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const Yn={kernelName:r.Pack,backendName:"cpu",kernelFunc:Xn};const Zn={kernelName:r.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{paddings:d,constantValue:h}=c;Object(o.a)(l,"pad");const f=d.map(((p,i)=>p[0]+l.shape[i]+p[1])),m=d.map((p=>p[0])),y=n.data.get(l.dataId).values,x=r.util.sizeFromShape(l.shape),v=l.shape.length,O=r.util.computeStrides(l.shape),k=r.util.sizeFromShape(f),w=f.length,I=r.util.computeStrides(f),S=r.util.getTypedArrayFromDType(l.dtype,k);0!==h&&S.fill(h);for(let i=0;i<x;i++){const e=r.util.indexToLoc(i,v,O).map(((e,i)=>e+m[i]));S[r.util.locToIndex(e,w,I)]=y[i]}return{dataId:n.write(S,f,l.dtype),shape:f,dtype:l.dtype}}},Qn=Object(k.a)(((a,b)=>Math.pow(a,b))),Jn=Object(ne.a)(r.Pow,Qn),er={kernelName:r.Pow,backendName:"cpu",kernelFunc:Jn};var nr=n(390),rr=n(391);const ar={kernelName:r.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:o,values:c,defaultValue:l,rowPartitionTensors:d}=t,{rowPartitionTypes:h}=r,f=n.data.get(o.dataId).values,m=n.data.get(c.dataId).values,y=n.data.get(l.dataId).values,x=d.map((e=>n.data.get(e.dataId).values)),v=d.map((e=>e.shape)),[O,output]=Object(rr.a)(f,o.shape,m,c.shape,c.dtype,y,l.shape,x,v,h);return n.makeTensorInfo(O,c.dtype,output)}};var sr=n(392);const or={kernelName:r.Range,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:o,dtype:c,step:l}=n,d=Object(sr.a)(r,o,l,c);return t.makeTensorInfo([d.length],c,d)}},ir=Object(f.a)(r.Reciprocal,(e=>1/e)),ur={kernelName:r.Reciprocal,backendName:"cpu",kernelFunc:ir};const cr={kernelName:r.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{images:l}=t,{alignCorners:d,halfPixelCenters:h,size:f}=c;Object(o.a)(l,"resizeBilinear");const m=r.util.computeStrides(l.shape),[y,x]=f,[v,O,k,w]=l.shape,I=n.data.get(l.dataId).values,S=new Float32Array(r.util.sizeFromShape([v,y,x,w])),N=[d&&y>1?O-1:O,d&&x>1?k-1:k],T=[d&&y>1?y-1:y,d&&x>1?x-1:x];let j=0;const C=N[0]/T[0],$=N[1]/T[1];for(let b=0;b<v;b++)for(let e=0;e<y;e++){let t;t=h?C*(e+.5)-.5:C*e;const n=Math.max(0,Math.floor(t)),r=t-n,o=Math.min(O-1,Math.ceil(t)),c=b*m[0]+n*m[1],l=b*m[0]+o*m[1];for(let e=0;e<x;e++){let t;t=h?$*(e+.5)-.5:$*e;const n=Math.max(0,Math.floor(t)),o=t-n,d=Math.min(k-1,Math.ceil(t)),f=c+n*m[2],y=l+n*m[2],x=c+d*m[2],v=l+d*m[2];for(let e=0;e<w;e++){const t=I[f+e],n=I[y+e],c=t+(I[x+e]-t)*o,l=c+(n+(I[v+e]-n)*o-c)*r;S[j++]=l}}}return n.makeTensorInfo([v,y,x,w],"float32",S)}};const lr={kernelName:r.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{images:l,dy:d}=t,{alignCorners:h}=c;Object(o.a)([d,l],"resizeBilinearGrad");const f=r.util.computeStrides(l.shape),[m,y,x,v]=l.shape,[,O,k]=d.shape,output=new Float32Array(m*y*x*v),w=[h&&O>1?y-1:y,h&&k>1?x-1:x],I=[h&&O>1?O-1:O,h&&k>1?k-1:k],S=w[0]/I[0],N=w[1]/I[1],T=n.data.get(d.dataId).values;let j=0;for(let b=0;b<m;b++){const e=b*f[0];for(let t=0;t<O;t++){const n=t*S,r=Math.floor(n),o=Math.min(Math.ceil(n),y-1),c=e+r*f[1],l=e+o*f[1],d=n-r,h=1-d;for(let e=0;e<k;e++){const t=e*N,n=Math.floor(t),r=Math.min(Math.ceil(t),x-1),o=t-n,m=1-o,y=c+n*f[2],O=c+r*f[2],k=l+n*f[2],w=l+r*f[2],I=h*m,S=h*o,C=d*m,$=d*o;for(let e=0;e<v;e++){const t=T[j++];output[y+e]+=t*I,output[O+e]+=t*S,output[k+e]+=t*C,output[w+e]+=t*$}}}}return n.makeTensorInfo([m,x,y,v],"float32",output)}};const dr={kernelName:r.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{images:l}=t,{alignCorners:d,halfPixelCenters:h,size:f}=c;Object(o.a)(l,"resizeNearestNeighbor");const m=r.util.computeStrides(l.shape),[y,x]=f,[v,O,k,w]=l.shape,I=n.data.get(l.dataId).values,output=new Float32Array(v*y*x*w),S=[d&&y>1?O-1:O,d&&x>1?k-1:k],N=[d&&y>1?y-1:y,d&&x>1?x-1:x],T=S[0]/N[0],j=S[1]/N[1];let C=0;for(let b=0;b<v;b++){const e=b*m[0];for(let t=0;t<y;t++){const n=h?T*(t+.5):T*t;let r=Math.min(O-1,d?Math.round(n):Math.floor(n));h&&(r=Math.max(0,r));const o=e+r*m[1];for(let e=0;e<x;e++){const t=h?j*(e+.5):j*e;let n=Math.min(k-1,d?Math.round(t):Math.floor(t));h&&(n=Math.max(0,n));const r=o+n*m[2];for(let e=0;e<w;e++){const t=I[r+e];output[C++]=t}}}}return n.makeTensorInfo([v,y,x,w],l.dtype,output)}};const pr={kernelName:r.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{images:l,dy:d}=t,{alignCorners:h}=c;Object(o.a)([d,l],"resizeNearestNeighborGrad");const f=r.util.computeStrides(l.shape),m=r.util.computeStrides(d.shape),[y,x,v,O]=l.shape,[,k,w]=d.shape,output=new Float32Array(y*x*v*O),I=n.data.get(d.dataId).values,S=[h&&k>1?x-1:x,h&&w>1?v-1:v],N=[h&&k>1?k-1:k,h&&w>1?w-1:w],T=S[0]/N[0],j=S[1]/N[1],C=1/T,$=1/j,E=2*Math.ceil(C)+2,A=2*Math.ceil($)+2;for(let b=0;b<y;b++){const e=b*f[0];for(let t=0;t<x;t++){const n=e+t*f[1],r=Math.floor(t*C),o=Math.floor(r-E/2);for(let r=0;r<v;r++){const c=n+r*f[2],l=Math.floor(r*$),d=Math.floor(l-A/2);for(let n=0;n<O;n++){let l=0;for(let c=0;c<E;c++){const f=c+o;if(f<0||f>=k)continue;const y=e+f*m[1],O=f*T;if(t===Math.min(x-1,h?Math.round(O):Math.floor(O)))for(let e=0;e<A;e++){const t=e+d;if(t<0||t>=w)continue;const o=y+t*m[2],c=t*j;r===Math.min(v-1,h?Math.round(c):Math.floor(c))&&(l+=I[o+n])}}output[c+n]=l}}}}return n.makeTensorInfo(l.shape,l.dtype,output)}};const fr={kernelName:r.Reverse,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{dims:d}=c;Object(o.a)(l,"reverse");const h=l.shape.length,f=r.util.parseAxisParam(d,l.shape);if(0===h)return Object(x.a)({inputs:{x:l},backend:n});const m=new r.TensorBuffer(l.shape,l.dtype),y=n.bufferSync(l);for(let i=0;i<m.size;i++){const e=m.indexToLoc(i),t=e.slice();f.forEach((e=>t[e]=l.shape[e]-1-t[e])),m.set(y.get(...t),...e)}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},mr={kernelName:r.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:image}=e,{radians:o,fillValue:c,center:l}=t,d=n,output=r.util.getTypedArrayFromDType(image.dtype,r.util.sizeFromShape(image.shape)),[h,f,m,y]=image.shape,[x,v]=r.backend_util.getImageCenter(l,f,m),O=Math.sin(o),k=Math.cos(o),w=d.data.get(image.dataId).values;for(let e=0;e<h;e++){const t=e*m*f*y;for(let e=0;e<f;e++){const n=e*(m*y);for(let col=0;col<m;col++){const r=col*y;for(let o=0;o<y;o++){const l=[h,e,col,o],d=l[2],I=l[1];let S=(d-x)*k-(I-v)*O,N=(d-x)*O+(I-v)*k;S=Math.round(S+x),N=Math.round(N+v);let T=c;if("number"!=typeof c&&(T=3===o?255:c[o]),S>=0&&S<m&&N>=0&&N<f){T=w[t+N*(m*y)+S*y+o]}output[t+n+r+o]=T}}}}return{dataId:d.write(output,image.shape,image.dtype),shape:image.shape,dtype:image.dtype}}},gr=Object(f.a)(r.Round,(e=>{const base=Math.floor(e);return e-base<.5?Math.floor(e):e-base>.5?Math.ceil(e):base%2==0?base:base+1})),yr={kernelName:r.Round,backendName:"cpu",kernelFunc:gr};var xr=n(393),vr=n(354);const Or={kernelName:r.ScatterNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{indices:c,updates:l}=t,{shape:d}=o,{sliceRank:h,numUpdates:f,sliceSize:m,strides:y,outputSize:x}=r.backend_util.calculateShapes(l,c,d),v=n.bufferSync(c),O=n.bufferSync(l),k=Object(vr.a)(v,O,d,x,m,f,h,y,0,!0);return n.makeTensorInfo(d,k.dtype,k.values)}};function kr(e,t){let n=0,r=e.length,o=0;for(;n<r;)o=Math.floor((n+r)/2),e[o]<t?n=o+1:r=o;return r}function wr(e,t){let n=0,r=e.length,o=0;for(;n<r;)o=Math.floor((n+r)/2),e[o]<=t?n=o+1:r=o;return r}const Ir={kernelName:r.SearchSorted,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{sortedSequence:c,values:l}=t,{side:d}=o,output=function(e,t,n,o,c,l){const output=r.util.getArrayFromDType("int32",n*c);for(let b=0;b<n;++b){const n=e.slice(b*o,(b+1)*o),r=b*c;for(let i=0;i<c;++i)output[r+i]="left"===l?kr(n,t[i+r]):wr(n,t[i+r])}return output}(n.data.get(c.dataId).values,n.data.get(l.dataId).values,c.shape[0],c.shape[1],l.shape[1],d);return n.makeTensorInfo(l.shape,"int32",output)}};const Sr={kernelName:r.Select,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:c,t:l,e:d}=t;Object(o.a)([c,l,d],"select");const h=c.shape.length,f=n.data.get(c.dataId).values,m=n.data.get(l.dataId).values,y=n.data.get(d.dataId).values,x=Object(r.upcastType)(l.dtype,d.dtype),v=r.util.makeZerosTypedArray(r.util.sizeFromShape(l.shape),x);let O=0;const k=0===h||h>1||1===l.shape.length?1:r.util.sizeFromShape(l.shape.slice(1));for(let i=0;i<f.length;i++)for(let e=0;e<k;e++)1===f[i]?v[O++]=m[i]:v[O++]=y[i];return n.makeTensorInfo(l.shape,x,v)}},Nr=r.backend_util.SELU_SCALEALPHA,Tr=r.backend_util.SELU_SCALE,jr=Object(f.a)(r.Selu,(e=>e>=0?Tr*e:Nr*(Math.exp(e)-1))),Cr={kernelName:r.Selu,backendName:"cpu",kernelFunc:jr},$r=Object(f.a)(r.Sign,(e=>e<0?-1:e>0?1:0)),Er={kernelName:r.Sign,backendName:"cpu",kernelFunc:$r},Ar=Object(f.a)(r.Sin,(e=>Math.sin(e))),Rr={kernelName:r.Sin,backendName:"cpu",kernelFunc:Ar},_r=Object(f.a)(r.Sinh,(e=>Math.sinh(e))),Fr={kernelName:r.Sinh,backendName:"cpu",kernelFunc:_r},Dr=Math.log(1.1920928955078125e-7)+2,Mr=Object(f.a)(r.Softplus,(e=>{const t=e>-Dr,n=e<Dr,r=Math.exp(e);let o;return o=n?r:t?e:Math.log(1+r),o})),Pr={kernelName:r.Softplus,backendName:"cpu",kernelFunc:Mr};const Lr={kernelName:r.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{blockShape:d,paddings:h}=c;Object(o.a)([l],"spaceToBatchND");const f=r.util.sizeFromShape(d),m=[[0,0]];m.push(...h);for(let i=1+d.length;i<l.shape.length;++i)m.push([0,0]);const y=Zn.kernelFunc({inputs:{x:l},backend:n,attrs:{paddings:m,constantValue:0}}),x=r.backend_util.getReshaped(y.shape,d,f,!1),v=r.backend_util.getPermuted(x.length,d.length,!1),O=r.backend_util.getReshapedPermuted(y.shape,d,f,!1),k=R({inputs:{x:y},backend:n,attrs:{shape:x}}),w={x:k},I={perm:v},S=Object(U.a)({inputs:w,backend:n,attrs:I}),N=R({inputs:{x:S},backend:n,attrs:{shape:O}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(S),N}};var Br=n(394);const zr={kernelName:r.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:o,denseShape:c,defaultValue:l}=t;if(1!==c.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${c.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==o.shape.length)throw new Error(`Values must be a vector, saw:\n        ${o.shape}`);if(0!==l.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${l.shape}`);const d=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,f=n.data.get(c.dataId).values,m=n.data.get(l.dataId).values[0],[y,x,v,O,k]=Object(Br.a)(d,r.shape,r.dtype,h,o.dtype,f,m);return[n.makeTensorInfo(x,r.dtype,y),n.makeTensorInfo([x[0]],o.dtype,v),n.makeTensorInfo([O.length],"bool",new Uint8Array(O.map((e=>Number(e))))),n.makeTensorInfo([k.length],r.dtype,new Int32Array(k))]}};var Vr=n(395);const Wr={kernelName:r.SparseReshape,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:o,newShape:c}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==o.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${o.shape}`);if(1!==c.shape.length)throw new Error(`Target shape should be a vector but received shape ${c.shape}`);const l=Array.from(n.data.get(o.dataId).values),d=n.data.get(r.dataId).values,h=Array.from(n.data.get(c.dataId).values),[f,m,y]=Object(Vr.a)(d,r.shape,r.dtype,l,h);return[n.makeTensorInfo(m,r.dtype,f),n.makeTensorInfo([y.length],c.dtype,new Int32Array(y))]}};var Ur=n(356);const Gr={kernelName:r.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const c=n.data.get(data.dataId).values,l=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,[h,f]=Object(Ur.a)(c,data.shape,data.dtype,l,d,!0);return n.makeTensorInfo(f,data.dtype,h)}};const Hr={kernelName:r.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const c=n.data.get(data.dataId).values,l=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,[h,f]=Object(Ur.a)(c,data.shape,data.dtype,l,d);return n.makeTensorInfo(f,data.dtype,h)}};const qr={kernelName:r.SparseToDense,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{sparseIndices:c,sparseValues:l,defaultValue:d}=t,{outputShape:h}=o,{sliceRank:f,numUpdates:m,sliceSize:y,strides:x,outputSize:v}=r.backend_util.calculateShapes(l,c,h),O=!1,k=n.bufferSync(c);let w;switch(l.dtype){case"bool":{const e=n.bufferSync(l),t=Boolean(n.data.get(d.dataId).values[0]);w=Object(vr.a)(k,e,h,v,y,m,f,x,t,O);break}case"float32":{const e=n.bufferSync(l),t=n.data.get(d.dataId).values[0];w=Object(vr.a)(k,e,h,v,y,m,f,x,t,O);break}case"int32":{const e=n.bufferSync(l),t=n.data.get(d.dataId).values[0];w=Object(vr.a)(k,e,h,v,y,m,f,x,t,O);break}case"string":{const e=n.bufferSync(l),t=r.util.decodeString(n.data.get(d.dataId).values[0]);w=Object(vr.a)(k,e,h,v,y,m,f,x,t,O);break}default:throw new Error(`Unsupported type ${l.dtype}`)}return n.makeTensorInfo(h,w.dtype,w.values)}};const Kr={kernelName:r.SplitV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:c}=t,{numOrSizeSplits:l,axis:d}=o,h=r.util.parseAxisParam(d,c.shape)[0],f=r.backend_util.prepareSplitSize(c,l,h),m=new Array(c.shape.length).fill(0),y=c.shape.slice();return f.map((s=>{const e=[...y];e[h]=s;const t=Object(be.a)({inputs:{x:c},backend:n,attrs:{begin:m,size:e}});return m[h]+=s,t}))}};var Xr=n(396);const Yr={kernelName:r.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;Object(o.a)(n,"square");const c=r.data.get(n.dataId).values,l=new Float32Array(c.length);for(let i=0;i<c.length;++i){const e=c[i];l[i]=e*e}return{dataId:r.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Zr=n(397);const Qr=Object(f.a)(r.Step,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),Jr={kernelName:r.Step,backendName:"cpu",kernelFunc:Qr};var ea=n(398);const ta={kernelName:r.StridedSlice,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{begin:d,end:h,strides:f,beginMask:m,endMask:y,ellipsisMask:x,newAxisMask:v,shrinkAxisMask:O}=c;Object(o.a)(l,"stridedSlice");const{finalShapeSparse:k,finalShape:w,isIdentity:I,sliceDim0:S,isSimpleSlice:N,begin:T,end:j,strides:C}=r.slice_util.sliceInfo(l.shape,d,h,f,m,y,x,v,O);let $;if(I)$=R({inputs:{x:l},backend:n,attrs:{shape:w}});else if(S||N){r.util.assert(l.shape.length>=1,(()=>`Input must have rank at least 1, got: ${l.shape.length}`));const e=r.slice_util.computeOutShape(T,j,C),t=Object(be.a)({inputs:{x:l},backend:n,attrs:{begin:T,size:e}});$=R({inputs:{x:t},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(t)}else{const e=n.bufferSync(l),t=Object(ea.a)(k,e,C,T);$=n.makeTensorInfo(w,t.dtype,t.values)}return $}};var na=n(399);const ra={kernelName:r.StringNGrams,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:o,nGramWidths:c,leftPad:l,rightPad:d,padWidth:h,preserveShortSequences:f}=r,{data:data,dataSplits:m}=t,y=n.data.get(data.dataId).values,x=n.data.get(m.dataId).values,[v,O]=Object(na.a)(y,x,o,c,l,d,h,f);return[n.makeTensorInfo([v.length],"string",v),n.makeTensorInfo(m.shape,"int32",O)]}};var aa=n(400);const sa={kernelName:r.StringSplit,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:o}=r,{input:input,delimiter:c}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(1!==input.shape.length)throw new Error(`Input must be a vector, got shape: ${input.shape}`);if(0!==c.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${c.shape}`);const l=n.data.get(input.dataId).values,d=n.data.get(c.dataId).values[0],[h,f,m]=Object(aa.a)(l,d,o),y=f.length;return[n.makeTensorInfo([y,2],"int32",h),n.makeTensorInfo([y],"string",f),n.makeTensorInfo([2],"int32",new Int32Array(m))]}};var oa=n(401);const ia={kernelName:r.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:o}=r,{input:input}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const c=n.data.get(input.dataId).values,output=Object(oa.a)(c,o);return n.makeTensorInfo(input.shape,"int32",output)}},ua=Object(f.a)(r.Tan,(e=>Math.tan(e))),ca={kernelName:r.Tan,backendName:"cpu",kernelFunc:ua},la=Object(f.a)(r.Tanh,(e=>Math.tanh(e))),da={kernelName:r.Tanh,backendName:"cpu",kernelFunc:la};var pa=n(402);const ha={kernelName:r.Tile,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:c}=t,{reps:l}=r;Object(o.a)(c,"tile");const d=Object(pa.a)(n.bufferSync(c),l);return n.makeTensorInfo(d.shape,d.dtype,d.values)}};var fa=n(403);const ma={kernelName:r.TopK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:c}=t,{k:l,sorted:d}=r;Object(o.a)(c,"topk");const h=n.data.get(c.dataId).values,[f,m]=Object(fa.a)(h,c.shape,c.dtype,l,d);return[n.makeTensorInfo(f.shape,f.dtype,f.values),n.makeTensorInfo(m.shape,m.dtype,m.values)]}};const ba={kernelName:r.Transform,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:o}=e,{image:image,transforms:c}=t,{interpolation:l,fillMode:d,fillValue:h,outputShape:f}=n,[m,y,x,v]=image.shape,[O,k]=null!=f?f:[y,x],w=[m,O,k,v],I=r.util.computeStrides(image.shape),S=I[0],N=I[1],T=I[2],j=r.util.computeStrides(w),C=j[0],$=j[1],E=j[2],A=r.util.getTypedArrayFromDType(image.dtype,r.util.sizeFromShape(w));A.fill(h);const R=o.data.get(image.dataId).values,_=o.data.get(c.dataId).values;for(let b=0;b<m;++b){const e=1===c.shape[0]?_:_.subarray(8*b,8*b+8);for(let t=0;t<O;++t)for(let n=0;n<k;++n)for(let r=0;r<v;++r){let o;const c=e[6]*n+e[7]*t+1;if(0===c)continue;const f=(e[0]*n+e[1]*t+e[2])/c,m=(e[3]*n+e[4]*t+e[5])/c,v=ga(f,x,d),O=ga(m,y,d);switch(l){case"nearest":o=xa(R,y,x,S,N,T,b,O,v,r,h);break;case"bilinear":o=va(R,y,x,S,N,T,b,O,v,r,h);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${l}`)}A[b*C+t*$+n*E+r]=o}return o.makeTensorInfo(w,image.dtype,A)}return{dataId:o.write(A,w,image.dtype),shape:image.shape,dtype:image.dtype}}};function ga(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return r.util.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return r.util.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return r.util.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function ya(e,t,n,r,o,c,l,d,h,f,m){return 0<=d&&d<t&&0<=h&&h<n?e[l*r+d*o+h*c+f]:m}function xa(e,t,n,r,o,c,l,d,h,f,m){return ya(e,t,n,r,o,c,l,Math.round(d),Math.round(h),f,m)}function va(e,t,n,r,o,c,l,d,h,f,m){const y=Math.floor(d),x=Math.floor(h),v=y+1,O=x+1;return(v-d)*((O-h)*ya(e,t,n,r,o,c,l,y,x,f,m)+(h-x)*ya(e,t,n,r,o,c,l,y,O,f,m))+(d-y)*((O-h)*ya(e,t,n,r,o,c,l,v,x,f,m)+(h-x)*ya(e,t,n,r,o,c,l,v,O,f,m))}var Oa=n(404);const ka={kernelName:r.Unique,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:c}=n,{x:l}=t;Object(o.a)(l,"unique");const d=r.data.get(l.dataId).values,{outputValues:h,outputShape:f,indices:m}=Object(Oa.a)(d,c,l.shape,l.dtype);return[r.makeTensorInfo(f,l.dtype,h),r.makeTensorInfo([m.length],"int32",m)]}};const wa={kernelName:r.Unpack,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:o}=t;let{axis:c}=r;c<0&&(c+=o.shape.length);const l=o.shape.length,d=o.shape[c],h=new Array(l-1);let f=0;for(let i=0;i<l;i++)i!==c&&(h[f++]=o.shape[i]);const m=new Array(l).fill(0),y=o.shape.slice();y[c]=1;const x=new Array(d);for(let i=0;i<x.length;i++){m[c]=i;const e=Object(be.a)({inputs:{x:o},backend:n,attrs:{begin:m,size:y}});x[i]=R({inputs:{x:e},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(e)}return x}};const Ia={kernelName:r.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:l,segmentIds:d}=t,{numSegments:h}=c;Object(o.a)(l,"unsortedSegmentSum");const f=[],m=[],y=l.shape.length-d.shape.length;let x=d;for(let i=0;i<y;++i){const e=vt({inputs:{input:x},backend:n,attrs:{dim:i+1}});x=e,m.push(e)}for(let i=0;i<h;++i){const e=r.util.createScalarValue(i,"int32"),t=n.makeTensorInfo([],"int32",e),mask=Object(lt.a)({inputs:{a:t,b:x},backend:n}),o=Object(Oe.a)({inputs:{x:mask},backend:n,attrs:{dtype:"float32"}}),c=Object(at.a)({inputs:{a:o,b:l},backend:n}),d=ot({inputs:{x:c},backend:n,attrs:{axis:0,keepDims:!1}});f.push(d),m.push(t),m.push(mask),m.push(o),m.push(c),m.push(d)}const v=Xn({inputs:f,backend:n,attrs:{axis:0}});return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}},Sa=[M,P.a,B,V,A.b,W,G,H,K,X,Z,J,te,se,ie,de,pe,he,fe,D,me,ge,xe,ve,Oe.b,ke.a,Ie,Se.b,Ne,Ae,_e,Fe,De,Me,Pe,Le,ze,We,Ue,Ge,He,qe,Ke,Ye,Ze,Qe,Je,et,tt,nt,ut,y,ct,lt.b,yt,xt.b,Ot,kt.a,Ct,Et,At,Rt.a,Dt,Mt,Pt,Bt,Vt,Wt.a,Ut.a,x.b,Gt,Ce,qt,Xt,Zt,O,Qt.a,Jt.a,tn,nn.a,an,un,ln,hn,fn,mn,xn,vn.a,On,kn,wn,In,Sn,Nn,Tn,jn.a,Cn,An,Dn,at.b,Mn.a,Ln,zn,Wn,Un.a,Gn,Kn,Yn,Zn,er,S,nr.a,ar,or,$e.b,It,ur,T,C,_,cr,lr,dr,pr,fr,mr,yr,xr.a,Or,Ir,Sr,Cr,$.b,Er,Rr,Fr,be.b,Fn,Pr,Lr,zr,Wr,Gr,Hr,qr,Kr,Xr.a,Yr,Zr.a,Jr,ta,ra,sa,ia,St.b,it,ca,da,ha,ma,ba,U.b,ka,wa,Ia,qn];for(const e of Sa)Object(r.registerKernel)(e)},function(e,t,n){"use strict";n.r(t),n.d(t,"GraphModel",(function(){return L})),n.d(t,"loadGraphModel",(function(){return B})),n.d(t,"loadGraphModelSync",(function(){return z})),n.d(t,"deregisterOp",(function(){return h.a})),n.d(t,"registerOp",(function(){return h.c})),n.d(t,"version_converter",(function(){return V}));var r={};n.r(r),n.d(r,"abs",(function(){return f.b})),n.d(r,"acos",(function(){return f.c})),n.d(r,"acosh",(function(){return f.d})),n.d(r,"add",(function(){return f.e})),n.d(r,"addN",(function(){return f.f})),n.d(r,"all",(function(){return f.g})),n.d(r,"any",(function(){return f.h})),n.d(r,"argMax",(function(){return f.i})),n.d(r,"argMin",(function(){return f.j})),n.d(r,"asin",(function(){return f.k})),n.d(r,"asinh",(function(){return f.l})),n.d(r,"atan",(function(){return f.m})),n.d(r,"atan2",(function(){return f.n})),n.d(r,"atanh",(function(){return f.o})),n.d(r,"avgPool",(function(){return f.p})),n.d(r,"avgPool3d",(function(){return f.q})),n.d(r,"basicLSTMCell",(function(){return f.r})),n.d(r,"batchToSpaceND",(function(){return f.w})),n.d(r,"batchNorm",(function(){return f.s})),n.d(r,"batchNorm2d",(function(){return f.t})),n.d(r,"batchNorm3d",(function(){return f.u})),n.d(r,"batchNorm4d",(function(){return f.v})),n.d(r,"bincount",(function(){return f.x})),n.d(r,"broadcastArgs",(function(){return f.z})),n.d(r,"broadcastTo",(function(){return f.A})),n.d(r,"buffer",(function(){return f.B})),n.d(r,"cast",(function(){return f.C})),n.d(r,"ceil",(function(){return f.D})),n.d(r,"clipByValue",(function(){return f.E})),n.d(r,"clone",(function(){return f.F})),n.d(r,"complex",(function(){return f.G})),n.d(r,"concat",(function(){return f.H})),n.d(r,"concat1d",(function(){return f.I})),n.d(r,"concat2d",(function(){return f.J})),n.d(r,"concat3d",(function(){return f.K})),n.d(r,"concat4d",(function(){return f.L})),n.d(r,"conv1d",(function(){return f.M})),n.d(r,"conv2d",(function(){return f.N})),n.d(r,"conv2dTranspose",(function(){return f.O})),n.d(r,"conv3d",(function(){return f.P})),n.d(r,"conv3dTranspose",(function(){return f.Q})),n.d(r,"cos",(function(){return f.R})),n.d(r,"cosh",(function(){return f.S})),n.d(r,"cumprod",(function(){return f.U})),n.d(r,"cumsum",(function(){return f.V})),n.d(r,"denseBincount",(function(){return f.W})),n.d(r,"depthToSpace",(function(){return f.X})),n.d(r,"depthwiseConv2d",(function(){return f.Y})),n.d(r,"diag",(function(){return f.Z})),n.d(r,"dilation2d",(function(){return f.ab})),n.d(r,"div",(function(){return f.bb})),n.d(r,"divNoNan",(function(){return f.cb})),n.d(r,"dot",(function(){return f.db})),n.d(r,"einsum",(function(){return f.fb})),n.d(r,"elu",(function(){return f.gb})),n.d(r,"equal",(function(){return f.ib})),n.d(r,"erf",(function(){return f.jb})),n.d(r,"euclideanNorm",(function(){return f.kb})),n.d(r,"exp",(function(){return f.lb})),n.d(r,"expandDims",(function(){return f.mb})),n.d(r,"expm1",(function(){return f.nb})),n.d(r,"eye",(function(){return f.ob})),n.d(r,"fill",(function(){return f.qb})),n.d(r,"floor",(function(){return f.rb})),n.d(r,"floorDiv",(function(){return f.sb})),n.d(r,"gather",(function(){return f.ub})),n.d(r,"greater",(function(){return f.wb})),n.d(r,"greaterEqual",(function(){return f.xb})),n.d(r,"imag",(function(){return f.zb})),n.d(r,"isFinite",(function(){return f.Db})),n.d(r,"isInf",(function(){return f.Eb})),n.d(r,"isNaN",(function(){return f.Fb})),n.d(r,"leakyRelu",(function(){return f.Gb})),n.d(r,"less",(function(){return f.Hb})),n.d(r,"lessEqual",(function(){return f.Ib})),n.d(r,"linspace",(function(){return f.Kb})),n.d(r,"localResponseNormalization",(function(){return f.Lb})),n.d(r,"log",(function(){return f.Mb})),n.d(r,"log1p",(function(){return f.Nb})),n.d(r,"logSigmoid",(function(){return f.Ob})),n.d(r,"logSoftmax",(function(){return f.Pb})),n.d(r,"logSumExp",(function(){return f.Qb})),n.d(r,"logicalAnd",(function(){return f.Rb})),n.d(r,"logicalNot",(function(){return f.Sb})),n.d(r,"logicalOr",(function(){return f.Tb})),n.d(r,"logicalXor",(function(){return f.Ub})),n.d(r,"lowerBound",(function(){return f.Wb})),n.d(r,"matMul",(function(){return f.Xb})),n.d(r,"max",(function(){return f.Yb})),n.d(r,"maxPool",(function(){return f.Zb})),n.d(r,"maxPool3d",(function(){return f.ac})),n.d(r,"maxPoolWithArgmax",(function(){return f.bc})),n.d(r,"maximum",(function(){return f.cc})),n.d(r,"mean",(function(){return f.dc})),n.d(r,"meshgrid",(function(){return f.ec})),n.d(r,"min",(function(){return f.fc})),n.d(r,"minimum",(function(){return f.gc})),n.d(r,"mirrorPad",(function(){return f.hc})),n.d(r,"mod",(function(){return f.ic})),n.d(r,"moments",(function(){return f.jc})),n.d(r,"mul",(function(){return f.lc})),n.d(r,"multiRNNCell",(function(){return f.mc})),n.d(r,"multinomial",(function(){return f.nc})),n.d(r,"neg",(function(){return f.oc})),n.d(r,"notEqual",(function(){return f.qc})),n.d(r,"oneHot",(function(){return f.rc})),n.d(r,"ones",(function(){return f.sc})),n.d(r,"onesLike",(function(){return f.tc})),n.d(r,"outerProduct",(function(){return f.vc})),n.d(r,"pad",(function(){return f.wc})),n.d(r,"pad1d",(function(){return f.xc})),n.d(r,"pad2d",(function(){return f.yc})),n.d(r,"pad3d",(function(){return f.zc})),n.d(r,"pad4d",(function(){return f.Ac})),n.d(r,"pool",(function(){return f.Bc})),n.d(r,"pow",(function(){return f.Cc})),n.d(r,"prelu",(function(){return f.Dc})),n.d(r,"print",(function(){return f.Ec})),n.d(r,"prod",(function(){return f.Fc})),n.d(r,"raggedTensorToTensor",(function(){return f.Gc})),n.d(r,"rand",(function(){return f.Hc})),n.d(r,"randomGamma",(function(){return f.Ic})),n.d(r,"randomNormal",(function(){return f.Jc})),n.d(r,"randomStandardNormal",(function(){return f.Kc})),n.d(r,"randomUniform",(function(){return f.Lc})),n.d(r,"range",(function(){return f.Mc})),n.d(r,"real",(function(){return f.Nc})),n.d(r,"reciprocal",(function(){return f.Oc})),n.d(r,"relu",(function(){return f.Pc})),n.d(r,"relu6",(function(){return f.Qc})),n.d(r,"reshape",(function(){return f.Rc})),n.d(r,"reverse",(function(){return f.Sc})),n.d(r,"reverse1d",(function(){return f.Tc})),n.d(r,"reverse2d",(function(){return f.Uc})),n.d(r,"reverse3d",(function(){return f.Vc})),n.d(r,"reverse4d",(function(){return f.Wc})),n.d(r,"round",(function(){return f.Yc})),n.d(r,"rsqrt",(function(){return f.Zc})),n.d(r,"scalar",(function(){return f.ad})),n.d(r,"selu",(function(){return f.dd})),n.d(r,"separableConv2d",(function(){return f.ed})),n.d(r,"setdiff1dAsync",(function(){return f.fd})),n.d(r,"sigmoid",(function(){return f.gd})),n.d(r,"sign",(function(){return f.hd})),n.d(r,"sin",(function(){return f.jd})),n.d(r,"sinh",(function(){return f.kd})),n.d(r,"slice",(function(){return f.ld})),n.d(r,"slice1d",(function(){return f.md})),n.d(r,"slice2d",(function(){return f.nd})),n.d(r,"slice3d",(function(){return f.od})),n.d(r,"slice4d",(function(){return f.pd})),n.d(r,"softmax",(function(){return f.qd})),n.d(r,"softplus",(function(){return f.rd})),n.d(r,"spaceToBatchND",(function(){return f.sd})),n.d(r,"fft",(function(){return f.pb})),n.d(r,"ifft",(function(){return f.yb})),n.d(r,"irfft",(function(){return f.Cb})),n.d(r,"rfft",(function(){return f.Xc})),n.d(r,"split",(function(){return f.wd})),n.d(r,"sqrt",(function(){return f.xd})),n.d(r,"square",(function(){return f.yd})),n.d(r,"squaredDifference",(function(){return f.zd})),n.d(r,"squeeze",(function(){return f.Ad})),n.d(r,"stack",(function(){return f.Bd})),n.d(r,"step",(function(){return f.Cd})),n.d(r,"stridedSlice",(function(){return f.Dd})),n.d(r,"sub",(function(){return f.Fd})),n.d(r,"sum",(function(){return f.Gd})),n.d(r,"tan",(function(){return f.Hd})),n.d(r,"tanh",(function(){return f.Id})),n.d(r,"tensor",(function(){return f.Jd})),n.d(r,"tensor1d",(function(){return f.Kd})),n.d(r,"tensor2d",(function(){return f.Ld})),n.d(r,"tensor3d",(function(){return f.Md})),n.d(r,"tensor4d",(function(){return f.Nd})),n.d(r,"tensor5d",(function(){return f.Od})),n.d(r,"tensor6d",(function(){return f.Pd})),n.d(r,"tile",(function(){return f.Qd})),n.d(r,"topk",(function(){return f.Rd})),n.d(r,"truncatedNormal",(function(){return f.Td})),n.d(r,"unique",(function(){return f.Ud})),n.d(r,"unsortedSegmentSum",(function(){return f.Vd})),n.d(r,"unstack",(function(){return f.Wd})),n.d(r,"upperBound",(function(){return f.Xd})),n.d(r,"variable",(function(){return f.Yd})),n.d(r,"where",(function(){return f.Zd})),n.d(r,"whereAsync",(function(){return f.ae})),n.d(r,"zeros",(function(){return f.be})),n.d(r,"zerosLike",(function(){return f.ce})),n.d(r,"booleanMaskAsync",(function(){return f.y})),n.d(r,"transpose",(function(){return f.Sd})),n.d(r,"norm",(function(){return f.pc})),n.d(r,"movingAverage",(function(){return f.kc})),n.d(r,"scatterND",(function(){return f.bd})),n.d(r,"searchSorted",(function(){return f.cd})),n.d(r,"sparseToDense",(function(){return f.ud})),n.d(r,"gatherND",(function(){return f.vb})),n.d(r,"dropout",(function(){return f.eb})),n.d(r,"enclosingPowerOfTwo",(function(){return f.hb})),n.d(r,"cosineWindow",(function(){return f.T})),n.d(r,"inTopKAsync",(function(){return f.Bb})),n.d(r,"op",(function(){return f.uc})),n.d(r,"OP_SCOPE_SUFFIX",(function(){return f.a})),n.d(r,"image",(function(){return f.Ab})),n.d(r,"linalg",(function(){return f.Jb})),n.d(r,"losses",(function(){return f.Vb})),n.d(r,"spectral",(function(){return f.vd})),n.d(r,"fused",(function(){return f.tb})),n.d(r,"signal",(function(){return f.id})),n.d(r,"sparse",(function(){return f.td})),n.d(r,"string",(function(){return f.Ed}));var o=n(279);Object(o.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}));var c=n(409),l=n(290);class d{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Object(l.e)(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Object(l.e)(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Object(c.f)(this.node.rawAttrs,e,t);if(null!=n.s)return Object(c.i)(this.node.rawAttrs,e,t);if(null!=n.b)return Object(c.c)(this.node.rawAttrs,e,t);if(null!=n.shape)return Object(c.k)(this.node.rawAttrs,e,t);if(null!=n.type)return Object(c.e)(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Object(c.g)(this.node.rawAttrs,e,t);if(null!=n.list.s)return Object(c.h)(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Object(c.j)(this.node.rawAttrs,e,t);if(null!=n.list.b)return Object(c.b)(this.node.rawAttrs,e,t);if(null!=n.list.type)return Object(c.d)(this.node.rawAttrs,e,t)}return t}}var h=n(344),f=n(334);function m(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){o.util.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let i=0;i<e.length;i++){const r=e[i],c=t[i];o.util.assert(r<0||c<0||r===c,(()=>n+` Shapes ${e} and ${t} must match`))}}}function y(e){return"number"!=typeof e&&!e.some((e=>e<0))}function x(e,t,n){let r=v(e,n);const o=!y(r);if(o&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&t.forEach((e=>{r=v(e.shape,r)})),!y(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function v(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let i=0;i<e.length;++i){const r=e[i],o=t[i];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[i]=r>=0?r:o}return n}class O{constructor(e,t,n,r,c,l,d){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=c,this.dynamicSize=l,this.clearAfterRead=d,this.tensors=[],this.closed_=!1,this.idTensor=Object(o.scalar)(0),Object(o.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),m(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Object(o.keep)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((i,e)=>this.write(i,t[e])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(0===e.length)return Object(o.tensor)([],[0].concat(this.elementShape));const n=this.readMany(e);return m(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Object(o.stack)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Object(o.tensor)([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const n=this.readMany(t);return m(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Object(o.concat)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Object(o.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const c=0===n?0:t.size/n,l=[];Object(o.tidy)((()=>{t=Object(o.reshape)(t,[1,n,c]);for(let i=0;i<e.length;++i){const n=[0,0===i?0:r[i-1],0],d=[1,e[i],c];l[i]=Object(o.reshape)(Object(o.slice)(t,n,d),this.elementShape)}return l}));const d=[];for(let i=0;i<e.length;i++)d[i]=i;this.writeMany(d,l)}}class k{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);m(t,e.shape,"TensorList shape mismatch: "),Object(o.keep)(e)})),this.idTensor=Object(o.scalar)(0),this.maxNumElements=r,Object(o.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new k([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);m(e,this.elementShape,"TensorList shape mismatch: ");const r=x(this.elementShape,this.tensors,e);return Object(o.tidy)((()=>{const e=this.tensors.map((e=>Object(o.reshape)(e,r)));return Object(o.stack)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=x(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,m(r.shape,e,"TensorList shape mismatch: "),Object(o.reshape)(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(m(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(o.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new k([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let i=0;i<Math.min(this.tensors.length,e);++i)t.tensors[i]=this.tensors[i];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);m(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=x(this.elementShape,this.tensors,t);return Object(o.reshape)(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);m(this.elementShape,t.shape,"TensorList shape mismatch: "),Object(o.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);m(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=x(this.elementShape,this.tensors,n);return 0===e.length?Object(o.tensor)([],[0].concat(r)):Object(o.tidy)((()=>{const t=e.map((i=>Object(o.reshape)(this.tensors[i],r)));return Object(o.stack)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);m(this.elementShape,t,"TensorList shape mismatch: ");const n=x(this.elementShape,this.tensors,t);return 0===this.size()?Object(o.tensor)([],[0].concat(n)):Object(o.tidy)((()=>{const e=this.tensors.map((e=>Object(o.reshape)(e,n)));return Object(o.concat)(e,0)}))}}const w=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=Object(l.d)("thenBranch",e,t,n),o=Object(l.d)("elseBranch",e,t,n),c=Object(l.d)("cond",e,t,n),d=Object(l.d)("args",e,t,n);return(await c.data())[0]?n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap):n.functionMap[o].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Object(l.d)("body",e,t,n),o=Object(l.d)("cond",e,t,n),c=Object(l.d)("args",e,t,n),d=await n.functionMap[o].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap),h=c.map((e=>e.id));let f=await d[0].data();d.forEach((e=>{e.kept||-1!==h.indexOf(e.id)||e.dispose()}));let m=c;for(;f[0];){const e=m;m=await n.functionMap[r].executeFunctionAsync(m,n.tensorArrayMap,n.tensorListMap);const t=m.map((e=>e.id));e.forEach((e=>{e.kept||-1!==h.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const c=await n.functionMap[o].executeFunctionAsync(m,n.tensorArrayMap,n.tensorListMap);f=await c[0].data(),c.forEach((e=>{e.kept||-1!==h.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return m}case"LoopCond":{const r=Object(l.d)("pred",e,t,n);return[Object(l.a)(r)]}case"Switch":{const r=Object(l.d)("pred",e,t,n);let data=Object(l.d)("data",e,t,n);return data.kept||(data=Object(l.a)(data)),(await r.data())[0]?[void 0,data]:[data,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==Object(l.e)(e,t,n)));if(r){const data=Object(l.e)(r,t,n);return[Object(l.a)(data)]}return}case"Enter":{const r=Object(l.d)("frameName",e,t,n),data=Object(l.d)("tensor",e,t,n);return n.enterFrame(r),[Object(l.a)(data)]}case"Exit":{const data=Object(l.d)("tensor",e,t,n);return n.exitFrame(),[Object(l.a)(data)]}case"NextIteration":{const data=Object(l.d)("tensor",e,t,n);return n.nextIteration(),[Object(l.a)(data)]}case"TensorArrayV3":{const r=Object(l.d)("size",e,t,n),c=Object(l.d)("dtype",e,t,n),d=Object(l.d)("elementShape",e,t,n),h=Object(l.d)("dynamicSize",e,t,n),f=Object(l.d)("clearAfterRead",e,t,n),m=Object(l.d)("identicalElementShapes",e,t,n),y=Object(l.d)("name",e,t,n),x=new O(y,c,r,d,m,h,f);return n.addTensorArray(x),[x.idTensor,Object(o.scalar)(1)]}case"TensorArrayWriteV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=Object(l.d)("index",e,t,n),c=Object(l.d)("tensor",e,t,n),d=n.getTensorArray(r.id);return d.write(o,c),[d.idTensor]}case"TensorArrayReadV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=Object(l.d)("index",e,t,n);return[n.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=Object(l.d)("indices",e,t,n),c=Object(l.d)("dtype",e,t,n);return[n.getTensorArray(r.id).gather(o,c)]}case"TensorArrayScatterV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=Object(l.d)("indices",e,t,n),c=Object(l.d)("tensor",e,t,n),d=n.getTensorArray(r.id);return d.scatter(o,c),[d.idTensor]}case"TensorArrayConcatV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=n.getTensorArray(r.id),c=Object(l.d)("dtype",e,t,n);return[o.concat(c)]}case"TensorArraySplitV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=Object(l.d)("tensor",e,t,n),c=Object(l.d)("lengths",e,t,n),d=n.getTensorArray(r.id);return d.split(c,o),[d.idTensor]}case"TensorArraySizeV3":{const r=Object(l.d)("tensorArrayId",e,t,n),c=n.getTensorArray(r.id);return[Object(o.scalar)(c.size(),"int32")]}case"TensorArrayCloseV3":{const r=Object(l.d)("tensorArrayId",e,t,n),o=n.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("index",e,t,n),c=Object(l.d)("tensor",e,t,n),d=n.getTensorList(r.id);return d.setItem(o,c),[d.idTensor]}case"TensorListGetItem":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("index",e,t,n),c=Object(l.d)("elementShape",e,t,n),d=Object(l.d)("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(o,c,d)]}case"TensorListScatterV2":case"TensorListScatter":{const r=Object(l.d)("indices",e,t,n),c=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const c=Math.max(...t);if(null!=r&&-1!==r&&c>=r)throw new Error(`Max index must be < array size (${c}  vs. ${r})`);const l=new k([],n,e.dtype,r),d=Object(o.unstack)(e,0);return t.forEach(((e,t)=>{l.setItem(e,d[t])})),l}(Object(l.d)("tensor",e,t,n),r,Object(l.d)("elementShape",e,t,n),Object(l.d)("numElements",e,t,n));return n.addTensorList(c),[c.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=Object(l.d)("elementShape",e,t,n),o=Object(l.d)("elementDType",e,t,n);let c;c="TensorListReserve"===e.op?"numElements":"maxNumElements";const d=Object(l.d)(c,e,t,n),h=function(e,t,n,r){return new k([],e,t,r)}(r,o,0,"TensorListReserve"===e.op?-1:d);return n.addTensorList(h),[h.idTensor]}case"TensorListGather":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("indices",e,t,n),c=Object(l.d)("elementShape",e,t,n),d=Object(l.d)("elementDType",e,t,n);return[n.getTensorList(r.id).gather(o,d,c)]}case"TensorListStack":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("elementShape",e,t,n),c=Object(l.d)("elementDType",e,t,n),d=Object(l.d)("numElements",e,t,n);return[n.getTensorList(r.id).stack(o,c,d)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);m(e.shape.slice(1),t,"TensorList shape mismatch: ");const c=Object(o.unstack)(e);return new k(c,t,r)}(Object(l.d)("tensor",e,t,n),Object(l.d)("elementShape",e,t,n),Object(l.d)("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=Object(l.d)("tensorListId",e,t,n),o=n.getTensorList(r.id),c=Object(l.d)("dtype",e,t,n),d=Object(l.d)("elementShape",e,t,n);return[o.concat(c,d)]}case"TensorListPushBack":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("tensor",e,t,n),c=n.getTensorList(r.id);return c.pushBack(o),[c.idTensor]}case"TensorListPopBack":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("elementShape",e,t,n),c=Object(l.d)("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(o,c)]}case"TensorListSplit":{const r=Object(l.d)("tensor",e,t,n),c=Object(l.d)("elementShape",e,t,n),d=function(e,t,n){let r=0;const c=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const l=v(e.shape.slice(1),n),d=0===r?0:e.size/r,h=Object(o.tidy)((()=>{const n=[];e=Object(o.reshape)(e,[1,r,d]);for(let i=0;i<t.length;++i){const r=[0,0===i?0:c[i-1],0],h=[1,t[i],d];n[i]=Object(o.reshape)(Object(o.slice)(e,r,h),l)}return e.dispose(),n})),f=new k([],n,e.dtype,t.length);for(let i=0;i<h.length;i++)f.setItem(i,h[i]);return f}(r,Object(l.d)("lengths",e,t,n),c);return n.addTensorList(d),[d.idTensor]}case"TensorListLength":{const r=Object(l.d)("tensorListId",e,t,n),c=n.getTensorList(r.id);return[Object(o.scalar)(c.size(),"int32")]}case"TensorListResize":{const r=Object(l.d)("tensorListId",e,t,n),o=Object(l.d)("size",e,t,n),c=n.getTensorList(r.id).resize(o);return n.addTensorList(c),[c.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function I(e,t,n){const[r,o]=Object(l.d)("fusedOps",e,t,n),c="biasadd"===r,d=!c,h="prelu"===o,f="fusedbatchnorm"===r,m=Object(l.d)("numArgs",e,t,n);if(c){if(h&&2!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!h&&c&&1!==m)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(f)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const y=Object(l.d)("strides",e,t,n),x=Object(l.c)(e,t,n),v=Object(l.d)("dataFormat",e,t,n).toUpperCase(),O=Object(l.d)("dilations",e,t,n);let[k,w]=Object(l.d)("args",e,t,n);d&&(w=k,k=void 0);return{stride:y,pad:x,dataFormat:v,dilations:O,biasArg:k,preluArg:w,activationFunc:o,leakyreluAlpha:Object(l.d)("leakyreluAlpha",e,t,n)}}function S(e,t,n){return{boxes:Object(l.d)("boxes",e,t,n),scores:Object(l.d)("scores",e,t,n),maxOutputSize:Object(l.d)("maxOutputSize",e,t,n),iouThreshold:Object(l.d)("iouThreshold",e,t,n),scoreThreshold:Object(l.d)("scoreThreshold",e,t,n),softNmsSigma:Object(l.d)("softNmsSigma",e,t,n)}}var N=n(297);class T{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Object(o.scalar)(0),this.tensorMap=new Map,Object(o.keep)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return N.a(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Object(o.tidy)((()=>{const e=Object(o.unstack)(t),r=n.length,c=e.length;o.util.assert(r===c,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${c} elements.`));for(let i=0;i<r;i++){const t=n[i],r=e[i];Object(o.keep)(r),this.tensorMap.set(t,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Object(o.tidy)((()=>{const e=[];for(let i=0;i<n.length;i++){const r=n[i],o=this.findWithDefault(r,t);e.push(o)}return Object(o.stack)(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function j(e,t,n,c,f=o.tidy){const m=((e,t,n)=>{switch(e.category){case"arithmetic":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[o.add(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"AddN":return[o.addN(Object(l.d)("tensors",e,t,n))];case"FloorMod":case"Mod":return[o.mod(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Mul":return[o.mul(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"RealDiv":case"Div":return[o.div(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"DivNoNan":return[o.divNoNan(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"FloorDiv":return[o.floorDiv(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Sub":return[o.sub(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Minimum":return[o.minimum(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Maximum":return[o.maximum(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Pow":return[o.pow(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"SquaredDifference":return[o.squaredDifference(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Abs":case"ComplexAbs":return[o.abs(Object(l.d)("x",e,t,n))];case"Acos":return[o.acos(Object(l.d)("x",e,t,n))];case"Acosh":return[o.acosh(Object(l.d)("x",e,t,n))];case"Asin":return[o.asin(Object(l.d)("x",e,t,n))];case"Asinh":return[o.asinh(Object(l.d)("x",e,t,n))];case"Atan":return[o.atan(Object(l.d)("x",e,t,n))];case"Atan2":return[o.atan2(Object(l.d)("x",e,t,n),Object(l.d)("y",e,t,n))];case"Atanh":return[o.atanh(Object(l.d)("x",e,t,n))];case"Ceil":return[o.ceil(Object(l.d)("x",e,t,n))];case"Complex":return[o.complex(Object(l.d)("real",e,t,n),Object(l.d)("imag",e,t,n))];case"Cos":return[o.cos(Object(l.d)("x",e,t,n))];case"Cosh":return[o.cosh(Object(l.d)("x",e,t,n))];case"Elu":return[o.elu(Object(l.d)("x",e,t,n))];case"Erf":return[o.erf(Object(l.d)("x",e,t,n))];case"Exp":return[o.exp(Object(l.d)("x",e,t,n))];case"Expm1":return[o.expm1(Object(l.d)("x",e,t,n))];case"Floor":return[o.floor(Object(l.d)("x",e,t,n))];case"Log":return[o.log(Object(l.d)("x",e,t,n))];case"Log1p":return[o.log1p(Object(l.d)("x",e,t,n))];case"Imag":return[o.imag(Object(l.d)("x",e,t,n))];case"Neg":return[o.neg(Object(l.d)("x",e,t,n))];case"Reciprocal":return[o.reciprocal(Object(l.d)("x",e,t,n))];case"Real":return[o.real(Object(l.d)("x",e,t,n))];case"Relu":return[o.relu(Object(l.d)("x",e,t,n))];case"Round":return[o.round(Object(l.d)("x",e,t,n))];case"Selu":return[o.selu(Object(l.d)("x",e,t,n))];case"Sigmoid":return[o.sigmoid(Object(l.d)("x",e,t,n))];case"Sin":return[o.sin(Object(l.d)("x",e,t,n))];case"Sign":return[o.sign(Object(l.d)("x",e,t,n))];case"Sinh":return[o.sinh(Object(l.d)("x",e,t,n))];case"Softplus":return[o.softplus(Object(l.d)("x",e,t,n))];case"Sqrt":return[o.sqrt(Object(l.d)("x",e,t,n))];case"Square":return[o.square(Object(l.d)("x",e,t,n))];case"Tanh":return[o.tanh(Object(l.d)("x",e,t,n))];case"Tan":return[o.tan(Object(l.d)("x",e,t,n))];case"ClipByValue":return[o.clipByValue(Object(l.d)("x",e,t,n),Object(l.d)("clipValueMin",e,t,n),Object(l.d)("clipValueMax",e,t,n))];case"Relu6":return[o.relu6(Object(l.d)("x",e,t,n))];case"Rsqrt":return[o.rsqrt(Object(l.e)(e.inputNames[0],t,n))];case"Prod":return[o.prod(Object(l.d)("x",e,t,n),Object(l.d)("axes",e,t,n))];case"LeakyRelu":return[o.leakyRelu(Object(l.d)("x",e,t,n),Object(l.d)("alpha",e,t,n))];case"Prelu":return[o.prelu(Object(l.d)("x",e,t,n),Object(l.d)("alpha",e,t,n))];case"IsNan":return[o.isNaN(Object(l.e)(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return w(e,t,n);case"convolution":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Conv1D":{const r=Object(l.d)("stride",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("dataFormat",e,t,n).toUpperCase(),h=Object(l.d)("dilation",e,t,n);return[o.conv1d(Object(l.d)("x",e,t,n),Object(l.d)("filter",e,t,n),r,c,d,h)]}case"Conv2D":{const r=Object(l.d)("strides",e,t,n),c=Object(l.c)(e,t,n),d=Object(l.d)("dataFormat",e,t,n).toUpperCase(),h=Object(l.d)("dilations",e,t,n);return[o.conv2d(Object(l.d)("x",e,t,n),Object(l.d)("filter",e,t,n),[r[1],r[2]],c,d,[h[1],h[2]])]}case"_FusedConv2D":{const{stride:r,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:m,activationFunc:y,leakyreluAlpha:x}=I(e,t,n);return[o.fused.conv2d({x:Object(l.d)("x",e,t,n),filter:Object(l.d)("filter",e,t,n),strides:[r[1],r[2]],pad:c,dataFormat:d,dilations:[h[1],h[2]],bias:f,activation:y,preluActivationWeights:m,leakyreluAlpha:x})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:m,activationFunc:y,leakyreluAlpha:x}=I(e,t,n);return[o.fused.depthwiseConv2d({x:Object(l.d)("x",e,t,n),filter:Object(l.d)("filter",e,t,n),strides:[r[1],r[2]],pad:c,dataFormat:d,dilations:[h[1],h[2]],bias:f,activation:y,preluActivationWeights:m,leakyreluAlpha:x})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Object(l.d)("outputShape",e,t,n),c=Object(l.d)("strides",e,t,n),d=Object(l.c)(e,t,n);return[o.conv2dTranspose(Object(l.d)("x",e,t,n),Object(l.d)("filter",e,t,n),r,[c[1],c[2]],d)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Object(l.d)("strides",e,t,n),c=Object(l.c)(e,t,n),d=Object(l.d)("dilations",e,t,n),h=Object(l.d)("dataFormat",e,t,n).toUpperCase();return[o.depthwiseConv2d(Object(l.d)("input",e,t,n),Object(l.d)("filter",e,t,n),[r[1],r[2]],c,h,[d[1],d[2]])]}case"Conv3D":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("dataFormat",e,t,n).toUpperCase(),h=Object(l.d)("dilations",e,t,n);return[o.conv3d(Object(l.d)("x",e,t,n),Object(l.d)("filter",e,t,n),[r[1],r[2],r[3]],c,d,[h[1],h[2],h[3]])]}case"AvgPool":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("kernelSize",e,t,n);return[o.avgPool(Object(l.d)("x",e,t,n),[d[1],d[2]],[r[1],r[2]],c)]}case"MaxPool":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("kernelSize",e,t,n);return[o.maxPool(Object(l.d)("x",e,t,n),[d[1],d[2]],[r[1],r[2]],c)]}case"MaxPoolWithArgmax":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("kernelSize",e,t,n),h=Object(l.d)("includeBatchInIndex",e,t,n),{result:f,indexes:m}=o.maxPoolWithArgmax(Object(l.d)("x",e,t,n),[d[1],d[2]],[r[1],r[2]],c,h);return[f,m]}case"AvgPool3D":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("kernelSize",e,t,n);return[o.avgPool3d(Object(l.d)("x",e,t,n),[d[1],d[2],d[3]],[r[1],r[2],r[3]],c)]}case"MaxPool3D":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("kernelSize",e,t,n);return[o.maxPool3d(Object(l.d)("x",e,t,n),[d[1],d[2],d[3]],[r[1],r[2],r[3]],c)]}case"Dilation2D":{const r=Object(l.d)("strides",e,t,n),c=Object(l.d)("pad",e,t,n),d=Object(l.d)("dilations",e,t,n),h=r[1],f=r[2],m=d[1],y=d[2];return[o.dilation2d(Object(l.d)("x",e,t,n),Object(l.d)("filter",e,t,n),[h,f],c,[m,y],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Fill":{const r=Object(l.d)("shape",e,t,n),c=Object(l.d)("dtype",e,t,n),d=Object(l.d)("value",e,t,n);return[o.fill(r,d,c)]}case"LinSpace":{const r=Object(l.d)("start",e,t,n),c=Object(l.d)("stop",e,t,n),d=Object(l.d)("num",e,t,n);return[o.linspace(r,c,d)]}case"Multinomial":{const r=Object(l.d)("logits",e,t,n),c=Object(l.d)("numSamples",e,t,n),d=Object(l.d)("seed",e,t,n);return[o.multinomial(r,c,d)]}case"OneHot":{const r=Object(l.d)("indices",e,t,n),c=Object(l.d)("depth",e,t,n),d=Object(l.d)("onValue",e,t,n),h=Object(l.d)("offValue",e,t,n),f=Object(l.d)("dtype",e,t,n);return[o.oneHot(r,c,d,h,f)]}case"Ones":return[o.ones(Object(l.d)("shape",e,t,n),Object(l.d)("dtype",e,t,n))];case"OnesLike":return[o.onesLike(Object(l.d)("x",e,t,n))];case"RandomStandardNormal":return[o.randomStandardNormal(Object(l.d)("shape",e,t,n),Object(l.d)("dtype",e,t,n),Object(l.d)("seed",e,t,n))];case"RandomUniform":return[o.randomUniform(Object(l.d)("shape",e,t,n),Object(l.d)("minval",e,t,n),Object(l.d)("maxval",e,t,n),Object(l.d)("dtype",e,t,n))];case"Range":{const r=Object(l.d)("start",e,t,n),c=Object(l.d)("stop",e,t,n),d=Object(l.d)("step",e,t,n);return[o.range(r,c,d,Object(l.d)("dtype",e,t,n))]}case"TruncatedNormal":{const r=Object(l.d)("shape",e,t,n),c=Object(l.d)("mean",e,t,n),d=Object(l.d)("stdDev",e,t,n),h=Object(l.d)("seed",e,t,n);return[o.truncatedNormal(r,c,d,Object(l.d)("dtype",e,t,n),h)]}case"Zeros":return[o.zeros(Object(l.d)("shape",e,t,n),Object(l.d)("dtype",e,t,n))];case"ZerosLike":return[o.zerosLike(Object(l.d)("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,o,c=r)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:o,maxOutputSize:l,iouThreshold:d,scoreThreshold:h,softNmsSigma:f}=S(e,t,n),m=await c.image.nonMaxSuppressionWithScoreAsync(r,o,l,d,h,f);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:o,maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=S(e,t,n),m=Object(l.d)("padToMaxOutputSize",e,t,n),y=await c.image.nonMaxSuppressionPaddedAsync(r,o,d,h,f,m);return[y.selectedIndices,y.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:o,maxOutputSize:l,iouThreshold:d,scoreThreshold:h}=S(e,t,n);return[await c.image.nonMaxSuppressionAsync(r,o,l,d,h)]}case"Where":{const r=c.cast(Object(l.d)("condition",e,t,n),"bool"),o=[await c.whereAsync(r)];return r.dispose(),o}case"ListDiff":return c.setdiff1dAsync(Object(l.d)("x",e,t,n),Object(l.d)("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"LowerBound":{const r=Object(l.d)("sortedSequence",e,t,n),c=Object(l.d)("values",e,t,n);return[o.lowerBound(r,c)]}case"TopKV2":{const r=Object(l.d)("x",e,t,n),c=Object(l.d)("k",e,t,n),d=Object(l.d)("sorted",e,t,n),h=o.topk(r,c,d);return[h.values,h.indices]}case"UpperBound":{const r=Object(l.d)("sortedSequence",e,t,n),c=Object(l.d)("values",e,t,n);return[o.upperBound(r,c)]}case"Unique":{const r=Object(l.d)("x",e,t,n),c=o.unique(r);return[c.values,c.indices]}case"UniqueV2":{const r=Object(l.d)("x",e,t,n),c=Object(l.d)("axis",e,t,n),d=o.unique(r,c);return[d.values,d.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"ResizeBilinear":{const r=Object(l.d)("images",e,t,n),c=Object(l.d)("size",e,t,n),d=Object(l.d)("alignCorners",e,t,n),h=Object(l.d)("halfPixelCenters",e,t,n);return[o.image.resizeBilinear(r,[c[0],c[1]],d,h)]}case"ResizeNearestNeighbor":{const r=Object(l.d)("images",e,t,n),c=Object(l.d)("size",e,t,n),d=Object(l.d)("alignCorners",e,t,n),h=Object(l.d)("halfPixelCenters",e,t,n);return[o.image.resizeNearestNeighbor(r,[c[0],c[1]],d,h)]}case"CropAndResize":{const image=Object(l.d)("image",e,t,n),r=Object(l.d)("boxes",e,t,n),c=Object(l.d)("boxInd",e,t,n),d=Object(l.d)("cropSize",e,t,n),h=Object(l.d)("method",e,t,n),f=Object(l.d)("extrapolationValue",e,t,n);return[o.image.cropAndResize(image,r,c,d,h,f)]}case"ImageProjectiveTransformV3":{const r=Object(l.d)("images",e,t,n),c=Object(l.d)("transforms",e,t,n),d=Object(l.d)("outputShape",e,t,n),h=Object(l.d)("fillValue",e,t,n),f=Object(l.d)("interpolation",e,t,n),m=Object(l.d)("fillMode",e,t,n);return[o.image.transform(r,c,f.toLowerCase(),m.toLowerCase(),h,d)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Object(l.d)("default",e,t,n);return[Object(l.e)(e.name,t,n)||r];case"Placeholder":return[Object(l.e)(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const data=Object(l.d)("x",e,t,n);return[Object(l.a)(data)]}case"IdentityN":return Object(l.d)("x",e,t,n).map((e=>Object(l.a)(e)));case"Snapshot":const c=Object(l.d)("x",e,t,n);return[Object(l.a)(c)];case"Shape":return[o.tensor1d(Object(l.d)("x",e,t,n).shape,"int32")];case"ShapeN":return Object(l.d)("x",e,t,n).map((e=>o.tensor1d(e.shape)));case"Size":return[o.scalar(Object(l.d)("x",e,t,n).size,"int32")];case"Rank":return[o.scalar(Object(l.d)("x",e,t,n).rank,"int32")];case"NoOp":return[o.scalar(1)];case"Print":const input=Object(l.d)("x",e,t,n),data=Object(l.d)("data",e,t,n),d=Object(l.d)("message",e,t,n),h=Object(l.d)("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(d);for(let i=0;i<data.length;i++)console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0,h));return[input];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Equal":return[o.equal(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"NotEqual":return[o.notEqual(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Greater":return[o.greater(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"GreaterEqual":return[o.greaterEqual(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Less":return[o.less(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"LessEqual":return[o.lessEqual(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"LogicalAnd":return[o.logicalAnd(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"LogicalNot":return[o.logicalNot(Object(l.d)("a",e,t,n))];case"LogicalOr":return[o.logicalOr(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];case"Select":case"SelectV2":return[o.where(Object(l.d)("condition",e,t,n),Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[o.matMul(Object(l.d)("a",e,t,n),Object(l.d)("b",e,t,n),Object(l.d)("transposeA",e,t,n),Object(l.d)("transposeB",e,t,n))];case"Einsum":return[o.einsum(Object(l.d)("equation",e,t,n),...Object(l.d)("tensors",e,t,n))];case"Transpose":return[o.transpose(Object(l.d)("x",e,t,n),Object(l.d)("perm",e,t,n))];case"_FusedMatMul":const[r,c]=Object(l.d)("fusedOps",e,t,n),d="biasadd"===r,h="prelu"===c,f=Object(l.d)("numArgs",e,t,n),m=Object(l.d)("leakyreluAlpha",e,t,n);if(d){if(h&&2!==f)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!h&&1!==f)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[y,x]=Object(l.d)("args",e,t,n);return[o.fused.matMul({a:Object(l.d)("a",e,t,n),b:Object(l.d)("b",e,t,n),transposeA:Object(l.d)("transposeA",e,t,n),transposeB:Object(l.d)("transposeB",e,t,n),bias:y,activation:c,preluActivationWeights:x,leakyreluAlpha:m})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"EuclideanNorm":return[o.euclideanNorm(Object(l.d)("x",e,t,n),Object(l.d)("axis",e,t,n),Object(l.d)("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[o.batchNorm(Object(l.d)("x",e,t,n),Object(l.d)("mean",e,t,n),Object(l.d)("variance",e,t,n),Object(l.d)("offset",e,t,n),Object(l.d)("scale",e,t,n),Object(l.d)("epsilon",e,t,n))];case"LRN":return[o.localResponseNormalization(Object(l.d)("x",e,t,n),Object(l.d)("radius",e,t,n),Object(l.d)("bias",e,t,n),Object(l.d)("alpha",e,t,n),Object(l.d)("beta",e,t,n))];case"Softmax":return[o.softmax(Object(l.d)("x",e,t,n))];case"LogSoftmax":return[o.logSoftmax(Object(l.d)("x",e,t,n))];case"SparseToDense":return[o.sparseToDense(Object(l.d)("sparseIndices",e,t,n),Object(l.d)("outputShape",e,t,n),Object(l.d)("sparseValues",e,t,n),Object(l.d)("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Max":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.max(Object(l.d)("x",e,t,n),r,c)]}case"Mean":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.mean(Object(l.d)("x",e,t,n),r,c)]}case"Min":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.min(Object(l.d)("x",e,t,n),r,c)]}case"Sum":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.sum(Object(l.d)("x",e,t,n),r,c)]}case"All":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.all(Object(l.d)("x",e,t,n),r,c)]}case"Any":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.any(Object(l.d)("x",e,t,n),r,c)]}case"ArgMax":{const r=Object(l.d)("axis",e,t,n);return[o.argMax(Object(l.d)("x",e,t,n),r)]}case"ArgMin":{const r=Object(l.d)("axis",e,t,n);return[o.argMin(Object(l.d)("x",e,t,n),r)]}case"Prod":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("keepDims",e,t,n);return[o.prod(Object(l.d)("x",e,t,n),r,c)]}case"Cumprod":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("exclusive",e,t,n),d=Object(l.d)("reverse",e,t,n);return[o.cumprod(Object(l.d)("x",e,t,n),r,c,d)]}case"Cumsum":{const r=Object(l.d)("axis",e,t,n),c=Object(l.d)("exclusive",e,t,n),d=Object(l.d)("reverse",e,t,n);return[o.cumsum(Object(l.d)("x",e,t,n),r,c,d)]}case"Bincount":const r=Object(l.d)("x",e,t,n),c=Object(l.d)("weights",e,t,n),d=Object(l.d)("size",e,t,n);return[o.bincount(r,c,d)];case"DenseBincount":{const r=Object(l.d)("x",e,t,n),c=Object(l.d)("weights",e,t,n),d=Object(l.d)("size",e,t,n),h=Object(l.d)("binaryOutput",e,t,n);return[o.denseBincount(r,c,d,h)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return f((()=>((e,t,n,c=r)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=Object(l.d)("n",e,t,n),o=Object(l.d)("axis",e,t,n);let d=Object(l.d)("tensors",e,t,n);return d=d.slice(0,r),[c.concat(d,o)]}case"Gather":{const input=Object(l.d)("x",e,t,n),r=Object(l.d)("indices",e,t,n);return[c.gather(input,c.cast(r,"int32"),0)]}case"GatherV2":{const r=Object(l.d)("axis",e,t,n),o=Object(l.d)("batchDims",e,t,n),input=Object(l.d)("x",e,t,n),d=Object(l.d)("indices",e,t,n);return[c.gather(input,c.cast(d,"int32"),r,o)]}case"Reverse":{const r=Object(l.d)("dims",e,t,n),o=[];for(let i=0;i<r.length;i++)r[i]&&o.push(i);const input=Object(l.d)("x",e,t,n);return[c.reverse(input,o)]}case"ReverseV2":{const r=Object(l.d)("axis",e,t,n),input=Object(l.d)("x",e,t,n);return[c.reverse(input,r)]}case"Slice":{const r=Object(l.d)("begin",e,t,n),o=Object(l.d)("size",e,t,n);return[c.slice(Object(l.d)("x",e,t,n),r,o)]}case"StridedSlice":{const r=Object(l.d)("begin",e,t,n),o=Object(l.d)("end",e,t,n),d=Object(l.d)("strides",e,t,n),h=Object(l.d)("beginMask",e,t,n),f=Object(l.d)("endMask",e,t,n),m=Object(l.d)("ellipsisMask",e,t,n),y=Object(l.d)("newAxisMask",e,t,n),x=Object(l.d)("shrinkAxisMask",e,t,n),v=Object(l.d)("x",e,t,n);return[c.stridedSlice(v,r,o,d,h,f,m,y,x)]}case"Pack":return Object(o.tidy)((()=>{const r=Object(l.d)("axis",e,t,n),d=Object(l.d)("tensors",e,t,n),h=d[0].shape,f=c.squeeze(d[0]).shape,m=d.map((e=>{const t=o.util.arraysEqual(e.shape,h);if(!t&&!o.util.arraysEqual(c.squeeze(e).shape,f))throw new Error("the input tensors shape does not match");return t?e:c.reshape(e,h)}));return[c.stack(m,r)]}));case"Unpack":{const r=Object(l.d)("axis",e,t,n),o=Object(l.d)("tensor",e,t,n);return c.unstack(o,r)}case"Tile":{const r=Object(l.d)("reps",e,t,n);return[c.tile(Object(l.d)("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Object(l.d)("axis",e,t,n),o=Object(l.d)("numOrSizeSplits",e,t,n),d=Object(l.d)("x",e,t,n);return c.split(d,o,r)}case"ScatterNd":{const r=Object(l.d)("indices",e,t,n),o=Object(l.d)("values",e,t,n),d=Object(l.d)("shape",e,t,n);return[c.scatterND(r,o,d)]}case"GatherNd":{const r=Object(l.d)("x",e,t,n),o=Object(l.d)("indices",e,t,n);return[c.gatherND(r,o)]}case"SparseToDense":{const r=Object(l.d)("sparseIndices",e,t,n),o=Object(l.d)("outputShape",e,t,n),d=Object(l.d)("sparseValues",e,t,n),h=Object(l.d)("defaultValue",e,t,n);return[c.sparseToDense(r,d,o,d.dtype===h.dtype?h:c.cast(h,d.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:c,emptyRowIndicator:d,reverseIndexMap:h}=o.sparse.sparseFillEmptyRows(Object(l.d)("indices",e,t,n),Object(l.d)("values",e,t,n),Object(l.d)("denseShape",e,t,n),Object(l.d)("defaultValue",e,t,n));return[r,c,d,h]}case"SparseReshape":{const{outputIndices:r,outputShape:c}=o.sparse.sparseReshape(Object(l.d)("inputIndices",e,t,n),Object(l.d)("inputShape",e,t,n),Object(l.d)("newShape",e,t,n));return[r,c]}case"SparseSegmentMean":return[o.sparse.sparseSegmentMean(Object(l.d)("data",e,t,n),Object(l.d)("indices",e,t,n),Object(l.d)("segmentIds",e,t,n))];case"SparseSegmentSum":return[o.sparse.sparseSegmentSum(Object(l.d)("data",e,t,n),Object(l.d)("indices",e,t,n),Object(l.d)("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"FFT":return[o.fft(Object(l.d)("x",e,t,n))];case"IFFT":return[o.ifft(Object(l.d)("x",e,t,n))];case"RFFT":return[o.rfft(Object(l.d)("x",e,t,n))];case"IRFFT":return[o.irfft(Object(l.d)("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:c}=o.string.stringNGrams(Object(l.d)("data",e,t,n),Object(l.d)("dataSplits",e,t,n),Object(l.d)("separator",e,t,n),Object(l.d)("nGramWidths",e,t,n),Object(l.d)("leftPad",e,t,n),Object(l.d)("rightPad",e,t,n),Object(l.d)("padWidth",e,t,n),Object(l.d)("preserveShortSequences",e,t,n));return[r,c]}case"StringSplit":{const{indices:r,values:c,shape:d}=o.string.stringSplit(Object(l.d)("input",e,t,n),Object(l.d)("delimiter",e,t,n),Object(l.d)("skipEmpty",e,t,n));return[r,c,d]}case"StringToHashBucketFast":return[o.string.stringToHashBucketFast(Object(l.d)("input",e,t,n),Object(l.d)("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return f((()=>((e,t,n,o=r)=>{switch(e.op){case"Cast":return[o.cast(Object(l.d)("x",e,t,n),Object(l.d)("dtype",e,t,n))];case"ExpandDims":{const r=Object(l.d)("axis",e,t,n);return[o.expandDims(Object(l.d)("x",e,t,n),r)]}case"Squeeze":{const r=Object(l.d)("axis",e,t,n);return[o.squeeze(Object(l.d)("x",e,t,n),r)]}case"Reshape":return[o.reshape(Object(l.d)("x",e,t,n),Object(l.d)("shape",e,t,n))];case"MirrorPad":return[o.mirrorPad(Object(l.d)("x",e,t,n),Object(l.d)("padding",e,t,n),Object(l.d)("mode",e,t,n))];case"PadV2":case"Pad":return[o.pad(Object(l.d)("x",e,t,n),Object(l.d)("padding",e,t,n),Object(l.d)("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Object(l.d)("blockShape",e,t,n),c=Object(l.d)("paddings",e,t,n);return[o.spaceToBatchND(Object(l.d)("x",e,t,n),r,c)]}case"BatchToSpaceND":{const r=Object(l.d)("blockShape",e,t,n),c=Object(l.d)("crops",e,t,n);return[o.batchToSpaceND(Object(l.d)("x",e,t,n),r,c)]}case"DepthToSpace":{const r=Object(l.d)("blockSize",e,t,n),c=Object(l.d)("dataFormat",e,t,n).toUpperCase();return[o.depthToSpace(Object(l.d)("x",e,t,n),r,c)]}case"BroadcastTo":return[o.broadcastTo(Object(l.d)("x",e,t,n),Object(l.d)("shape",e,t,n))];case"BroadcastArgs":return[o.broadcastArgs(Object(l.d)("s0",e,t,n),Object(l.d)("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const o=Object(l.d)("keyDType",e,t,n),c=Object(l.d)("valueDType",e,t,n),d=new T(o,c);return r.addHashTable(e.name,d),[d.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=Object(l.d)("tableHandle",e,t,n,r),c=Object(l.d)("keys",e,t,n),d=Object(l.d)("values",e,t,n),h=r.getHashTableById(o.id);return[await h.import(c,d)]}case"LookupTableFind":case"LookupTableFindV2":{const o=Object(l.d)("tableHandle",e,t,n,r),c=Object(l.d)("keys",e,t,n),d=Object(l.d)("defaultValue",e,t,n),h=r.getHashTableById(o.id);return[await h.find(c,d)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=Object(l.d)("tableHandle",e,t,n,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,c);case"custom":const m=Object(h.b)(e.op);if(m&&m.customExecutor)return m.customExecutor(new d(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return o.util.isPromise(m)?m.then((data=>[].concat(data))):[].concat(m)}class C{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let i=0;i<this.contexts.length-1;i++){const t=this.contexts.slice(0,this.contexts.length-i);e.push(this.contextIdforContexts(t))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function $(e,t,n,r){const o=new Set,c=[];let d=null,h=null;const f=new Set,m=Object.keys(e).map((e=>Object(l.g)(e)[0]));let y=[];null!=r&&(y=r.map((e=>Object(l.g)(e.name)[0])));const x=[...t];for(;x.length>0;){const e=x.pop();(_(e)||F(e)||D(e))&&null==d&&(d=e,h=d.children.map((e=>e.name)).filter((e=>o.has(e)))),o.add(e.name),null==n[e.name]&&(-1===m.indexOf(e.name)&&-1===y.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((input=>{f.has(input.name)||(f.add(input.name),x.push(input))})):c.push(e.name)))}return{inputs:e,outputs:t,usedNodes:o,missingInputs:c,dynamicNode:d,syncInputs:h}}const E=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],A=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],R=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function _(e){return E.indexOf(e.op)>=0}function F(e){return A.indexOf(e.op)>=0}function D(e){return R.indexOf(e.op)>=0}class M{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new M(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((map,e)=>(map[e]=this._functions[e].signature,map)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=$(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:c}=n;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${c}]`);if(r.length>0){const n=t.map((e=>e.name)),o=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${o}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:o}=n,c=[],d=Object.keys(o).map((e=>Object(l.g)(e)[0])).map((t=>e.nodes[t])),h=e.initNodes;d.forEach((input=>{r.has(input.name)&&c.push(input)})),e.weights.forEach((e=>{r.has(e.name)&&c.push(e)})),null!=h&&h.forEach((e=>{r.has(e.name)&&c.push(e)}));const f=new Set,m=[];for(;c.length>0;){const e=c.pop();f.add(e.name),t[e.name]||m.push(e),e.children.forEach((e=>{!f.has(e.name)&&r.has(e.name)&&e.inputs.every((input=>f.has(input.name)))&&c.push(e)}))}return m}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[Object(l.g)(e)[0]])),c=t.map((e=>Object(l.g)(e)[0]));let d=c.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===d.length&&(d=this._outputs);const h=this.getCompilationKey(r,d);let f=this.compiledMap.get(h);null==f&&(f=this.compile(e,d),this.compiledMap.set(h,f));const m={},y={};return Object(o.tidy)((()=>{const n=new C(this.weightMap,m,y,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,o]=Object(l.g)(t),c=[];c[o]=e[t],r[n]=c}));const d=this.getFrozenTensorIds(r),h={};for(let i=0;i<f.length;i++){const e=f[i];if(!r[e.name]){const t=j(e,r,n,this._resourceManager);if(o.util.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.checkTensorForDisposal(e.name,e,r,n,d,c,h)}}return null==this.parent&&n.dispose(d),t.map((e=>Object(l.e)(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,o,c,d){"control"!==t.category&&-1===c.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(d[e.id]=(d[e.id]||0)+t.children.length)})),t.inputs.forEach((input=>{if("control"!==input.category){const e=Object(l.f)(input.name,n,r);null!=e&&e.forEach((e=>{if(e&&!e.kept&&!o.has(e.id)){const n=d[e.id];if(1===n){if(this.keepTensorForDebug){const[n,o]=Object(l.b)(t.name,r);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][o]=e}else e.dispose();delete d[e.id]}else null!=n&&d[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},c={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=Object(o.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){console.warn(e.message)}this.resetIntermediateTensors();const d=new C(this.weightMap,r,c,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,d,t,n);const h=t.map((e=>Object(l.e)(e,this.tensorsMap,d))),f=h.map((e=>e.id)),m=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...f,...m,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&d.dispose(this.keepIds),h}async executeFunctionAsync(e,t,n){const r=e.reduce(((map,e,t)=>(map[this.inputs[t].name]=e,map)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const o=Object.keys(e),c=o.map((e=>this.graph.nodes[Object(l.g)(e)[0]])),d=n.map((e=>Object(l.g)(e)[0]));let h=d.map((e=>this.graph.nodes[e]));0===h.length&&(h=this._outputs);const{usedNodes:f,missingInputs:m,dynamicNode:y,syncInputs:x}=$(e,h,this.weightMap,this._initNodes),v=[...c,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),O=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=Object(l.g)(t),o=[];o[r]=e[t],O[n]=o}));const k={},w=this.getFrozenTensorIds(O),I={};for(;v.length>0;){const e=this.processStack(c,v,t,O,I,w,d,k,f);await Promise.all(e)}null!=y||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const S=h.filter((e=>!_(e)&&!Object(l.e)(e.name,O,t))).map((e=>e.name));if(S.length>0){let e="";throw null!=y&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${x}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${o}]. Consider providing the following inputs: [${m}]. ${e}`)}return O}processStack(e,t,n,r,c,d,h,f,m){const y=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let x="";if("Enter"===e.node.op&&Object(l.d)("isConstant",e.node,r,n)&&([x]=Object(l.b)(e.node.name,n)),null==r[e.node.name]){const v=j(e.node,r,n,this._resourceManager);x||([x]=Object(l.b)(e.node.name,n));const O=n.currentContext;o.util.isPromise(v)?y.push(v.then((o=>(r[x]=o,n.currentContext=O,this.checkTensorForDisposal(x,e.node,r,n,d,h,f),this.processChildNodes(e.node,t,n,r,c,m),o)))):(r[x]=v,this.checkTensorForDisposal(x,e.node,r,n,d,h,f),this.processChildNodes(e.node,t,n,r,c,m))}else this.processChildNodes(e.node,t,n,r,c,m)}return y}processChildNodes(e,t,n,r,o,c){e.children.forEach((e=>{const[d]=Object(l.b)(e.name,n);!o[d]&&c.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Object(l.e)(e,r,n)))&&(o[d]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Object(l.e)(e,r,n)))&&(o[d]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const input=e[t],[n]=Object(l.g)(t),r=this.graph.nodes[n];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value,t=e.length===input.shape.length&&input.shape.every(((t,n)=>-1===e[n]||e[n]===t));o.util.assert(t,(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${input.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&o.util.assert(input.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${input.dtype}`))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Object(l.g)(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Object(l.g)(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class P{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class L{constructor(e,t={},n=o.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new P}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const path=this.modelUrl;if(null!=path.load)this.handler=path;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(path,this.loadOptions);else{const e=this.io.getLoadHandlers(path,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(path,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[path]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return o.util.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new M(c.a.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=c.a.Instance.transformGraph(e.modelInitializer);this.initializer=new M(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e=n instanceof o.Tensor?[n]:n,t={};return e.forEach(((e,i)=>t[this.structuredOutputKeys[i]]=e)),t}return n}normalizeInputs(e){if(!(e instanceof o.Tensor||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((map,t,i)=>(map[t]=e[i],map)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(map){return Object.keys(map).reduce(((e,t)=>(e[t]=[map[t]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function B(e,t={},n=o.io){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}model.json?tfjs-format=file`}(e));const r=new L(e,t,n);return await r.load(),r}function z(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!e.load)throw new Error(`modelUrl IO Handler ${e} has no load function`);const t=new L(e);return t.load(),t}const V="3.20.0"}])]);